<style>
/* PATCH: strike-through via keyboard 'S' */
.struck, [data-strike="1"]{ 
  text-decoration: line-through;
  opacity: .45;
}
</style>
<!DOCTYPE html>

<html lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Quiz Review</title><style>:root{--g:linear-gradient(135deg,#60a5fa,#a78bfa 40%,#f472b6);--bd:#334155;--bg:#0b1220}body{font-family:Arial,Helvetica,sans-serif;max-width:900px;margin:0 auto;padding:1.5rem;background:#0f172a;color:#e2e8f0}h1{text-align:center;position:relative;z-index:2;margin:0 0 .25rem;font-size:2rem;background:var(--g);-webkit-background-clip:text;background-clip:text;color:transparent;text-shadow:0 0 24px rgba(96,165,250,.25),0 0 36px rgba(167,139,250,.25)}#quiz-card{position:relative;background:#1f2937;border:2px solid #374151;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.6);padding:2rem 2rem 220px}.question-text{font-size:1.3rem;font-weight:800;margin-bottom:1rem;color:#f1f5f9}.choice{display:block;width:100%;margin:.35rem 0;padding:.7rem 1rem;border:2px solid #475569;border-radius:10px;background:#334155;color:#f8fafc;cursor:pointer;transition:transform .05s ease,background .2s,border .2s}.choice:hover{background:#1e293b;transform:translateY(-1px)}.choice.correct{border-color:#22c55e;background:#14532d}.choice.incorrect{border-color:#ef4444;background:#7f1d1d}#next-btn,#reset-btn,#prev-btn,#open-tab-btn{padding:.8rem 1.25rem;font-size:1rem;border:none;border-radius:10px;cursor:pointer}#explanation{margin-top:1rem;padding:1rem;border-radius:10px;background:var(--bg);border:1px solid var(--bd);display:none;line-height:1.45}#additional{margin-top:.75rem;padding:1rem;border-radius:10px;background:#111827;border:1px dashed var(--bd);font-size:.98rem;color:#d1d5db;display:none;line-height:1.45}#instr-btn{
  position: fixed;
  right: 16px;
  /* Place this button directly above the 'open in new tab' button (which is bottom:16px).
     Keep the original size and appearance; only change positioning. */
  bottom: calc(16px + 56px);
  left: auto;
  z-index: 9999;
  padding:.8rem 1.25rem;
  font-size:1rem;
  border:none;
  border-radius:10px;
  background:var(--bg);
  border:1px solid var(--bd);
  background-image:var(--g);
  -webkit-background-clip:text;
  background-clip:text;
  -webkit-text-fill-color:transparent;
  color:transparent;
  cursor:pointer;
  /* important: keep intrinsic size and prevent accidental full-width stretching */
  width: auto !important;
  max-width: none !important;
  display: inline-block;
  white-space: nowrap; /* ensure it doesn't wrap or stretch horizontally */
  box-sizing: border-box;
}#instr-panel{
position:fixed;
right:16px;
left:auto;
bottom:140px;
min-width:320px;
max-width:420px;
background:var(--bg);
border:1px solid var(--bd);
border-radius:12px;
box-shadow:0 12px 28px rgba(0,0,0,.55);
padding:.6rem;
display:none;
z-index:10006}#instr-panel textarea{width:100%;min-height:140px;background:#0f172a;color:#e5e7eb;border:1px solid var(--bd);border-radius:8px;padding:.5rem;font-family:ui-monospace,Menlo,monospace;font-size:.9rem}#instr-copy{margin-top:.5rem;padding:.45rem .7rem;border:none;border-radius:10px;background:#2563eb;color:#fff;cursor:pointer}#next-btn{position:absolute;right:12px;bottom:12px;background-color:var(--bg);border:1px solid var(--bd);background-image:var(--g);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;color:transparent}#prev-btn{position:absolute;left:12px;bottom:12px;background-color:var(--bg);border:1px solid var(--bd);background-image:var(--g);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;color:transparent}#prev-btn:before{content:'← ';font-weight:700}#next-btn:after{content:' →';font-weight:700}#reset-btn{position:absolute;left:50%;transform:translateX(-50%);bottom:12px;background:var(--bg);border:1px solid var(--bd);background-image:var(--g);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;color:transparent}#open-tab-btn{position:fixed;right:16px;bottom:16px;background:var(--bg);border:1px solid var(--bd);background-image:var(--g);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;color:transparent;box-shadow:0 4px 12px rgba(0,0,0,.35)}#save-btn{position:absolute;left:50%;bottom:56px;transform:translateX(-50%);background:#f59e0b;color:#111827;z-index:10005}#save-btn.saved{background:#16a34a;color:#fff}#review-menu-btn{position:absolute;left:calc(100% + 8px);top:-36px;padding:.45rem .7rem;font-size:.95rem;border:1px solid var(--bd);border-radius:10px;background:var(--bg);background-image:var(--g);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;color:transparent;cursor:pointer}#review-menu-btn:hover{background:#1f2937}#review-menu{position:absolute;top:56px;left:calc(100% + 8px);min-width:280px;max-width:360px;max-height:50vh;overflow:auto;background:var(--bg);border:1px solid var(--bd);border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.5);padding:.5rem;display:none}#review-menu h3{margin:.25rem .5rem .5rem;font-size:1rem;color:#e5e7eb}#review-menu ul{list-style:none;margin:0;padding:0}#review-menu li{display:flex;align-items:center;gap:.5rem;padding:.4rem .5rem;border-radius:8px}#review-menu li:hover{background:#111827}.rev-jump{flex:1;text-align:left;background:transparent;border:none;color:#d1d5db;cursor:pointer}.rev-remove{background:#ef4444;border:none;color:#fff;border-radius:8px;padding:.2rem .45rem;cursor:pointer}#import-btn{position:absolute;top:28px;left:calc(100% + 8px);padding:.45rem .7rem;font-size:.95rem;border:1px solid var(--bd);border-radius:10px;background:var(--bg);background-image:var(--g);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;color:transparent;cursor:pointer;box-shadow:0 4px 12px rgba(0,0,0,.35);z-index:10005}#import-btn:hover{background:#334155}#import-menu{position:absolute;top:56px;left:calc(100% + 8px);min-width:320px;max-width:420px;max-height:60vh;overflow:auto;background:var(--bg);border:1px solid var(--bd);border-radius:12px;box-shadow:0 12px 28px rgba(0,0,0,.55);padding:.6rem;display:none;z-index:10006}#import-menu h3{margin:.25rem .5rem .5rem;font-size:1rem;color:#e5e7eb}#import-menu textarea{width:100%;min-height:160px;background:#0f172a;color:#e5e7eb;border:1px solid var(--bd);border-radius:8px;padding:.5rem;font-family:ui-monospace,Menlo,monospace;font-size:.9rem}#search-wrap{margin-bottom:.75rem;position:relative}#search-input{width:100%;padding:.6rem .75rem;border-radius:10px;border:1px solid var(--bd);background:var(--bg);color:#e5e7f0}#search-results{position:absolute;top:100%;left:0;right:0;background:var(--bg);border:1px solid var(--bd);border-top:none;max-height:40vh;overflow:auto;border-radius:0 0 10px 10px;display:none;z-index:10007;list-style:none;margin:0;padding:0}#search-results li{padding:.5rem .75rem;cursor:pointer;border-top:1px solid #1f2937}#search-results li:hover{background:#111827}#jump-select{position:absolute;top:12px;left:-8px;transform:translateX(-100%);margin-left:0;padding:.2rem .45rem;border:1px solid var(--bd);border-radius:8px;background:var(--bg);color:#e5e7f0;font-size:.95rem}#jump-select:focus{outline:none;box-shadow:0 0 0 2px rgba(37,99,235,.35)}.qhead{white-space:nowrap}.choice .label{margin-right:.5rem;font-weight:700;opacity:.9}
/* Buttons styled with title gradient */
#viewer-toggle-btn,#arrange-btn,#reset-layout-btn,#evidence-toggle-btn,#upload-lectures-btn{
  margin:.4rem .4rem 0 0;display:inline-flex;align-items:center;gap:.5rem;
  padding:.45rem .8rem;border-radius:12px;border:1px solid rgba(255,255,255,.22);
  background:rgba(255,255,255,.06);backdrop-filter:blur(10px);
  font-weight:800;letter-spacing:.01em;background-image:var(--g);
  -webkit-background-clip:text;background-clip:text;color:transparent;
  text-shadow:0 0 18px rgba(96,165,250,.25);cursor:pointer
}
/* Layout and gap (>= 1.25in) */
#work-area{display:grid;grid-template-columns:1fr;column-gap:28px;align-items:start}
#work-area.viewer-open{grid-template-columns:minmax(0,1fr) minmax(420px,40%);column-gap:1.25in}
#pdf-pane{display:none;background:#111827;border:2px solid #374151;border-radius:14px;box-shadow:0 4px 14px rgba(0,0,0,.35);padding:.75rem}
#work-area.viewer-open #pdf-pane{display:block}
#pdf-title{margin:.25rem 0 .5rem;font-weight:800;letter-spacing:.01em;background-image:var(--g);-webkit-background-clip:text;background-clip:text;color:transparent}
#pdf-iframe{width:100%;height:72vh;border:0;background:#0b1220}
/* Toggle + list */
#resources-toggle{margin:.65rem 0 .25rem;display:block}
#resources-toggle > summary{
  cursor:pointer;user-select:none;display:inline-flex;align-items:center;gap:.5rem;
  padding:.45rem .75rem;border-radius:12px;border:1px solid rgba(255,255,255,.22);
  background:rgba(255,255,255,.06);backdrop-filter:blur(10px);
  font-weight:800;letter-spacing:.01em;background-image:var(--g);
  -webkit-background-clip:text;background-clip:text;color:transparent;
  text-shadow:0 0 18px rgba(96,165,250,.25);
}
#resources-panel{margin-top:.5rem;background:#1f2937;border:2px solid #374151;border-radius:14px;box-shadow:0 4px 12px rgba(0,0,0,.35);padding:.75rem}
#resources-list{display:flex;flex-direction:column;gap:.5rem;list-style:none;margin:0;padding:0}
.resources-link{display:flex;align-items:center;justify-content:space-between;gap:.75rem;text-decoration:none;border:1px solid #475569;background:#334155;border-radius:10px;padding:.55rem .75rem;color:#f8fafc;transition:transform .05s ease,background .2s,border .2s}
.resources-link:hover{background:#1e293b;transform:translateY(-1px)}
.resources-title{font-weight:700;letter-spacing:.01em}.resources-meta{opacity:.8;font-size:.9rem}
 
/* Arrange mode */
#work-area.viewer-open #quiz-card,#work-area.viewer-open #pdf-pane{resize:horizontal;overflow:auto}
body.arrange-mode #quiz-card,body.arrange-mode #pdf-pane{position:fixed;z-index:999;cursor:move;resize:both;overflow:auto;box-shadow:0 10px 30px rgba(0,0,0,.45)}
.drag-handle{position:absolute;top:6px;left:6px;font-size:.75rem;background:rgba(0,0,0,.45);color:#fff;padding:.2rem .45rem;border-radius:6px;display:none;user-select:none}
body.arrange-mode .drag-handle{display:block}

/* PDF viewer zoom controls */
#pdf-controls input[type="range"]::-webkit-slider-thumb{appearance:none;width:14px;height:14px;border-radius:50%;border:1px solid rgba(0,0,0,0.4);background:#fff;box-shadow:0 1px 2px rgba(0,0,0,0.35)}
#pdf-controls input[type="range"]{height:6px}
#pdf-close-btn{transition:transform .12s, background .12s}
#pdf-close-btn:hover{transform:translateY(-1px);background:rgba(255,255,255,0.04)}
#pdf-controls button{color:inherit}


/* Make the close button very visible: white rounded box with dark X */
#pdf-close-btn{
  background: white !important;
  color: #222 !important;
  border: 1px solid rgba(0,0,0,0.08) !important;
  box-shadow: 0 4px 14px rgba(0,0,0,0.22) !important;
  font-size: 20px !important;
  width: 36px !important;
  height: 36px !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  padding: 0 !important;
  line-height: 1 !important;
  text-align: center !important;
  cursor: pointer !important;
  opacity: 0.98 !important;
}
#pdf-close-btn:hover{ transform: translateY(-1px); }


/* Hide scrollbars inside the lecture viewer and iframe */
#pdf-pane { overflow: hidden !important; }
#pdf-pane iframe { overflow: hidden !important; scrollbar-width: none !important; -ms-overflow-style: none !important; }
#pdf-pane iframe::-webkit-scrollbar { display: none !important; width: 0 !important; height: 0 !important; }

/* Make the close button 25% smaller (from 36px -> 27px) and reduce font-size */
#pdf-close-btn{
  width: 27px !important;
  height: 27px !important;
  font-size: 16px !important;
  padding: 0 !important;
  border-radius: 6px !important;
}
#pdf-close-btn > * { pointer-events: none; }


/* Resizer handles for quiz-card and pdf-pane */
.resizer {
  position: absolute;
  width: 12px;
  height: 12px;
  background: rgba(0,0,0,0.0);
  border-radius: 2px;
  z-index: 2005;
  box-sizing: border-box;
}
/* Visible corner "dots" to help the user find the resizers */
.resizer:before{
  content: '';
  display: block;
  width: 6px;
  height: 6px;
  margin: 2px;
  border-radius: 1px;
  background: rgba(0,0,0,0.25);
  opacity: 0.65;
}
/* Cursor hints */
.resizer.n { cursor: n-resize; top: -6px; left: calc(50% - 6px); }
.resizer.s { cursor: s-resize; bottom: -6px; left: calc(50% - 6px); }
.resizer.e { cursor: e-resize; right: -6px; top: calc(50% - 6px); }
.resizer.w { cursor: w-resize; left: -6px; top: calc(50% - 6px); }
.resizer.ne { cursor: ne-resize; right: -6px; top: -6px; }
.resizer.nw { cursor: nw-resize; left: -6px; top: -6px; }
.resizer.se { cursor: se-resize; right: -6px; bottom: -6px; }
.resizer.sw { cursor: sw-resize; left: -6px; bottom: -6px; }

/* Ensure the panes have position relative/fixed so resizers sit correctly */
#quiz-card, #pdf-pane { position: relative; box-sizing: border-box; }


/* Close button: glass-like transparent background, bold X, no heavy solid fill */
#pdf-close-btn{
  background: rgba(255,255,255,0.06) !important;
  -webkit-backdrop-filter: blur(8px) !important;
  backdrop-filter: blur(8px) !important;
  border: 1px solid rgba(255,255,255,0.10) !important;
  color: inherit !important;
  font-weight: 700 !important;
  opacity: 0.98 !important;
  transition: background .12s, transform .12s, box-shadow .12s;
}
#pdf-close-btn:hover{
  background: rgba(255,255,255,0.10) !important;
  transform: translateY(-1px);
  box-shadow: 0 6px 18px rgba(0,0,0,0.18);
}


/* ===== Fix: make explanation area expand without being overlapped by bottom buttons ===== */
#explanation, #additional {
  max-height: calc(60vh - 160px);
  overflow: auto;
  margin-bottom: 12px;
  box-sizing: border-box;
  padding-right: 6px; /* avoid scrollbar overlapping text */
  -webkit-overflow-scrolling: touch;
}
#next-btn, #prev-btn, #reset-btn, #save-btn {
  z-index: 10005; /* keep buttons on top but allow content to scroll above them */
}
/* ensure choice text wraps to avoid horizontal overflow */
.choice { white-space: normal; word-wrap: break-word; }


/* Evidence/Citation UI */
#evidence-toolbar{
  display:flex;justify-content:flex-end;align-items:center;gap:.5rem;
  margin-top:.25rem;margin-bottom:.25rem;
  font: inherit;
}
#evidence-toggle-btn{ /* picks up shared button styles from the expanded selector */ }

#evidence-panel{
  display:none;margin:.35rem 0 0 0;padding:.75rem 1rem;border-radius:12px;
  border:1px solid rgba(255,255,255,.18);
  background:rgba(255,255,255,.05);
  color:inherit;font-size:.95rem;line-height:1.35;
}
#evidence-panel .ev-row{margin:.15rem 0}
#evidence-panel .ev-key{opacity:.85;margin-right:.35rem}
#evidence-panel code{background:rgba(0,0,0,0.25);padding:.1rem .25rem;border-radius:6px}
#evidence-panel .anchors{margin-top:.35rem}
#evidence-panel .anchor-item{opacity:.9;font-size:.9rem}

.resources-list li{
  position: relative;
  padding-right: 28px; /* space for the remove X */
}
.resource-remove{
  position: absolute;
  right: 6px;
  top: 8px;
  width: 20px;
  height: 20px;
  line-height: 18px;
  text-align: center;
  border-radius: 50%;
  border: 1px solid var(--border-muted,#555);
  cursor: pointer;
  user-select: none;
  font-weight: 700;
  opacity: 0.7;
}
.resource-remove:hover{ opacity: 1; }
#pptx-overlay{
  position: absolute;
  inset: 46px 10px 10px 10px; /* below title bar if any */
  background: rgba(20,20,20,0.85);
  color: #fff;
  padding: 18px;
  border-radius: 8px;
  overflow: auto;
  display: none;
}
#pptx-overlay h3{ margin: 0 0 8px 0; font-size: 1.05rem; }
#pptx-overlay p{ margin: 0 0 8px 0; font-size: 0.95rem; }


/* Bulk select/delete UI and hide old per-item X */
.resource-remove{ display:none !important; }

/* Selection UI */
.select-mode #resources-list li{
  cursor: pointer;
  padding-left: 28px; /* space for check */
  position: relative;
}
.resource-select{
  display: none;
  position: absolute;
  left: 8px;
  top: 10px;
  width: 16px;
  height: 16px;
  border: 2px solid var(--border-muted,#666);
  border-radius: 3px;
  box-sizing: border-box;
  background: transparent;
}
.select-mode .resource-select{ display: inline-block; }
#resources-list li.selected .resource-select{
  background: var(--accent,#4a90e2);
  border-color: var(--accent,#4a90e2);
}
#resources-list li.selected .resources-title{
  text-decoration: underline;
}

/* Buttons */
#select-lectures-btn,#bulk-delete-lectures-btn{
  margin-left: 6px;
}
#bulk-delete-lectures-btn{ display: none; }


/* Hide legacy select/delete buttons near upload */
#select-lectures-btn, #bulk-delete-lectures-btn { display: none !important; }

/* Summary action buttons (only show when Lecture PDFs panel is open) */
#resources-summary { display:flex; align-items:center; justify-content:space-between; }
#resources-summary .resources-actions { display:flex; align-items:center; gap:.5rem; }
#pdfs-select-btn, #pdfs-remove-btn {
  display:none;
  padding:.35rem .6rem;
  border-radius:.5rem;
  border:1px solid var(--border-muted, #444);
  background: var(--btn-bg, rgba(255,255,255,0.04));
  color: var(--fg, #eaeaea);
  font: inherit;
  cursor:pointer;
}
#pdfs-select-btn:hover, #pdfs-remove-btn:hover { filter: brightness(1.12); }

/* Selection highlight — match title font/color weight */
#resources-toggle.select-mode #resources-list li.selected {
  background: rgba(127, 157, 255, 0.16);
  border-radius: .5rem;
}
#resources-toggle.select-mode #resources-list li.selected .resources-title {
  color: var(--fg, #eaeaea);
  font-weight: 600;
  text-decoration: underline;
}

</style>
<style>
/* === Select/Remove buttons styled to match the title gradient === */
#pdfs-select-btn, #pdfs-remove-btn{
  display:none;
  margin-left:.45rem;
  padding:.45rem .8rem;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.22);
  background:rgba(255,255,255,.06);
  backdrop-filter:blur(10px);
  font-weight:800;
  letter-spacing:.01em;
  background-image:var(--g);
  -webkit-background-clip:text;
  background-clip:text;
  -webkit-text-fill-color:transparent;
  color:transparent;
  text-shadow:0 0 18px rgba(96,165,250,.25), 0 0 18px rgba(167,139,250,.15);
  cursor:pointer;
}
#resources-summary .resources-actions { display:inline-flex; align-items:center; gap:.45rem; margin-left:.5rem; }

#resources-toggle.select-mode #resources-list li.selected {
  background: rgba(96,165,250,0.12);
  border: 1px solid rgba(96,165,250,0.35);
}
#resources-toggle.select-mode #resources-list li.selected .resources-title {
  text-decoration: underline;
  font-weight: 800;
}
</style>


<style>
/* Boxed action buttons */
#pdfs-select-btn, #pdfs-remove-btn{
  display:none;
  margin-left:.45rem;
  padding:.45rem .9rem;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.22);
  background:rgba(255,255,255,.06);
  backdrop-filter:blur(10px);
  font-weight:800;
  letter-spacing:.01em;
  cursor:pointer;
  user-select:none;
}
/* Keep title gradient for the label color */
#pdfs-select-btn, #pdfs-remove-btn{
  background-image:var(--g);
  -webkit-background-clip:text;
  background-clip:text;
  -webkit-text-fill-color:transparent;
  color:transparent;
  text-shadow:0 0 18px rgba(96,165,250,.25), 0 0 18px rgba(167,139,250,.15);
}

#resources-summary .resources-actions { display:inline-flex; align-items:center; gap:.5rem; margin-left:.6rem; }

/* Blue checkbox that appears in select mode */
#resources-toggle .resource-select{ display:none; }
#resources-toggle.select-mode .resource-select{
  display:inline-block;
  width:16px;
  height:16px;
  margin-right:.6rem;
  border-radius:4px;
  border:2px solid rgba(96,165,250,0.9); /* blue border */
  box-shadow: 0 0 12px rgba(96,165,250,0.25) inset;
  flex: 0 0 auto;
  translate: 0 2px;
}
#resources-toggle.select-mode li{ cursor:pointer; }

/* Fill the box when selected */
#resources-toggle.select-mode li.selected .resource-select{
  background: rgba(96,165,250,0.9);
  box-shadow: 0 0 0 2px rgba(96,165,250,0.35), 0 0 12px rgba(96,165,250,0.4);
}

/* Keep selection highlight consistent */
#resources-toggle.select-mode #resources-list li.selected {
  background: rgba(96,165,250,0.12);
  border: 1px solid rgba(96,165,250,0.35);
}
#resources-toggle.select-mode #resources-list li.selected .resources-title {
  text-decoration: underline;
  font-weight: 800;
}
</style>


<style>
/* Strong pointer-events for selection */
#resources-list li, #resources-list a.resources-link, #resources-list .resource-select{
  pointer-events: auto;
}
#resources-list a.resources-link{ cursor: pointer; }
#resources-toggle.select-mode #resources-list a.resources-link{ text-decoration: none; }
</style>

<!-- kill legacy pptx public-link overlay -->
<style id="kill-pptx-overlay-css">
#pptx-overlay{display:none !important;visibility:hidden !important;pointer-events:none !important;}
</style>
<style>
  /* Force-hide Exact mode UI; Exact conversion is always on */
  #viewer-controls, #exact-mode { display: none !important; }
</style>
<style>
/* === PATCH (Save button theming + hide Reset) === */
#reset-btn{ display:none !important; visibility:hidden !important; pointer-events:none !important; }
#save-btn{
  position:absolute;
  left:50%;
  bottom:56px;
  transform:translateX(-50%);
  background: var(--g);
  color:#fff;
  border:1px solid var(--bd);
  padding:10px 16px;
  border-radius:10px;
  font-weight:600;
  cursor:pointer;
  box-shadow:0 6px 18px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.08);
}
#save-btn:hover{ filter:brightness(1.1); transform:translateX(-50%) translateY(-1px); }
#save-btn:active{ filter:brightness(0.95); transform:translateX(-50%) translateY(0); }
#save-btn[disabled]{ opacity:.5; cursor:not-allowed; filter:none; transform:translateX(-50%); }
</style>
</head><body><h1>Quiz Review</h1><div id="work-area"><div id="quiz-card">
<div class="resizer nw" data-dir="nw"></div>
<div class="resizer n" data-dir="n"></div>
<div class="resizer ne" data-dir="ne"></div>
<div class="resizer e" data-dir="e"></div>
<div class="resizer se" data-dir="se"></div>
<div class="resizer s" data-dir="s"></div>
<div class="resizer sw" data-dir="sw"></div>
<div class="resizer w" data-dir="w"></div>
<div class="drag-handle">Drag</div><button id="review-menu-btn">Saved (0)</button><div id="review-menu"><h3>Saved Questions</h3><ul id="review-list"></ul></div><button id="import-btn" title="Import questions">Import</button><div id="import-menu"><h3>Import Questions</h3><input accept=".json" id="import-json-file" style="width:100%;margin:.25rem 0 .35rem" type="file"/><button id="import-load-json" style="width:100%;margin:0 0 .5rem">Load 100Q JSON</button><textarea id="import-ta" placeholder="Paste JSON array of question objects here"></textarea><div class="rev-meta" id="import-status" style="margin-top:.25rem"></div></div><details id="resources-toggle"><summary id="resources-summary"><span>Lecture PDFs</span><span class="resources-actions"><button id="pdfs-select-btn">Select</button><button id="pdfs-remove-btn">Remove</button></span></summary><div id="resources-panel"><h3>Open a lecture PDF</h3><ul id="resources-list"><li><a class="resources-link" data-view="Lecture 1 Introduction to Histology and the Cell.pdf" href="#">
<span class="resources-title">Lecture 1 — Introduction to Histology and the Cell</span>
<span class="resources-meta">PDF</span>
</a></li><li><a class="resources-link" data-view="Lecture 2 Cell Cytoplasm and Organelles.pdf" href="Lecture 2 Cell Cytoplasm and Organelles.pdf">
<span class="resources-title">Lecture 2 — Cell Cytoplasm and Organelles</span>
<span class="resources-meta">PDF</span>
</a></li><li><a class="resources-link" data-view="Lecture 3 Cell Nucleus and Tissues.pdf" href="#">
<span class="resources-title">Lecture 3 — Cell Nucleus and Tissues</span>
<span class="resources-meta">PDF</span>
</a></li><li><a class="resources-link" data-view="Lectures 4 and 5 Epithelium part 1.pdf" href="#">
<span class="resources-title">Lectures 4 &amp; 5 — Epithelium Part 1</span>
<span class="resources-meta">PDF</span>
</a></li><li><a class="resources-link" data-view="Lectures 4 and 5 Epithelium Part 2.pdf" href="#">
<span class="resources-title">Lectures 4 &amp; 5 — Epithelium Part 2</span>
<span class="resources-meta">PDF</span>
</a></li><li><a class="resources-link" data-view="Lecture 5 Connective Tissue I and II.pdf" href="#">
<span class="resources-title">Lecture 5 — Connective Tissue I and II</span>
<span class="resources-meta">PDF</span>
</a></li><li><a class="resources-link" data-view="Lecture 6 Cartilage (1).pdf" href="#">
<span class="resources-title">Lecture 6 — Cartilage</span>
<span class="resources-meta">PDF</span>
</a></li><li><a class="resources-link" data-view="Lecture 7 Blood I and II.pdf" href="#">
<span class="resources-title">Lecture 7 — Blood I &amp; II</span>
<span class="resources-meta">PDF</span>
</a></li></ul></div></details><button id="viewer-toggle-btn" type="button">Show Lecture Viewer</button><button id="upload-lectures-btn" title="Upload lecture PDF or PPT/PPTX">Upload Lectures</button><button id="select-lectures-btn" title="Select lectures for bulk actions">Select</button><button id="bulk-delete-lectures-btn" title="Delete selected lectures">Delete</button><input id="lecture-upload-input" type="file" multiple accept=".pdf,application/pdf,.ppt,.pptx,application/vnd.ms-powerpoint,application/vnd.openxmlformats-officedocument.presentationml.presentation" style="display:none"/><div id="search-wrap"><input id="search-input" placeholder="Search questions (title, choices, explanation)" type="text"/><ul id="search-results"></ul></div><div class="question-text" id="question"></div><div id="choices"></div><div id="explanation"></div><div id="additional"></div><button id="prev-btn" style="display:none">Previous</button><button id="save-btn" title="Save this question">☆ Save</button><div><button id="next-btn" style="display:none">Next Question</button><button id="reset-btn">Reset</button></div></div><div id="pdf-pane">
<div class="resizer nw" data-dir="nw"></div>
<div class="resizer n" data-dir="n"></div>
<div class="resizer ne" data-dir="ne"></div>
<div class="resizer e" data-dir="e"></div>
<div class="resizer se" data-dir="se"></div>
<div class="resizer s" data-dir="s"></div>
<div class="resizer sw" data-dir="sw"></div>
<div class="resizer w" data-dir="w"></div>
<div class="drag-handle">Drag
    <div aria-hidden="false" id="pdf-overlay" style="position:absolute;inset:0;z-index:1001;background:transparent;touch-action: none;"></div>
<button aria-pressed="false" id="pdf-interact-toggle" style="position:absolute;top:12px;left:12px;z-index:1003;padding:6px 8px;border-radius:6px;border:1px solid rgba(0,0,0,0.08);background:rgba(255,255,255,0.95);cursor:pointer;font-size:13px" title="Toggle PDF interaction">Interact</button>
</div><div id="pdf-title">Lecture Viewer</div>

<div id="viewer-controls" style="display:flex;align-items:center;gap:12px;margin:6px 0 8px 0;font-size:.85rem;opacity:.9;">
  <label style="display:inline-flex;align-items:center;gap:6px;cursor:pointer;">
    <input type="checkbox" id="exact-mode" style="width:14px;height:14px;">
    Exact mode (image-PDF)
  </label>
  <div id="backend-badge" style="font-size:.8rem;opacity:.85;"></div>
</div>
<div id="backend-badge" style="font-size:.75rem;opacity:.8;margin:4px 0 8px 0;"></div>
<div aria-hidden="false" id="pdf-controls" style="display:flex;gap:8px;align-items:center;margin-bottom:0.5rem;">
<button aria-label="Zoom out" id="pdf-zoom-out" style="padding:.25rem .5rem;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:rgba(0,0,0,0.25);cursor:pointer" title="Zoom out" type="button">−</button>
<input id="pdf-zoom-slider" max="250" min="50" step="5" style="width:180px;cursor:pointer;border-radius:6px;background:transparent" title="Zoom" type="range" value="100"/>
<button aria-label="Zoom in" id="pdf-zoom-in" style="padding:.25rem .5rem;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:rgba(0,0,0,0.25);cursor:pointer" title="Zoom in" type="button">+</button>
<button aria-label="Reset zoom" id="pdf-zoom-reset" style="padding:.25rem .5rem;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;cursor:pointer" title="Reset zoom" type="button">100%</button>
</div>
<iframe id="pdf-iframe" src="about:blank" title="PDF Viewer"></iframe></div></div><button id="instr-btn" title="Copy-paste prompt">Instructions</button><div id="instr-panel" style="align-items:center;gap:8px;display:none;"><textarea id="instr-ta" readonly=""></textarea><button id="instr-copy">Copy</button></div><button id="open-tab-btn">Open in New Tab</button><script>"use strict";const questions=[{q:"Primary function of mitochondria?",c:["ATP production by oxidative phosphorylation","Protein glycosylation","Lipid droplet storage","Detoxification of xenobiotics"],a:0,e:"The lecture states that mitochondria produce ATP by oxidative phosphorylation.",add:"Mitochondria are dynamic—changing shape, moving, and dividing.",w:["","Golgi/ER complete most glycosylation steps.","Neutral lipids typically store in adipocytes; mitochondria are not storage vacuoles.","Most detox occurs in smooth ER and peroxisomes, not mitochondria."]},{q:"Mitochondria are bounded by a double membrane; the inner membrane forms infoldings called:",c:["cisternae","thylakoids","grana","laminae"],a:0,e:"Inner mitochondrial membrane forms infoldings called cisternae in these slides, increasing surface area.",add:"Two compartments are created: intermembrane space and matrix.",w:["","These are chloroplast structures.","Also a chloroplast term.","Refers to nuclear lamina, not mitochondrial folds."]},{q:"The two mitochondrial compartments created by the membranes are:",c:["Intermembrane space and matrix","Cytosol and stroma","Periplasm and lumen","Nuclear space and cisternae"],a:0,e:"Outer and inner membranes create an intermembrane space and the matrix.",add:"The matrix contains proteins, RNA, DNA, and may have electron-dense Ca/Mg granules.",w:["","Those are chloroplast terms.","Periplasm is a bacterial term; lumen refers to ER/Golgi.","Mixes nuclear and mitochondrial terminology incorrectly."]},{q:"Ribosomes are composed of:",c:["rRNA (4 types) and ~80 proteins in two subunits","A single rRNA and a lipid monolayer","DNA and histones","Only proteins without RNA"],a:0,e:"Slides specify four types of rRNA and nearly eighty proteins forming two subunits; intensely basophilic.",add:"rRNA for both subunits is synthesized in the nucleolus.",w:["","Ribosomes are not lipid-enclosed.","DNA/histones describe chromatin.","Ribosomes are ribonucleoprotein particles."]},{q:"Polyribosomes are:",c:["Clusters of ribosomes held on a single mRNA","Ribosomes bound together by tRNA","Ribosomes stored in the Golgi","Inactive ribosomal subunits"],a:0,e:"Individual ribosomes are held together by a strand of mRNA, translating one message in parallel.",add:"This boosts throughput of protein synthesis from one transcript.",w:["","tRNA transfers amino acids but does not link ribosomes.","Golgi does not store ribosomes.","Polyribosomes are active, not inactive."]},{q:"The ER exists as:",c:["Smooth and rough forms that are continuous","Only rough stacks separated from smooth tubules","Three discrete forms with no continuity","Vesicles only"],a:0,e:"ER occurs as flat sheets and rounded tubules; smooth and rough are continuous with one another.",add:"Rough ER is continuous with the outer nuclear membrane.",w:["","Slides emphasize continuity between smooth and rough.","Only two forms are listed, not three.","Vesicles bud from ER/Golgi but are not the ER itself."]},{q:"Which is listed as a function of ER?",c:["Initial glycosylation of glycoproteins","ATP generation via TCA cycle","DNA replication","Lipid droplet catabolism"],a:0,e:"Functions include initial glycosylation, lipid synthesis, limited proteolysis of signal sequences, and more.",add:"Other ER functions: assemble multichain proteins; modify endogenous/exogenous compounds.",w:["","TCA enzymes are in the mitochondrial matrix.","Occurs in nucleus, not ER.","Not highlighted as an ER function here."]},{q:"Cells rich in rough ER are typically:",c:["Protein-secreting cells (e.g., pancreatic acinar, salivary serous, plasma cells)","Adipocytes storing triglyceride","Osteoclasts resorbing bone","Erythrocytes"],a:0,e:"Rough ER is prominent in protein-secreting cells such as pancreatic acinar, salivary serous, and plasma cells.",add:"Polyribosomes give RER a basophilic, granular appearance.",w:["","Adipocytes emphasize lipid storage, not abundant RER.","Osteoclasts are secretory but not classic RER exemplars in the slide.","Mature RBCs lack ER."]},{q:"During cotranslational targeting, the signal sequence binds:",c:["Signal recognition particle (SRP)","DNA polymerase","Clathrin","Dynein"],a:0,e:"SRP (a polypeptide/RNA complex) binds the N-terminal signal sequence and pauses elongation.",add:"The SRP–ribosome–nascent chain then docks to a receptor (docking protein) in the RER membrane.",w:["","Unrelated to translation targeting.","Clathrin coats vesicles downstream, not the ribosome.","A microtubule motor, not involved in SRP targeting."]},{q:"The SRP–ribosome complex binds a receptor on the RER commonly called the:",c:["Docking protein","Integrin","Perforin","Annexin"],a:0,e:"Slides name the receptor a ‘docking protein’ on the rough ER membrane.",add:"After docking, SRP is released and translation resumes through the translocation machinery.",w:["","Integrins are adhesion receptors.","Perforin is a cytolytic protein from immune cells.","Annexins bind membranes but are not the SRP receptor."]},{q:"Ribophorins I and II:",c:["Integral RER proteins that may form hydrophilic channels for nascent proteins","Mitochondrial matrix chaperones","Nuclear pore ring proteins","Golgi matrix scaffolds only"],a:0,e:"Rough ER contains integral membrane proteins ribophorin I/II which may form hydrophilic channels for passage into the lumen.",add:"Once inside, the signal sequence is removed by signal peptidase on the luminal side.",w:["","Not localized to mitochondria in this context.","Not nuclear pore components.","Ribophorins are RER, not Golgi, proteins."]},{q:"The enzyme that removes the signal peptide of a nascent protein in the RER is:",c:["Signal peptidase (luminal side)","Topoisomerase","Peptidyl-tRNA hydrolase","Catalase"],a:0,e:"Signal peptidase on the inner (luminal) surface of RER cleaves the signal sequence.",add:"Translation continues with concurrent structural modifications.",w:["","DNA topology enzyme (nuclear).","Releases peptides from tRNA at termination, not signal cleavage.","Peroxisomal enzyme for H2O2 breakdown."]},{q:"Smooth ER is characterized by:",c:["Interconnected haphazard tubules lacking surface ribosomes","Stacks of flattened sacs coated with ribosomes","Dense granules of rRNA","A double membrane with cristae"],a:0,e:"Smooth ER has numerous interconnected tubules without bound ribosomes; many cells have only small amounts.",add:"In muscle, smooth ER is called sarcoplasmic reticulum and associates with contraction.",w:["","That describes rough ER.","Describes nucleoli/ribosomes, not SER membranes.","Cristae (cisternae here) describe mitochondria."]},{q:"Which is a listed function of smooth ER?",c:["Detoxification and steroid synthesis","mRNA splicing","Oxidative phosphorylation","DNA replication licensing"],a:0,e:"Slides highlight fatty acid/phospholipid synthesis, detoxification (e.g., liver), and steroid synthesis; in muscle it is sarcoplasmic reticulum.",add:"Steroid-secreting cells are packed with SER.",w:["","Nuclear process.","Mitochondrial function.","Nuclear licensing, not SER."]},{q:"Golgi structure is best described as:",c:["Curved stack of cisternae with peripheral vesicles and vacuoles","Random tubules without polarity","Ribosome-coated sacs","A single flattened sac without vesicles"],a:0,e:"The Golgi is a curved stack of cisternae surrounded by vesicles; large vacuoles are present on one side.",add:"Polarity: forming convex cis face near RER; maturing concave trans face.",w:["","Golgi has clear polarity.","Ribosomes are on RER, not Golgi.","Multiple stacks and vesicles are typical."]},{q:"Which statement about Golgi polarity is correct?",c:["Cis face = forming/convex near RER; Trans face = maturing/concave with condensing vacuoles","Both faces are identical in structure and function","Trans face lies nearest the RER","Condensing vacuoles arise from the cis face"],a:0,e:"Forming (cis) face is convex and near RER; maturing (trans) face is concave; condensing vacuoles bud from trans.",add:"Condensing vacuoles deliver cargo to secretory granules and plasma membrane.",w:["","Slides explicitly describe polarity.","Opposite of slide.","Opposite of slide."]},{q:"Primary function of the Golgi listed in these slides:",c:["Complete chemical modifications and sort proteins to destinations","Synthesize rRNA subunits","Generate ATP via TCA cycle","Degrade H2O2 via catalase"],a:0,e:"Golgi completes modifications of ER-made proteins and determines their destination (PM, secretion, lysosomes, or retained in ER).",add:"Plasma membrane proteins move RER → Golgi → plasma membrane via transport vesicles.",w:["","Nucleolar job.","Mitochondrial job.","Peroxisomal job."]},{q:"Lysosomes are described as:",c:["Single-membrane organelles with hydrolytic enzymes active at acidic pH","Double-membrane organelles with DNA","Protein synthesis granules","Neutral-pH peroxidation sites"],a:0,e:"Slides: spherical, single-membrane organelles with many acid hydrolases; acidic pH; intracellular digestion & turnover.",add:"Enzymes synthesized in RER and modified/packaged in Golgi as lysosomes.",w:["","Not part of lysosome definition here.","Ribosomes synthesize proteins; lysosomes digest.","Peroxisomes handle H2O2 detox, not lysosomes."]},{q:"Lysosomal enzymes originate where before packaging as lysosomes?",c:["Synthesized in RER, modified in Golgi","Synthesized in mitochondria, sorted by peroxisomes","Made in cytosol and imported into nucleus","Synthesized on free ribosomes then secreted directly"],a:0,e:"Enzymes are synthesized in rough ER and then sent to Golgi where they are modified and packaged as lysosomes.",add:"Acid hydrolases require acidic lumen; primary vs secondary states reflect activity.",w:["","Not per lecture.","Nuclear import is unrelated here.","They’re routed via Golgi, not secreted directly."]},{q:"Primary vs secondary lysosomes:",c:["Primary: uniform, not yet digesting; Secondary: heterogeneous, actively digesting","Primary: contains DNA; Secondary: lacks enzymes","Primary: neutral pH; Secondary: alkaline","Primary: double membrane; Secondary: single membrane"],a:0,e:"Primary lysosomes have uniform dense appearance and have not engaged in digestion; secondary contain partially digested material and look heterogeneous.",add:"Secondary lysosomes form after fusion of endocytosed material with a primary lysosome.",w:["","DNA is not a defining feature.","Lysosomes function at acidic pH.","Both are single-membrane organelles."]},{q:"Heterophagy vs autophagy:",c:["Heterophagy digests material brought in by endocytosis; autophagy digests cell’s own components","Both refer only to bacterial digestion","Autophagy digests only extracellular matrix","Heterophagy is fusion with nucleus"],a:0,e:"Slides define heterophagy as digestion of endocytosed material and autophagy as turnover of intracellular components via fusion with primary lysosomes.",add:"Lysosomes are abundant in macrophages and other phagocytes.",w:["","Not in the slides.","Autophagy targets intracellular components, not ECM specifically.","Nucleus is not involved in heterophagy."]},{q:"Residual bodies / lipofuscin are common in:",c:["Long-lived cells like neurons and cardiac muscle","Hepatocytes exclusively","Erythrocytes","All rapidly dividing cells"],a:0,e:"Slides: residual bodies accumulate; large quantities called lipofuscin (age pigment) common in long-lived cells such as neurons and cardiac muscle.",add:"Residual bodies form when indigestible contents remain within lysosomes.",w:["","Not exclusive per slide.","Mature RBCs lack lysosomes.","Dividing cells dilute pigments; not highlighted as common here."]},{q:"Peroxisomes contain enzymes such as:",c:["Catalase, amino oxidases, hydroxy acid oxidase","Cytochrome c oxidase and ATP synthase","DNA polymerase and helicase","Pepsin and trypsin"],a:0,e:"Peroxisomes house catalase, amino oxidases, and hydroxy acid oxidase to decompose H2O2 and protect cells; they also participate in lipid metabolism.",add:"They resemble lysosomes in size but differ in enzyme composition.",w:["","Those are mitochondrial respiratory enzymes.","Nuclear DNA replication enzymes.","Digestive proteases of stomach/pancreas."]},{q:"The cytoskeleton listed components are:",c:["Microtubules, actin filaments, intermediate filaments","Actin filaments only","Myosin thick filaments only","Kinesin and dynein only"],a:0,e:"The cytoskeleton is composed of microtubules, microfilaments (actin), and intermediate filaments; provides form and movement.",add:"Motor proteins move along filaments/microtubules but are not themselves filaments.",w:["","Slides list three classes, not one.","Myosin is part of contractile apparatus but cytoskeleton includes more.","These are motors, not the filaments themselves."]},{q:"Microtubule structure:",c:["Hollow tubes of α/β-tubulin dimers with ~13 units per spiral turn","Solid rods of actin","Triple helical DNA fibers","Collagen fibrils"],a:0,e:"Slides: microtubules are like a straw—dense wall, hollow core; α/β-tubulin heterodimers in spirals with 13 units/turn.",add:"Polymerization directed by MTOCs: centrioles, basal bodies, centromeres.",w:["","That’s actin, not microtubules.","DNA is nuclear, not cytoskeletal filaments.","Extracellular matrix, not cytoskeleton."]},{q:"Within cells, vesicles/proteins move along tracks formed by:",c:["Microtubules with kinesin and dynein motors","Intermediate filaments with myosin motors","Actin filaments with dynein only","Golgi cisternae with clathrin motors"],a:0,e:"Slides: movement involves tracks of microtubules; motor proteins kinesin and dynein mediate this transport.",add:"Directionality isn’t detailed here, only that kinesin/dynein are involved.",w:["","Myosin is the actin motor; IFs are structural.","Dynein is a microtubule motor; actin uses myosin.","Clathrin forms coats; no such ‘motors’."]},{q:"Microtubule organizing centers (as listed):",c:["Centrioles, basal bodies, and centromeres","Only centrosomes","Ribosomes and nucleoli","Sarcomeres and desmosomes"],a:0,e:"Slides list centrioles, basal bodies, and centromeres directing polymerization.",add:"Terminology reflects the slide; focus on these exemplar MTOCs.",w:["","The slide spelled out specific structures.","These are for protein synthesis/RNA, not MT organizing.","Muscle/adhesion structures, not MT organizers."]},{q:"Centrioles are composed of:",c:["Nine microtubule triplets arranged in a pinwheel","Nine doublets plus two central singlets","Thirteen actin protofilaments","A single microtubule with dynein arms"],a:0,e:"Each centriole has 9 sets of microtubule triplets arranged in a pinwheel; pairs lie orthogonal near nucleus/Golgi.",add:"Basal bodies share essentially identical microtubule structure to centrioles.",w:["","That’s the axoneme (9+2) pattern.","That is actin’s description, not centrioles.","Dynein arms are axonemal, not centriole structure."]},{q:"Centriole dynamics in the cell cycle:",c:["Duplicate in S phase; pairs move to opposite poles during mitosis to organize spindles","Duplicate only in G1; remain near nucleus during mitosis","Disassemble before mitosis","Are absent from all human cells"],a:0,e:"Slides: during S period each centriole duplicates; during mitosis the two pairs move to opposite poles and organize the mitotic spindles.",add:"Orthogonal arrangement is typical in non-dividing cells.",w:["","Not per slide.","They organize the spindle; not stated to disassemble.","They are present; absence not stated here."]},{q:"Cilia vs flagella in humans:",c:["Both share a similar structure; flagella are found only in sperm","Cilia and flagella are structurally unrelated","Flagella are common on many epithelial cells","Only flagella beat; cilia are immotile by definition"],a:0,e:"Slides: cilia are motile processes; flagella share similar structure; in humans, flagella occur only in sperm.",add:"Both use an axoneme core.",w:["","They share the same core plan.","Not per slide.","Cilia are motile here."]},{q:"Axoneme core pattern:",c:["9 microtubule doublets around 2 central microtubules (9+2)","9 triplets with no central pair","13 protofilaments only","Random microtubule array"],a:0,e:"Axoneme consists of a circle of 9 pairs (doublets) with a central pair; linked by nexin and radial spokes; basal body resembles a centriole.",add:"Adjacent doublets are connected to central sheath via radial spokes.",w:["","That’s centriole/basal body pattern.","Protofilament count is a property of MT walls, not the axoneme arrangement.","The axoneme is highly ordered, not random."]},{q:"Mechanism driving ciliary/flagellar bending:",c:["Dynein arms on A-tubule ‘walk’ along B-tubule using ATPase activity","Kinesin sliding on actin filaments","Elastic recoil of intermediate filaments","Passive diffusion of tubulin"],a:0,e:"Dynein arms (ATPase) extend from the A microtubule and walk along the B of the adjacent doublet, producing sliding that bends the axoneme.",add:"This undulating motion accounts for ciliary/flagellar motility.",w:["","Kinesin transports cargo; actin uses myosin.","IFs provide structure, not motility.","Not a force-generating mechanism."]},{q:"Actin filament structure:",c:["Double-stranded helix of globular subunits; abundant in non-muscle cells too","Hollow tube of α/β-tubulin","Triple helix of DNA","Single collagen chain"],a:0,e:"Slides: actin forms thin filaments organized as a double-stranded helix; present in non-muscle cells and is the most abundant cytoskeletal protein.",add:"Cells often contain several actin isoforms/species.",w:["","That’s microtubules.","That’s chromatin.","Collagen is extracellular."]},{q:"Actin functions highlighted include:",c:["Anchorage of membrane proteins and core of microvilli; terminal web helps maintain apical shape","ATP generation in mitochondria","DNA repair in nucleus","H2O2 breakdown"],a:0,e:"Slides emphasize anchorage (e.g., focal adhesions) and formation of the structural core of microvilli; the apical terminal web acts as tension cables.",add:"Actin polymerization drives lamellipodia; depolymerization retracts the trailing edge.",w:["","Mitochondrial, not actin’s direct role.","Nuclear enzymes perform repair.","Peroxisomal function."]},{q:"Cell crawling (lamellipodia) depends on:",c:["Actin polymerization at the leading edge with trailing depolymerization","Dynein walking on microtubules","Intermediate filament sliding","Ribophorin-mediated translocation"],a:0,e:"Leading edge protrusion is driven by actin polymerization; trailing edge retracts as actin depolymerizes.",add:"Filopodia contain loose bundles of ~10–20 actin filaments oriented with plus ends toward the membrane.",w:["","Dynein is for MT-based motility, not lamellipodia.","IFs are structural; no stated motor.","Ribophorins are RER proteins."]},{q:"Intermediate filament key role:",c:["Structural reinforcement of cells and tissues","Vesicle transport motors","ATP synthesis","Protein glycosylation"],a:0,e:"Slides: the principal function of intermediate filaments is structural—reinforcing cells and organizing tissues.",add:"IF-associated proteins cross-link IFs into bundles (e.g., tonofilaments), networks, or to membranes.",w:["","Transport is microtubule/actin-motor based.","Mitochondrial job.","Golgi/ER job."]},{q:"Which intermediate filament pairing is correct?",c:["Cytokeratins – epithelial cells","Vimentin – neurons","Desmin – hepatocytes","GFAP – skeletal muscle"],a:0,e:"Types: cytokeratins in epithelium; vimentin in mesenchymal/embryonic cells; desmin in muscle; GFAP in astrocytes; neurofilaments in neurons; nuclear lamins line inner nuclear envelope of all cells.",add:"These patterns are used diagnostically.",w:["","Neurons contain neurofilaments; vimentin is mesenchymal.","Desmin is in smooth, cardiac, and skeletal muscle.","GFAP marks astrocytes (glia)."]}];const $=id=>document.getElementById(id),qEl=$("question"),choicesEl=$("choices"),explEl=$("explanation"),addEl=$("additional"),nextBtn=$("next-btn"),prevBtn=$("prev-btn"),resetBtn=$("reset-btn"),openBtn=$("open-tab-btn"),saveBtn=$("save-btn"),menuBtn=$("review-menu-btn"),menu=$("review-menu"),listEl=$("review-list");const sWrap=$("search-wrap"),sInput=$("search-input"),sList=$("search-results");const importBtn=$("import-btn"),importMenu=$("import-menu"),importTA=$("import-ta"),importStatus=$("import-status"),importJSON=$("import-json-file"),importLoad=$("import-load-json");const instrBtn=document.getElementById('instr-btn'),instrPanel=document.getElementById('instr-panel'),instrTA=document.getElementById('instr-ta'),instrCopy=document.getElementById('instr-copy');const read=(k,d={})=>{try{const v=localStorage.getItem(k);return v?JSON.parse(v):d}catch(e){return d}},write=(k,v)=>{try{localStorage.setItem(k,JSON.stringify(v))}catch(e){}};const STORAGE_KEY='histologyL2QuizStateV1',PROG_KEY=STORAGE_KEY+'_progress',BM_KEY=STORAGE_KEY+'_bookmarks';
const QUESTIONS_KEY = STORAGE_KEY + '_questions';

// If we've previously imported a question set, restore it into the in-memory `questions` array.
// `questions` is declared earlier as a const array, so we use splice to replace its contents.
try{
  const persisted = read(QUESTIONS_KEY, null);
  if(Array.isArray(persisted) && persisted.length){
    try{ questions.splice(0, questions.length, ...persisted); }catch(e){}
  }
}catch(e){}
function updateTitle(){const h=document.querySelector('h1');if(h)h.textContent='Quiz Review';document.title='Quiz Review'}function ensureVisible(el){try{if(!el||el.style.display!=='block')return;const r=el.getBoundingClientRect();let dx=0;if(r.right>window.innerWidth)dx=r.right-window.innerWidth+12;if(r.left<0)dx=r.left-12;if(dx)window.scrollBy({left:dx,behavior:'smooth'})}catch(e){}}function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}}function saveState(){write(STORAGE_KEY,{order,current,queued:[...queued],choiceMap,attemptMap})}function loadState(){const s=read(STORAGE_KEY,null);return s&&Array.isArray(s.order)&&typeof s.current==='number'?s:null}let order=[],current=0,queued=new Set(),choiceMap={},attemptMap={};function enforceCap(){try{if(questions.length>100)questions.splice(100);if(typeof order!=='undefined'){order=order.filter(i=>i<questions.length);if(current>=order.length)current=Math.max(0,order.length-1)}}catch(e){}}function getChoiceOrder(i){if(!choiceMap[i]){choiceMap[i]=[0,1,2,3];shuffle(choiceMap[i]);saveState()}return choiceMap[i]}(function init(){const s=loadState();if(s){order=s.order.filter(i=>Number.isInteger(i)&&i>=0&&i<questions.length);current=Math.min(Math.max(0,s.current),order.length);queued=new Set((s.queued||[]).filter(i=>Number.isInteger(i)&&i>=0&&i<questions.length));choiceMap=s.choiceMap||{};attemptMap=s.attemptMap||{};if(order.length===0){order=[...Array(questions.length).keys()];shuffle(order);current=0}}else{order=[...Array(questions.length).keys()];shuffle(order);current=0}saveState()})();function buildWrongsList(item,orderArr){if(!item.w)return'';const list=orderArr.map(o=>o!==item.a?`<li><strong>${item.c[o]}:</strong> ${item.w[o]||''}</li>`:'').filter(Boolean).join('');return list?`<div style="margin-top:.75rem"><div style="font-weight:700;margin-bottom:.25rem">Why the other options are wrong:</div><ul style="margin:0 0 0 1.25rem;padding:0;list-style:disc">${list}</ul></div>`:''}function finalizeQuestion(orderArr,item){[...choicesEl.children].forEach(b=>b.disabled=true);addEl.innerHTML=item.add||'';addEl.style.display=item.add?'block':'none';explEl.innerHTML=item.e+buildWrongsList(item,orderArr);explEl.style.display='block';
    try{ ensureVisible(explEl); }catch(e){}nextBtn.style.display='inline-block';saveState()}function showQuestion(){if(current>=order.length){qEl.textContent='Quiz complete!';choicesEl.innerHTML='';explEl.style.display='none';addEl.style.display='none';nextBtn.style.display='none';try{localStorage.removeItem(STORAGE_KEY)}catch(e){}return}const qi=order[current],it=questions[qi],co=getChoiceOrder(qi);const n=Math.min(questions.length,100);qEl.innerHTML=`<span class="qhead"><select id="jump-select" title="Jump to question"></select></span> ${it.q}`;(function(){const js=document.getElementById('jump-select');if(!js)return;js.innerHTML='';for(let pos=0;pos<n;pos++){const qx=order[pos],t=(questions[qx]&&questions[qx].q)||('Question '+(qx+1));const o=document.createElement('option');o.value=pos;o.textContent='Q '+(pos+1);o.title=t;if(pos===current)o.selected=true;js.appendChild(o)}js.addEventListener('focus',()=>ensureVisible(js));js.addEventListener('mousedown',()=>ensureVisible(js));js.onchange=e=>{current=parseInt(e.target.value,10)||0;saveState();showQuestion()}})();choicesEl.innerHTML='';explEl.style.display='none';addEl.style.display='none';nextBtn.style.display='inline-block';co.forEach((orig,di)=>{const b=document.createElement('button');b.className='choice';b.innerHTML=`<span class="label">${['A','B','C','D'][di]}.</span> ${it.c[orig]}`;b.onclick=()=>selectAnswer(b,di,qi);choicesEl.appendChild(b)});restoreUI(qi);nextBtn.style.display='inline-block';updateSaveBtn();prevBtn.style.display=current>0?'inline-block':'none'}function selectAnswer(btn,di,qi){const it=questions[qi],co=getChoiceOrder(qi),chosen=co[di],attempts=attemptMap[qi]||0;if(chosen===it.a){btn.classList.add('correct');finalizeQuestion(co,it);attemptMap[qi]=(attempts+1);captureUI(qi);return}if(attempts===0){btn.classList.add('incorrect');btn.disabled=true;explEl.innerHTML='<div style="opacity:.9">One more try — choose the best remaining option.</div>';explEl.style.display='block';nextBtn.style.display='inline-block';attemptMap[qi]=1;captureUI(qi);return}else{btn.classList.add('incorrect');const bs=[...choicesEl.children];bs.forEach(b=>b.disabled=true);const ci=co.indexOf(it.a);if(ci>-1)bs[ci].classList.add('correct');addEl.innerHTML=it.add||'';addEl.style.display=it.add?'block':'none';explEl.innerHTML=it.e+buildWrongsList(it,co);explEl.style.display='block';nextBtn.style.display='inline-block';attemptMap[qi]=attempts+1;if(!queued.has(qi)){queued.add(qi);order.push(qi)}captureUI(qi);return}}function captureUI(qi){const btns=[...choicesEl.children];write(PROG_KEY,{...read(PROG_KEY),[qi]:{disabled:btns.map(b=>!!b.disabled),classes:btns.map(b=>b.className),explHTML:explEl.innerHTML,explVisible:explEl.style.display!=='none',addHTML:addEl.innerHTML,addVisible:addEl.style.display!=='none',nextVisible:nextBtn.style.display!=='none',attempts:attemptMap[qi]||0}})}function restoreUI(qi){const s=read(PROG_KEY)[qi];if(!s)return;if(s.attempts!=null)attemptMap[qi]=s.attempts;const btns=[...choicesEl.children];(s.classes||[]).forEach((c,i)=>{if(btns[i])btns[i].className=c});(s.disabled||[]).forEach((d,i)=>{if(btns[i])btns[i].disabled=!!d});explEl.innerHTML=s.explHTML||'';explEl.style.display=s.explVisible?'block':'none';addEl.innerHTML=s.addHTML||'';addEl.style.display=s.addVisible?'block':'none';nextBtn.style.display=s.nextVisible?'inline-block':'none'}nextBtn.onclick=()=>{captureUI(order[current]);current++;try{const tgt=order[current];if(tgt!=null){const prog=read(PROG_KEY);if(prog&&prog[tgt]){delete prog[tgt];write(PROG_KEY,prog)}if(attemptMap)delete attemptMap[tgt]}}catch(e){};saveState();showQuestion()};prevBtn.onclick=()=>{if(current>0){captureUI(order[current]);current--;saveState();showQuestion()}};resetBtn.onclick=()=>{try{localStorage.removeItem(STORAGE_KEY)}catch(e){}order=[...Array(questions.length).keys()];shuffle(order);current=0;queued=new Set();choiceMap={};attemptMap={};write(PROG_KEY,{});saveState();showQuestion()};openBtn.onclick=()=>{try{const html='<!DOCTYPE html>'+document.documentElement.outerHTML;const url=URL.createObjectURL(new Blob([html],{type:'text/html'}));window.open(url,'_blank','noopener,noreferrer')}catch(e){window.open(location.href,'_blank','noopener,noreferrer')}};function loadBM(){return read(BM_KEY)}function saveBM(m){write(BM_KEY,m)}function isSaved(qi){return Object.prototype.hasOwnProperty.call(loadBM(),String(qi))}function updateSaveBtn(){const qi=order[current];if(isSaved(qi)){saveBtn.classList.add('saved');saveBtn.textContent='★ Saved'}else{saveBtn.classList.remove('saved');saveBtn.textContent='☆ Save'}}saveBtn.onclick=()=>{const qi=order[current],m=loadBM();if(isSaved(qi))delete m[String(qi)];else m[String(qi)]=Date.now();saveBM(m);renderMenu();updateSaveBtn()};function renderMenu(){const m=loadBM(),entries=Object.keys(m).map(k=>({qi:parseInt(k,10),ts:m[k]})).sort((a,b)=>b.ts-a.ts);menuBtn.textContent='Saved ('+entries.length+')';listEl.innerHTML=entries.length?'':'<li class="rev-meta" style="padding:.5rem .5rem">No saved questions yet.</li>';entries.forEach(({qi})=>{const li=document.createElement('li'),jump=document.createElement('button');jump.className='rev-jump';const pos=order.indexOf(qi),title=(questions[qi]&&questions[qi].q)||('Question '+(qi+1));jump.textContent=(pos>=0?('Q'+(pos+1)+': '):'Q? ')+title;jump.onclick=()=>{const idx=order.indexOf(qi);if(idx>=0){try{const prog=read(PROG_KEY);if(prog&&prog[qi]!=null){delete prog[qi];write(PROG_KEY,prog)}if(attemptMap)delete attemptMap[qi]}catch(e){}current=idx;saveState();showQuestion();}};const rm=document.createElement('button');rm.className='rev-remove';rm.textContent='×';rm.title='Remove';rm.onclick=()=>{const mm=loadBM();delete mm[String(qi)];saveBM(mm);renderMenu();updateSaveBtn()};li.appendChild(jump);li.appendChild(rm);listEl.appendChild(li)})}menuBtn.onclick=e=>{e.stopPropagation();menu.style.display=menu.style.display==='block'?'none':'block';if(menu.style.display==='block')ensureVisible(menu)};document.addEventListener('click',e=>{if(sWrap&&!sWrap.contains(e.target))sList.style.display='none';if(menu&&e.target!==menu&&!menu.contains(e.target)&&e.target!==menuBtn)menu.style.display='none';if(importMenu&&e.target!==importMenu&&!importMenu.contains(e.target)&&e.target!==importBtn)importMenu.style.display='none'});document.addEventListener('click',e=>{if(instrPanel&&e.target!==instrPanel&&!instrPanel.contains(e.target)&&e.target!==instrBtn)instrPanel.style.display='none'});(function(){if(instrTA)instrTA.value="Using the uploaded file, follow the instructions line by line without error and respond with the .json file.\n\n# quizinstructions0 (clean)\n\n## Scope & sources\n- Use only my lecture slides as the source of truth. No outside facts, guesses, or embellishments.\n- Match my terminology exactly; do not introduce synonyms or pronunciations.\n\n## Coverage, order & count\n- Be **exhaustive** for the assigned slides.\n- Keep questions in the **same chronological order** as the slides.\n- **Minimum of 100 questions per set.** Generate exhaustively in order and stop wherever you reach 100 (it\u00e2\u0080\u0099s fine if that lands around slide 40/50). Do **not** skip or compress content just to \u00e2\u0080\u009ccover all slides.\u00e2\u0080\u009d I\u00e2\u0080\u0099ll request another set to finish the remaining slides.\n- No overall cap: the generator must handle **any number of questions** when asked.\n\n## Output format (strict)\n- Return **one valid JSON array** of question objects.\n- **Exactly 4 choices per question.**\n- **Schema (keys and types):**\n  - `q` (string): the question stem.\n  - `c` (array of 4 strings): answer choices in display order.\n  - `a` (integer 0\u00e2\u0080\u00933): index of the correct choice in `c`.\n  - `e` (string): concise explanation for why the correct choice is correct, citing slide facts.\n  - `w` (array of 4 strings): for each choice (A\u00e2\u0080\u0093D), a brief reason it is wrong; the entry for the correct option may be `\"\"` or a short reinforcement.\n  - `add` (string, optional): brief extra note if truly helpful (otherwise omit).\n  - Optional media (use only when instructed below):\n    - `img` (string **or** object) **or** `_media: { img: { src: string, alt?: string, credit?: string, license?: string } }`\n- **JSON rules:**\n  - No trailing commas.\n  - No comments.\n  - Plain UTF-8 text (write subscripts as Vmax, KM, etc.\u00e2\u0080\u0094no HTML tags).\n  - Do not include keys other than those listed above, except the optional `img`, `_media.img`, or `_meta` (for the Show Evidence panel).\n\n## Image-based questions (required when applicable)\n- When a slide covers an **identifiable muscle**, include **at least one** image-based item using a **cadaver photograph only** (no illustrations/models).\n- The photo must **clearly depict** the target structure; if uncertain, **omit** the image item.\n- Attach via `img` (URL or object) or `_media.img`.\n- Ensure the structure requested in the stem **matches slide evidence**.\n\n## Question writing rules\n- Stems are clear, self-contained, and drawn directly from slide content.\n- No \u00e2\u0080\u009cAll/None of the above,\u00e2\u0080\u009d no double-negatives, no vague qualifiers.\n- Use positive phrasing unless the slide explicitly stresses exceptions.\n- Exactly **one** unambiguously correct answer; distractors must be plausible near-misses from the slides.\n- Keep options parallel in length, grammar, and specificity; avoid giveaway cues.\n- Prefer clinically meaningful/application stems where the slides support them.\n\n## Difficulty & balance\n- Match slide depth:\n  - Recognition/recall for definitions, names, and lists on slides.\n  - Understanding/application where slides provide relationships, functions, attachments, innervation, pathways, etc.\n- Where slides list **landmarks or name changes**, include items that test those transitions precisely.\n\n## Anatomy-specific constraints\n- Use **exact slide conventions** for names (nerve roots, attachment borders, spaces, fossae, etc.).\n- When asking where an artery/nerve changes names, specify the **precise landmark** from the slides.\n\n## Error-minimization checklist (before returning JSON)\n- Every `c` has length 4 and `a \u00e2\u0088\u0088 {0,1,2,3}`.\n- Each `w` array has 4 entries aligned to choices A\u00e2\u0080\u0093D.\n- No duplicate questions; no placeholder text (e.g., \u00e2\u0080\u009cpractice,\u00e2\u0080\u009d \u00e2\u0080\u009cdrill,\u00e2\u0080\u009d \u00e2\u0080\u009csample\u00e2\u0080\u009d).\n- Preserve slide order; do not skip covered points within the assigned range.\n- For any image item, confirm it is a cadaver photo and the target structure is unambiguous.\n\n## Evidence metadata (for the **Show Evidence** tab)\n- To populate the in\u2011app Show Evidence panel, include an optional `_meta` object on each question. This is **not shown to learners**; it powers the evidence UI.\n- `_meta` object keys:\n  - `slide_range` (array): 1\u2011based slide number(s) from the lecture PDF that support the question. Use `[N]` for a single slide, or `[start, end]` for a contiguous range.\n  - `slide_title` (string): the **exact** slide title/heading text (match the slide verbatim).\n  - `slide_uid` (string, optional): a stable identifier if available. If unknown, use `\"<file_basename>#<slide_number>\"` (e.g., `Lecture 7 \u2014 Blood I & II#18`).\n  - `evidence` (string): 1\u20132 short phrases pointing to the **exact bullet/figure/caption** on the slide that justifies the correct answer (no outside sources).\n  - `anchors` (array, optional): list of anchor objects to aid searching/jumping. Each: `{ \"text\": \"<exact phrase on the slide>\", \"start\": 0, \"end\": 0 }`. If offsets are unknown, include `\"text\"` only.\n- Do **not** leave these blank. At minimum, provide `slide_range` (or `slide`) with the correct number and `slide_title` if present on the slide.\n- You may also include a legacy top\u2011level `slide` (integer) for single\u2011slide items; the UI will use it if present, but prefer `_meta.slide_range`.\n\n\n## Output delivery\n- When asked to generate questions, return **only** the downloadable JSON (no prose, no headings).\n";if(instrBtn)instrBtn.onclick=(ev)=>{ev.stopPropagation();instrPanel.style.display=instrPanel.style.display==='block'?'none':'block'};if(instrCopy)instrCopy.onclick=async()=>{try{await navigator.clipboard.writeText(instrTA.value);instrCopy.textContent='Copied!';setTimeout(()=>instrCopy.textContent='Copy',1000)}catch(e){}}})();function importToggle(){if(importMenu){importMenu.style.display=importMenu.style.display==='block'?'none':'block';if(importMenu.style.display==='block')ensureVisible(importMenu)}}if(importBtn){importBtn.onclick=e=>{e.stopPropagation();importToggle()}}function parseImported(t){try{const a=JSON.parse(t);if(Array.isArray(a))return a}catch(e){}return null}function validateQs(a){return Array.isArray(a)&&a.every(q=>q&&typeof q.q==='string'&&Array.isArray(q.c)&&q.c.length===4&&Number.isInteger(q.a))}if(importLoad){importLoad.onclick=()=>{try{if(!importJSON||!importJSON.files||!importJSON.files[0]){if(importStatus)importStatus.textContent='Choose a JSON file.';return}const r=new FileReader();r.onload=()=>{try{const arr=JSON.parse((r.result||'').trim());if(!validateQs(arr)){if(importStatus)importStatus.textContent='Invalid JSON array.';return}questions.splice(0,questions.length,...arr);
            // Persist imported question set so it survives page reloads
            try{ write(QUESTIONS_KEY, arr); }catch(e){}
            write(PROG_KEY,{}); write(BM_KEY,{});order=[...Array(questions.length).keys()];shuffle(order);current=0;queued=new Set();choiceMap={};attemptMap={};enforceCap();saveState();showQuestion();renderMenu();updateSaveBtn();updateTitle();if(importStatus)importStatus.textContent='Loaded '+arr.length+' questions.'}catch(e){if(importStatus)importStatus.textContent='Load error: '+e}};r.onerror=()=>{if(importStatus)importStatus.textContent='Read failed'};r.readAsText(importJSON.files[0])}catch(e){if(importStatus)importStatus.textContent='Load error: '+e}}}function norm(t){return (t||'').toLowerCase()}function doSearch(q){if(!sList)return;sList.innerHTML='';q=(q||'').trim();if(q.length<2){sList.style.display='none';return}const n=Math.min(questions.length,100),needle=norm(q),res=[];for(let i=0;i<n;i++){const it=questions[i]||{},hay=[it.q,(it.c||[]).join(' '),it.e,it.add].map(norm).join(' ');if(hay.indexOf(needle)>-1){res.push(i);if(res.length>=12)break}}if(!res.length){sList.style.display='none';return}res.forEach(i=>{const li=document.createElement('li'),pos=order.indexOf(i),label=(pos>=0?(pos+1)+'/'+Math.min(questions.length,100)+': ':'')+((questions[i]&&questions[i].q)||('Question '+(i+1)));li.textContent=label;li.onclick=()=>{const idx=order.indexOf(i);if(idx>=0){current=idx;saveState;showQuestion()}sList.style.display='none';sInput&&sInput.blur()};sList.appendChild(li)});sList.style.display='block'}if(sInput){sInput.addEventListener('input',e=>doSearch(e.target.value));sInput.addEventListener('focus',e=>doSearch(e.target.value))}enforceCap();
// Force start at Q1 and ensure instructions panel hidden on initial load
// intentionally preserved saved state on load (removed forced clear)
showQuestion();
try{console.assert(typeof write==='function','write helper exists');console.assert(Array.isArray(questions)&&questions.length>0,'questions seeded');const t=buildWrongsList({w:["",'x','y','z'],c:['a','b','c','d'],a:0},[0,1,2,3]);console.assert(t.includes('<li>'),'wrongs list renders');console.debug('[Quiz Self-Tests] OK')}catch(err){console.warn('[Quiz Self-Tests]',err)}</script><script>
(function(){
  const area = document.getElementById('work-area');
  const btn = document.getElementById('viewer-toggle-btn'); // "Show Lecture Viewer" opener
  const resetBtn = document.getElementById('reset-layout-btn');
  const quiz = document.getElementById('quiz-card');
  const pane = document.getElementById('pdf-pane');
  const iframe = document.getElementById('pdf-iframe');
  const titleEl = document.getElementById('pdf-title');

  function ensureFixed(el){
    const computedPos = getComputedStyle(el).position;
    if (computedPos === 'fixed') return;
    const r = el.getBoundingClientRect();
    el.style.position = 'fixed';
    el.style.top = Math.max(8, Math.round(r.top)) + 'px';
    el.style.left = Math.max(8, Math.round(r.left)) + 'px';
    el.style.boxSizing = 'border-box';
    el.style.width = Math.round(r.width) + 'px';
    el.style.height = Math.round(r.height) + 'px';
    el.style.zIndex = 999;
  }

  function unfix(el){
    if(!el) return;
    el.style.position = '';
    el.style.top = '';
    el.style.left = '';
    el.style.width = '';
    el.style.height = '';
    el.style.boxSizing = '';
    el.style.zIndex = '';
  }

  function isInteractive(target){
    return !!(target && target.closest && target.closest('button,input,select,textarea,a,summary,label,iframe,#review-menu,#import-menu,#resources-panel,#search-results,#jump-select,.choice'));
  }

  function makeDraggable(el){
    let dragging = false, startX = 0, startY = 0, baseLeft = 0, baseTop = 0;
    let blockedIframe = null;

    el.addEventListener('mousedown', (e)=>{
      if(e.button !== 0) return;
      if(isInteractive(e.target)) return;

      if (getComputedStyle(el).position !== 'fixed') {
        ensureFixed(el);
      }

      dragging = true;
      startX = e.clientX;
      startY = e.clientY;
      const r = el.getBoundingClientRect();
      baseLeft = r.left;
      baseTop = r.top;

      if(el.id === 'pdf-pane'){
        const ifr = el.querySelector('iframe');
        if(ifr){
          blockedIframe = ifr;
          ifr.style.pointerEvents = 'none';
        }
      }
      e.preventDefault();
    });

    window.addEventListener('mousemove', (e)=>{
      if(!dragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      el.style.left = (baseLeft + dx) + 'px';
      el.style.top  = (baseTop + dy) + 'px';
      const winW = window.innerWidth, winH = window.innerHeight;
      const rect = el.getBoundingClientRect();
      if(rect.left < 8) el.style.left = '8px';
      if(rect.top < 8) el.style.top = '8px';
      if(rect.right > winW - 8) el.style.left = (winW - 8 - rect.width) + 'px';
      if(rect.bottom > winH - 8) el.style.top = (winH - 8 - rect.height) + 'px';
      e.preventDefault();
    });

    window.addEventListener('mouseup', ()=>{
      if(!dragging) return;
      dragging = false;
      if(blockedIframe){
        blockedIframe.style.pointerEvents = '';
        blockedIframe = null;
      }
    });

    window.addEventListener('mouseleave', ()=>{
      dragging = false;
      if(blockedIframe){
        blockedIframe.style.pointerEvents = '';
        blockedIframe = null;
      }
    });
  }

  // create a close (X) button inside the pdf-pane top-right
  let closeBtn = null;
  function createCloseButton(){
    if(!pane) return;
    // ensure pane positioned to contain the absolute button
    const curPos = getComputedStyle(pane).position;
    if(curPos === 'static' || !curPos){
      pane.style.position = 'relative';
    }
    closeBtn = document.createElement('button');
    closeBtn.id = 'pdf-close-btn';
    closeBtn.setAttribute('aria-label','Close Lecture Viewer');
    closeBtn.innerText = '✕';
    // basic styles — color will be set to match the title if available
    closeBtn.style.position = 'absolute';
    closeBtn.style.top = '8px';
    closeBtn.style.right = '8px';
    closeBtn.style.border = '1px solid rgba(255,255,255,0.08)';
    closeBtn.style.background = 'rgba(255,255,255,0.03)';
    closeBtn.style.fontSize = '22px';
    closeBtn.style.cursor = 'pointer';
    closeBtn.style.padding = '6px 8px';
    closeBtn.style.lineHeight = '1';
    closeBtn.style.zIndex = '1002';
    closeBtn.style.borderRadius = '8px';
    closeBtn.style.boxShadow = '0 2px 8px rgba(0,0,0,0.4)';
    closeBtn.style.fontWeight = '600';

    // match color of the title if possible
    try{
      const tc = (titleEl && getComputedStyle(titleEl).color) ? getComputedStyle(titleEl).color : null;
      if(tc) closeBtn.style.color = tc;
    }catch(err){}
    // append to pane and hide initially
    pane.appendChild(closeBtn);
    closeBtn.style.display = 'none';
    closeBtn.addEventListener('click', hideViewer);
  }

  // Show/hide viewer. Note: the main "Show Lecture Viewer" button remains as the opener.
  function showViewer(){
    if(!area) return;
    // restore quiz to normal flow so layout recalculates and no scrollbars appear
    unfix(quiz);
    // ensure pdf pane sits on top
    if(pane){
      pane.style.zIndex = 1000;
      if(closeBtn) closeBtn.style.display = 'block';
    }
    area.classList.add('viewer-open');
    // hide instructions button when viewer opens
    try{var ib=document.getElementById('instr-btn'); if(ib){ if(!ib.dataset._origDisplay) ib.dataset._origDisplay = getComputedStyle(ib).display || 'inline-flex'; ib.style.display = 'none'; }}catch(e){}

    // do not change text of the opener button — it stays "Show Lecture Viewer"
  }

  function hideViewer(){
    if(!area) return;
    area.classList.remove('viewer-open');
    // restore instructions button when viewer closes
    try{var ib=document.getElementById('instr-btn'); if(ib){ ib.style.display = ib.dataset._origDisplay || ''; delete ib.dataset._origDisplay; }}catch(e){}

    // hide close button
    if(closeBtn) closeBtn.style.display = 'none';
    // also clear any zIndex we set on pane
    if(pane) pane.style.zIndex = '';
  }

  // Initialize
  if(btn){
    // make the button an opener only (always say "Show Lecture Viewer")
    btn.addEventListener('click', (e)=>{
      e.preventDefault();
      showViewer();
    });
  }

  if(resetBtn){
    resetBtn.addEventListener('click', ()=>{
      [quiz,pane].forEach(el=>{ if(el){ unfix(el); } });
      if(area) area.classList.add('viewer-open');
      window.scrollTo(0,0);
    });
  }

  if(quiz) makeDraggable(quiz);
  if(pane) makeDraggable(pane);

  createCloseButton();

  // Clicking a lecture loads its viewer page into the iframe and opens the viewer
  document.querySelectorAll('#resources-list a[data-view]').forEach(a=>{
    a.addEventListener('click', (ev)=>{
      ev.preventDefault();
      const url = a.getAttribute('data-view') || 'about:blank';
      showViewer(); // this will unfix the quiz before opening the viewer
      if(iframe) iframe.src = url;
      const resourcesToggle = document.getElementById('resources-toggle');
      if(resourcesToggle) resourcesToggle.open = false;
      const t = a.querySelector('.resources-title')?.textContent || 'Lecture Viewer';
      const title = document.getElementById('pdf-title');
      if(title) title.textContent = t;
      // update close button color if needed
      if(closeBtn && title){
        try{ closeBtn.style.color = getComputedStyle(title).color; }catch(err){}
      }
    });
  });
})();


// --- Zoom controls for PDF iframe ---
(function(){
  const iframe = document.getElementById('pdf-iframe');
  const zoomOut = document.getElementById('pdf-zoom-out');
  const zoomIn = document.getElementById('pdf-zoom-in');
  const zoomReset = document.getElementById('pdf-zoom-reset');
  const zoomSlider = document.getElementById('pdf-zoom-slider');
  let zoom = 1.0;

  function applyZoom(z){
    if(!iframe) return;
    zoom = Math.min(2.5, Math.max(0.5, z));
    iframe.style.transformOrigin = '0 0';
    iframe.style.transform = 'scale(' + zoom + ')';
    iframe.style.width = (100/zoom) + '%';
    iframe.style.height = (100/zoom) + '%';
    if(zoomSlider) zoomSlider.value = Math.round(zoom*100);
    if(zoomReset) zoomReset.textContent = Math.round(zoom*100) + '%';
  }

  if(zoomIn) zoomIn.addEventListener('click', ()=> applyZoom(zoom + 0.1));
  if(zoomOut) zoomOut.addEventListener('click', ()=> applyZoom(zoom - 0.1));
  if(zoomReset) zoomReset.addEventListener('click', ()=> applyZoom(1));
  if(zoomSlider) zoomSlider.addEventListener('input', (e)=> applyZoom(e.target.value/100));

  // initialize at 100%
  applyZoom(1);
})();

</script>
<script>
(function(){
  // Remove the +/- controls entirely (they were hidden earlier, but ensure they're gone)
  try{ ['pdf-zoom-in','pdf-zoom-out','pdf-zoom-slider','pdf-zoom-reset','pdf-controls'].forEach(function(id){ var el = document.getElementById(id); if(el) el.style.display = 'none'; }); }catch(e){}

  var iframe = document.getElementById('pdf-iframe');
  var pane = document.getElementById('pdf-pane');
  var overlay = document.getElementById('pdf-overlay');
  var interactBtn = document.getElementById('pdf-interact-toggle');
  var closeBtn = document.getElementById('pdf-close-btn');

  if(!pane) return;
  if(!overlay){
    // create overlay if for some reason it wasn't created above
    overlay = document.createElement('div');
    overlay.id = 'pdf-overlay';
    overlay.style.position = 'absolute';
    overlay.style.inset = '0';
    overlay.style.zIndex = '1001';
    overlay.style.background = 'transparent';
    overlay.style.touchAction = 'none';
    pane.appendChild(overlay);
  }

  // Ensure pane is positioned to allow absolutely positioned overlay
  var panePos = getComputedStyle(pane).position;
  if(panePos === 'static') pane.style.position = 'relative';

  // Interact toggle: when pressed (true), overlay is disabled so user can click inside iframe
  var interacting = false;
  function updateInteractButton(){
    if(!interactBtn) return;
    interactBtn.innerText = interacting ? 'Interact: ON' : 'Interact: OFF';
    interactBtn.setAttribute('aria-pressed', interacting ? 'true' : 'false');
    overlay.style.pointerEvents = interacting ? 'none' : 'auto';
  }
  if(interactBtn){
    interactBtn.addEventListener('click', function(e){
      interacting = !interacting;
      updateInteractButton();
    });
  }
  // default: overlay active (Interact OFF) so zoom works by default
  interacting = false;
  updateInteractButton();

  // Zoom state and applyZoom function (keeps consistent with previous implementation)
  var zoom = 1.0;
  function applyZoom(z){
    zoom = Math.min(2.5, Math.max(0.5, z));
    if(!iframe) return;
    iframe.style.transformOrigin = '0 0';
    iframe.style.transform = 'scale(' + zoom + ')';
    iframe.style.width = (100/zoom) + '%';
    iframe.style.height = (100/zoom) + '%';
  }
  applyZoom(1.0);

  // Utility: distance between two touches
  function dist(p1,p2){ var dx = p2.clientX - p1.clientX; var dy = p2.clientY - p1.clientY; return Math.sqrt(dx*dx + dy*dy); }

  // Touch pinch handling on the overlay
  var pinch = {active:false, startDist:0, startZoom:1};
  overlay.addEventListener('touchstart', function(e){
    if(e.touches && e.touches.length === 2){
      pinch.active = true;
      pinch.startDist = dist(e.touches[0], e.touches[1]);
      pinch.startZoom = zoom;
      e.preventDefault();
    }
  }, {passive:false});
  overlay.addEventListener('touchmove', function(e){
    if(pinch.active && e.touches && e.touches.length === 2){
      var d = dist(e.touches[0], e.touches[1]);
      var scale = d / pinch.startDist;
      applyZoom(pinch.startZoom * scale);
      e.preventDefault();
    }
  }, {passive:false});
  overlay.addEventListener('touchend', function(e){
    if(pinch.active && (!e.touches || e.touches.length < 2)){
      pinch.active = false;
    }
  });

  // Trackpad pinch / ctrl+wheel handling on the overlay
  overlay.addEventListener('wheel', function(e){
    // If overlay disabled (interacting), don't intercept wheel events
    if(interacting) return;
    // Some browsers send ctrlKey during pinch gesture on touchpad; accept either ctrlKey or wheel delta mode
    if(e.ctrlKey || Math.abs(e.deltaY) > 0){
      // interpret wheel as pinch-like: small factor change
      var factor = 1 - (e.deltaY * 0.0016);
      applyZoom(zoom * factor);
      e.preventDefault();
    }
  }, {passive:false});

  // Safari gesture events support
  overlay.addEventListener('gesturestart', function(e){ if(e.scale){ pinch.active = true; pinch.startZoom = zoom; } }, false);
  overlay.addEventListener('gesturechange', function(e){ if(e.scale && pinch.active){ applyZoom(pinch.startZoom * e.scale); e.preventDefault(); } }, false);
  overlay.addEventListener('gestureend', function(e){ pinch.active = false; }, false);

  // Visual hint: briefly flash overlay border when user first uses pinch/wheel so they know zoom is active
  var hinted = false;
  function flashHint(){
    if(hinted) return;
    hinted = true;
    overlay.style.boxShadow = 'inset 0 0 0 2px rgba(0,0,0,0.06)';
    setTimeout(function(){ overlay.style.boxShadow = ''; }, 600);
  }
  overlay.addEventListener('wheel', flashHint, {passive:true});
  overlay.addEventListener('touchstart', flashHint, {passive:true});

  // Ensure close button is visible and on top
  if(closeBtn){
    closeBtn.style.zIndex = '1004';
    closeBtn.style.display = 'flex';
  }
})();
</script>
<script>
(function(){
  var iframe = document.getElementById('pdf-iframe');
  var overlay = document.getElementById('pdf-overlay');
  var interactBtn = document.getElementById('pdf-interact-toggle');
  try{
    if(!iframe) return;
    var same = false;
    try{
      // Accessing contentDocument will throw if cross-origin
      var doc = iframe.contentDocument || (iframe.contentWindow && iframe.contentWindow.document);
      if(doc) same = true;
    }catch(e){
      same = false;
    }
    if(same){
      // Remove overlay and interact toggle to allow direct interaction with the iframe content
      if(overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
      if(interactBtn && interactBtn.parentNode) interactBtn.parentNode.removeChild(interactBtn);
      // Ensure iframe accepts pointer events
      iframe.style.pointerEvents = 'auto';
    } else {
      // For cross-origin iframes, keep overlay behavior as-is
      if(iframe) iframe.style.pointerEvents = 'none';
    }
  }catch(err){
    console.warn('Same-origin detection failed', err);
  }
})();
</script>
<script>
(function(){
  // Utility functions
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  // Targets we want resizable
  var targets = [
    {id: 'quiz-card', minW: 320, minH: 200},
    {id: 'pdf-pane', minW: 320, minH: 200}
  ];

  // On load, record the original bounding sizes so resizing cannot go smaller than the original.
  targets.forEach(function(t){
    var el = document.getElementById(t.id);
    if(!el) return;
    var r = el.getBoundingClientRect();
    // store original size only once
    if(!el.dataset.origWidth) el.dataset.origWidth = Math.max(20, Math.round(r.width));
    if(!el.dataset.origHeight) el.dataset.origHeight = Math.max(20, Math.round(r.height));
    // initialize user-set values to none
    if(!el.dataset.userWidth) el.dataset.userWidth = '';
    if(!el.dataset.userHeight) el.dataset.userHeight = '';
    if(!el.dataset.userLeft) el.dataset.userLeft = '';
    if(!el.dataset.userTop) el.dataset.userTop = '';
  });

  targets.forEach(function(t){
    var el = document.getElementById(t.id);
    if(!el) return;
    // Ensure element is positioned so resizers can be placed correctly.
    var computed = getComputedStyle(el).position;
    if(computed === 'static' || !computed){
      el.style.position = 'relative';
    }
  });

  var active = null; // {el, dir, startRect, startX, startY, minW, minH}

  function onPointerDown(e){
    var target = e.target;
    if(!target.classList.contains('resizer')) return;
    e.preventDefault();
    var dir = target.getAttribute('data-dir');
    var container = target.closest('#quiz-card, #pdf-pane');
    if(!container) return;

    // Get bounding rect and initial values
    var r = container.getBoundingClientRect();
    var startLeft = r.left;
    var startTop = r.top;
    var startWidth = r.width;
    var startHeight = r.height;

    // Convert to fixed positioning (only if not already fixed)
    var prevPos = getComputedStyle(container).position;
    if(prevPos !== 'fixed'){
      // set fixed positioning using current rect so layout below doesn't reflow during resize
      container.dataset._origPosition = prevPos;
      container.style.position = 'fixed';
      container.style.left = Math.max(8, Math.round(r.left)) + 'px';
      container.style.top  = Math.max(8, Math.round(r.top)) + 'px';
      container.style.width = Math.round(r.width) + 'px';
      container.style.height = Math.round(r.height) + 'px';
      container.style.boxSizing = 'border-box';
      container.style.zIndex = 2000;
    }

    // disable pointer events on iframe inside pdf-pane during resize to avoid capturing mouse
    var innerIframe = container.querySelector('iframe');
    if(innerIframe) innerIframe.style.pointerEvents = 'none';

    // Determine minimum allowed sizes based on original size (can't go smaller than original)
    var origW = parseFloat(container.dataset.origWidth) || 120;
    var origH = parseFloat(container.dataset.origHeight) || 80;
    var minW = Math.max(origW,  (container.id === 'pdf-pane' ? 360 : 320));
    var minH = Math.max(origH,  (container.id === 'pdf-pane' ? 240 : 200));

    active = {
      el: container,
      dir: dir,
      startX: e.clientX,
      startY: e.clientY,
      startLeft: startLeft,
      startTop: startTop,
      startWidth: startWidth,
      startHeight: startHeight,
      minW: minW,
      minH: minH,
      origPos: prevPos
    };

    // Prevent text selection
    document.body.style.userSelect = 'none';

    window.addEventListener('mousemove', onPointerMove);
    window.addEventListener('mouseup', onPointerUp);
  }

  function onPointerMove(e){
    if(!active) return;
    e.preventDefault();
    var dx = e.clientX - active.startX;
    var dy = e.clientY - active.startY;

    var newLeft = active.startLeft;
    var newTop = active.startTop;
    var newWidth = active.startWidth;
    var newHeight = active.startHeight;

    var maxWidth = Math.max(active.minW, window.innerWidth - 16);
    var maxHeight = Math.max(active.minH, window.innerHeight - 16);

    // adjust based on direction
    if(active.dir.indexOf('e') !== -1){
      newWidth = clamp(active.startWidth + dx, active.minW, maxWidth);
    }
    if(active.dir.indexOf('s') !== -1){
      newHeight = clamp(active.startHeight + dy, active.minH, maxHeight);
    }
    if(active.dir.indexOf('w') !== -1){
      newWidth = clamp(active.startWidth - dx, active.minW, maxWidth);
      newLeft = active.startLeft + (active.startWidth - newWidth);
      // ensure left doesn't go off-screen
      newLeft = clamp(newLeft, 8, window.innerWidth - active.minW - 8);
    }
    if(active.dir.indexOf('n') !== -1){
      newHeight = clamp(active.startHeight - dy, active.minH, maxHeight);
      newTop = active.startTop + (active.startHeight - newHeight);
      newTop = clamp(newTop, 8, window.innerHeight - active.minH - 8);
    }

    // apply styles
    active.el.style.width = Math.round(newWidth) + 'px';
    active.el.style.height = Math.round(newHeight) + 'px';
    active.el.style.left = Math.round(newLeft) + 'px';
    active.el.style.top = Math.round(newTop) + 'px';
  }

  function onPointerUp(e){
    if(!active) return;
    // restore iframe pointerEvents
    var innerIframe = active.el.querySelector('iframe');
    if(innerIframe) innerIframe.style.pointerEvents = '';

    // store the user's resized values so they persist and can be reapplied when viewer is shown
    try{
      active.el.dataset.userWidth = active.el.style.width || '';
      active.el.dataset.userHeight = active.el.style.height || '';
      active.el.dataset.userLeft = active.el.style.left || '';
      active.el.dataset.userTop = active.el.style.top || '';
      active.el.dataset.resized = 'true';
    }catch(err){}

    // restore userSelect
    document.body.style.userSelect = '';

    // Remove event listeners
    window.removeEventListener('mousemove', onPointerMove);
    window.removeEventListener('mouseup', onPointerUp);
    active = null;
  }

  // Attach pointerdown to the document so dynamically added resizers are captured
  document.addEventListener('mousedown', onPointerDown);

  // For touch support on the resizers, map touchstart to pointerdown logic
  document.addEventListener('touchstart', function(e){
    var t = e.target;
    if(t && t.classList && t.classList.contains('resizer')){
      onPointerDown({ target: t, clientX: e.touches[0].clientX, clientY: e.touches[0].clientY, preventDefault: function(){} });
    }
  }, {passive:false});

  // Keep resizers visible on window resize adjustments
  window.addEventListener('resize', function(){
    // ensure elements don't exceed viewport after resize, and reapply if needed
    ['quiz-card','pdf-pane'].forEach(function(id){
      var el = document.getElementById(id);
      if(!el) return;
      var r = el.getBoundingClientRect();
      var maxW = Math.max(200, window.innerWidth - 16);
      var maxH = Math.max(200, window.innerHeight - 16);
      var changed = false;
      if(r.width > maxW){ el.style.width = maxW + 'px'; changed = true; }
      if(r.height > maxH){ el.style.height = maxH + 'px'; changed = true; }
      if(r.left + r.width > window.innerWidth - 8){ el.style.left = Math.max(8, window.innerWidth - r.width - 8) + 'px'; changed = true; }
      if(r.top + r.height > window.innerHeight - 8){ el.style.top = Math.max(8, window.innerHeight - r.height - 8) + 'px'; changed = true; }
      if(changed) { el.style.boxSizing = 'border-box'; }
    });
  });

  // Helper: make resizers focusable for keyboard (optional)
  document.querySelectorAll('.resizer').forEach(function(r){ r.setAttribute('tabindex','0'); r.setAttribute('aria-label','Resize handle'); });

  // Reapply stored user sizes for pdf-pane (or any target) when the viewer is shown.
  function reapplyUserSizes(){
    try{
      var pane = document.getElementById('pdf-pane');
      if(pane && pane.dataset && pane.dataset.resized === 'true'){
        // ensure pane stays fixed and retain user's values
        pane.style.position = 'fixed';
        if(pane.dataset.userLeft) pane.style.left = pane.dataset.userLeft;
        if(pane.dataset.userTop) pane.style.top = pane.dataset.userTop;
        if(pane.dataset.userWidth) pane.style.width = pane.dataset.userWidth;
        if(pane.dataset.userHeight) pane.style.height = pane.dataset.userHeight;
        pane.style.boxSizing = 'border-box';
        pane.style.zIndex = 1000;
      }
      // also reapply for quiz-card in case it was altered elsewhere
      var quiz = document.getElementById('quiz-card');
      if(quiz && quiz.dataset && quiz.dataset.resized === 'true'){
        quiz.style.position = 'fixed';
        if(quiz.dataset.userLeft) quiz.style.left = quiz.dataset.userLeft;
        if(quiz.dataset.userTop) quiz.style.top = quiz.dataset.userTop;
        if(quiz.dataset.userWidth) quiz.style.width = quiz.dataset.userWidth;
        if(quiz.dataset.userHeight) quiz.style.height = quiz.dataset.userHeight;
        quiz.style.boxSizing = 'border-box';
      }
    }catch(err){ console.warn('reapplyUserSizes error', err); }
  }

  // Hook into the show viewer flow: if there's a "Show Lecture Viewer" button, attach to its click;
  // also watch for clicks on resource links that open the viewer.
  var opener = document.getElementById('viewer-toggle-btn');
  if(opener) opener.addEventListener('click', function(){ setTimeout(reapplyUserSizes, 60); });

  document.querySelectorAll && document.querySelectorAll('#resources-list a[data-view]').forEach(function(a){
    a.addEventListener('click', function(){ setTimeout(reapplyUserSizes, 60); });
  });

  // Also observe mutations in case something else toggles viewer visibility
  try{
    var area = document.getElementById('work-area');
    if(area){
      var mo = new MutationObserver(function(muts){
        muts.forEach(function(mu){
          if(mu.attributeName === 'class'){
            // viewer-open class toggled
            setTimeout(reapplyUserSizes, 60);
          }
        });
      });
      mo.observe(area, { attributes: true });
    }
  }catch(err){}
})();
</script>
<script>
(function(){
  // Create snap prompt UI
  function createSnapPrompt(){
    if(document.getElementById('snap-prompt')) return;
    var p = document.createElement('div');
    p.id = 'snap-prompt';
    p.style.position = 'fixed';
    p.style.left = '50%';
    p.style.top = '50%';
    p.style.transform = 'translate(-50%,-50%)';
    p.style.zIndex = 10050;
    p.style.padding = '12px';
    p.style.background = 'rgba(255,255,255,0.98)';
    p.style.border = '1px solid rgba(0,0,0,0.08)';
    p.style.boxShadow = '0 8px 30px rgba(0,0,0,0.25)';
    p.style.borderRadius = '10px';
    p.style.display = 'none';
    p.style.minWidth = '280px';
    p.style.textAlign = 'center';
    p.innerHTML = '<div style="font-weight:600;margin-bottom:8px">Windows detected overlap</div>' +
                  '<div style="margin-bottom:10px;font-size:13px;color:#333">Would you like to split the screen so each occupies half?</div>' +
                  '<div style="display:flex;gap:8px;justify-content:center">' +
                  '<button id="snap-lr" style="padding:8px 10px;border-radius:6px;border:1px solid rgba(0,0,0,0.08);background:#f5f5f5;cursor:pointer">Split Left / Right</button>' +
                  '<button id="snap-tb" style="padding:8px 10px;border-radius:6px;border:1px solid rgba(0,0,0,0.08);background:#f5f5f5;cursor:pointer">Split Top / Bottom</button>' +
                  '<button id="snap-cancel" style="padding:8px 10px;border-radius:6px;border:1px solid rgba(0,0,0,0.08);background:transparent;cursor:pointer">Cancel</button>' +
                  '</div>';
    document.body.appendChild(p);
    document.getElementById('snap-lr').addEventListener('click', function(){ applySplit('lr'); hidePrompt(); });
    document.getElementById('snap-tb').addEventListener('click', function(){ applySplit('tb'); hidePrompt(); });
    document.getElementById('snap-cancel').addEventListener('click', function(){ hidePrompt(true); });
  }

  function showPrompt(){
    createSnapPrompt();
    var p = document.getElementById('snap-prompt');
    if(!p) return;
    p.style.display = 'block';
  }
  function hidePrompt(cancel){
    var p = document.getElementById('snap-prompt');
    if(!p) return;
    p.style.display = 'none';
    if(cancel){
      // mark a temporary suppression for 1.5s to avoid repeat prompting
      lastSuppress = Date.now();
    }
  }

  // Utility: rect intersection test
  function rectsOverlap(r1, r2){
    return !(r2.left >= r1.right || r2.right <= r1.left || r2.top >= r1.bottom || r2.bottom <= r1.top);
  }

  // Apply split: lr = left/right, tb = top/bottom
  function applySplit(mode){
    var quiz = document.getElementById('quiz-card');
    var pane = document.getElementById('pdf-pane');
    if(!quiz || !pane) return;
    var ww = window.innerWidth, wh = window.innerHeight;
    if(mode === 'lr'){
      // left-right split: quiz left half, pane right half
      var halfW = Math.max(200, Math.round(ww/2));
      // quiz
      quiz.style.position = 'fixed';
      quiz.style.left = '0px';
      quiz.style.top = '0px';
      quiz.style.width = halfW + 'px';
      quiz.style.height = wh + 'px';
      quiz.style.boxSizing = 'border-box';
      quiz.style.zIndex = 2000;
      // pane
      pane.style.position = 'fixed';
      pane.style.left = halfW + 'px';
      pane.style.top = '0px';
      pane.style.width = (ww - halfW) + 'px';
      pane.style.height = wh + 'px';
      pane.style.boxSizing = 'border-box';
      pane.style.zIndex = 2000;
    } else {
      // top-bottom split: quiz top half, pane bottom half
      var halfH = Math.max(150, Math.round(wh/2));
      quiz.style.position = 'fixed';
      quiz.style.left = '0px';
      quiz.style.top = '0px';
      quiz.style.width = ww + 'px';
      quiz.style.height = halfH + 'px';
      quiz.style.boxSizing = 'border-box';
      quiz.style.zIndex = 2000;
      pane.style.position = 'fixed';
      pane.style.left = '0px';
      pane.style.top = halfH + 'px';
      pane.style.width = ww + 'px';
      pane.style.height = (wh - halfH) + 'px';
      pane.style.boxSizing = 'border-box';
      pane.style.zIndex = 2000;
    }
    // mark snapped so we don't repeatedly prompt
    try{ quiz.dataset.snapped = 'true'; pane.dataset.snapped = 'true'; }catch(e){}
  }

  // Overlap detector removed
</script>
<script>
(function(){
  // Force a left/right split when the viewer is opened and hide scrollbars.
  function forceLeftRightSplit(){
    var quiz = document.getElementById('quiz-card');
    var pane = document.getElementById('pdf-pane');
    var iframe = document.getElementById('pdf-iframe');
    if(!quiz || !pane) return;
    var ww = window.innerWidth, wh = window.innerHeight;
    var halfW = Math.max(200, Math.round(ww/2));
    // quiz left
    quiz.style.position = 'fixed';
    quiz.style.left = '0px';
    quiz.style.top = '0px';
    quiz.style.width = halfW + 'px';
    quiz.style.height = wh + 'px';
    quiz.style.boxSizing = 'border-box';
    quiz.style.zIndex = 2000;
    // pane right
    pane.style.position = 'fixed';
    pane.style.left = halfW + 'px';
    pane.style.top = '0px';
    pane.style.width = (ww - halfW) + 'px';
    pane.style.height = wh + 'px';
    pane.style.boxSizing = 'border-box';
    pane.style.zIndex = 2000;
    // hide scrollbars for pane and iframe and quiz
    try{
      pane.style.overflow = 'hidden';
      pane.style.overflowX = 'hidden';
      pane.style.overflowY = 'hidden';
      if(iframe){
        iframe.style.pointerEvents = 'auto';
        iframe.style.overflow = 'hidden';
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        // also ensure transform origin is at top-left so previous zooming continues to work
        iframe.style.transformOrigin = '0 0';
      }
      // hide scrollbars for quiz card too
      quiz.style.overflow = 'hidden';
      quiz.style.overflowX = 'hidden';
      quiz.style.overflowY = 'hidden';
    }catch(e){}
  }

  // Attach to the viewer-toggle button to force split when opened
  var opener = document.getElementById('viewer-toggle-btn');
  if(opener){
    opener.addEventListener('click', function(e){
      // allow existing logic to open viewer, then force split shortly after
      setTimeout(forceLeftRightSplit, 60);
    });
  }

  // Also attach to resource links that open viewer
  document.querySelectorAll && document.querySelectorAll('#resources-list a[data-view]').forEach(function(a){
    a.addEventListener('click', function(){
      setTimeout(forceLeftRightSplit, 60);
    });
  });

  // Also listen for class toggles on work-area (viewer-open) so if viewer is opened elsewhere we snap
  var area = document.getElementById('work-area');
  if(area){
    var mo = new MutationObserver(function(muts){
      muts.forEach(function(mu){
        if(mu.attributeName === 'class'){
          if(area.classList && area.classList.contains('viewer-open')){
            setTimeout(forceLeftRightSplit, 60);
          }
        }
      });
    });
    mo.observe(area, { attributes: true });
  }

  // Ensure on window resize while snapped we maintain half-split
  window.addEventListener('resize', function(){
    var quiz = document.getElementById('quiz-card');
    var pane = document.getElementById('pdf-pane');
    if(!quiz || !pane) return;
    // if both are fixed and occupying full height, reapply half widths
    if(getComputedStyle(quiz).position === 'fixed' && getComputedStyle(pane).position === 'fixed'){
      var ww = window.innerWidth, wh = window.innerHeight;
      var halfW = Math.max(200, Math.round(ww/2));
      quiz.style.left = '0px';
      quiz.style.top = '0px';
      quiz.style.width = halfW + 'px';
      quiz.style.height = wh + 'px';
      pane.style.left = halfW + 'px';
      pane.style.top = '0px';
      pane.style.width = (ww - halfW) + 'px';
      pane.style.height = wh + 'px';
    }
  });
})();
</script>
<script>
(function(){
  var opener = document.getElementById('viewer-toggle-btn');
  var quiz = document.getElementById('quiz-card');
  var pane = document.getElementById('pdf-pane');
  var closeBtn = document.getElementById('pdf-close-btn');
  var area = document.getElementById('work-area');

  function saveQuizState(){
    if(!quiz) return;
    // Save only once per open action
    quiz.dataset._savedPosition = quiz.style.position || '';
    quiz.dataset._savedLeft = quiz.style.left || '';
    quiz.dataset._savedTop = quiz.style.top || '';
    quiz.dataset._savedWidth = quiz.style.width || '';
    quiz.dataset._savedHeight = quiz.style.height || '';
    quiz.dataset._savedOverflow = quiz.style.overflow || '';
    quiz.dataset._savedZ = quiz.style.zIndex || '';
    quiz.dataset._wasSaved = 'true';
  }

  function restoreQuizState(){
    if(!quiz) return;
    if(quiz.dataset._wasSaved !== 'true') return;
    // Restore saved inline styles
    quiz.style.position = quiz.dataset._savedPosition || '';
    quiz.style.left = quiz.dataset._savedLeft || '';
    quiz.style.top = quiz.dataset._savedTop || '';
    quiz.style.width = quiz.dataset._savedWidth || '';
    quiz.style.height = quiz.dataset._savedHeight || '';
    quiz.style.overflow = quiz.dataset._savedOverflow || '';
    quiz.style.zIndex = quiz.dataset._savedZ || '';
    // clear flags
    delete quiz.dataset._wasSaved;
    delete quiz.dataset._savedPosition;
    delete quiz.dataset._savedLeft;
    delete quiz.dataset._savedTop;
    delete quiz.dataset._savedWidth;
    delete quiz.dataset._savedHeight;
    delete quiz.dataset._savedOverflow;
    delete quiz.dataset._savedZ;
  }

  // When opener is clicked, save quiz state and hide the opener button.
  if(opener){
    opener.addEventListener('click', function(){
      try{ saveQuizState(); }catch(e){}
      try{ opener.style.display = 'none'; }catch(e){}
      // existing logic will open viewer and force split; no further action needed here
    }, {capture:false});
  }

  // When close button is clicked, restore quiz state and show opener again.
  if(closeBtn){
    closeBtn.addEventListener('click', function(e){
      try{
        // call existing hideViewer if available to close viewer UI
        if(typeof hideViewer === 'function') hideViewer();
        else if(area && area.classList) area.classList.remove('viewer-open');
      }catch(err){}
      // restore quiz box to its saved state
      try{ restoreQuizState(); }catch(e){}
      // reveal opener again
      try{ if(opener) opener.style.display = ''; }catch(e){}
    }, {capture:false});
  }

  // Also if user closes viewer by other means (e.g., pressing ESC or external scripts), ensure opener is shown.
  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape'){
      try{ if(opener) opener.style.display = ''; }catch(err){} 
      try{ restoreQuizState(); }catch(err){} 
    }
  });

  // Defensive: if the viewer is hidden by code (viewer-open class removed), re-show opener and restore quiz.
  var moTarget = area || document.body;
  try{
    var mo = new MutationObserver(function(muts){
      muts.forEach(function(mu){
        if(mu.attributeName === 'class'){
          if(area && area.classList && !area.classList.contains('viewer-open')){
            // viewer closed - restore
            try{ restoreQuizState(); }catch(e){};
            try{ if(opener) opener.style.display = ''; }catch(e){};
          }
        }
      });
    });
    mo.observe(moTarget, { attributes: true, subtree: false });
  }catch(err){}
})();
</script>
<script>
(function(){
  function styleCloseButton(){
    var closeBtn = document.getElementById('pdf-close-btn');
    var title = document.getElementById('pdf-title');
    if(!closeBtn) return;
    // Make sure it's visible and styled as glass
    closeBtn.style.background = 'rgba(255,255,255,0.06)';
    closeBtn.style.webkitBackdropFilter = 'blur(8px)';
    closeBtn.style.backdropFilter = 'blur(8px)';
    closeBtn.style.border = '1px solid rgba(255,255,255,0.10)';
    closeBtn.style.fontWeight = '700';
    closeBtn.style.display = 'flex';
    closeBtn.style.alignItems = 'center';
    closeBtn.style.justifyContent = 'center';
    // Match color to title if available
    try{
      if(title){
        var tc = getComputedStyle(title).color;
        if(tc) closeBtn.style.color = tc;
      }
    }catch(err){}
  }

  // Collapse helper: collapse resources area after a link is clicked
  function collapseResources(){
    // Try some likely containers
    var candidates = [
      document.getElementById('resources-list'),
      document.getElementById('resources-panel'),
      document.getElementById('lecture-pdfs'),
      document.querySelector('.resources-list'),
      document.querySelector('#work-area #resources-list')
    ];
    var container = null;
    for(var i=0;i<candidates.length;i++){ if(candidates[i]){ container = candidates[i]; break; } }
    if(!container) {
      // As a fallback, try to find any element that contains links with data-view attribute
      var any = document.querySelector('a[data-view]');
      if(any) container = any.closest('div');
    }
    if(!container) return;
    // Close any open details
    container.querySelectorAll('details[open]').forEach(function(d){ d.open = false; });
    // Remove bootstrap-like show classes
    container.querySelectorAll('.collapse.show').forEach(function(el){ el.classList.remove('show'); });
    // Set aria-expanded to false on toggles within container
    container.querySelectorAll('[aria-expanded="true"]').forEach(function(el){ el.setAttribute('aria-expanded','false'); });
    // If there are any elements with class 'expanded' or 'open' remove them
    container.querySelectorAll('.expanded').forEach(function(el){ el.classList.remove('expanded'); });
    container.querySelectorAll('.open').forEach(function(el){ el.classList.remove('open'); });
  }

  // Attach collapse behavior to resource links
  document.querySelectorAll && document.querySelectorAll('#resources-list a[data-view], a[data-view]').forEach(function(a){
    a.addEventListener('click', function(e){
      // collapse after a short delay to allow existing handlers to run
      setTimeout(collapseResources, 80);
    });
  });

  // Re-style the close button on DOMContentLoaded and also whenever the pdf title text might change.
  document.addEventListener('DOMContentLoaded', function(){ styleCloseButton(); });
  // Also try to style immediately in case script runs after DOM ready
  styleCloseButton();

  // Observe title changes to reapply color
  var title = document.getElementById('pdf-title');
  if(title){
    try{
      var mo = new MutationObserver(function(){ styleCloseButton(); });
      mo.observe(title, { childList: true, characterData: true, subtree: true });
    }catch(e){}
  }
})();
</script>
<!-- Auto-hide Instructions button when a Lecture Viewer is shown, and restore when closed -->
<script>
document.addEventListener('DOMContentLoaded', function(){
  try{
    var instrBtn = document.getElementById('instr-btn');
    if(!instrBtn) return;
    // store original display
    if(!instrBtn.dataset.origDisplay) instrBtn.dataset.origDisplay = getComputedStyle(instrBtn).display || 'inline-flex';
    function setInstrVisible(show){
      instrBtn.style.display = show ? instrBtn.dataset.origDisplay : 'none';
    }
    function isAnyLectureVisible(){
      var selectors = ['#lecture-viewer', '.lecture-viewer', '#viewer', '.viewer', '#lectureModal', '.lecture-modal', '#lecture_panel', '[data-lecture-viewer]'];
      for(var i=0;i<selectors.length;i++){
        var el = document.querySelector(selectors[i]);
        if(!el) continue;
        var cs = getComputedStyle(el);
        if(el.hidden || cs.display === 'none' || cs.visibility === 'hidden') continue;
        if(el.offsetWidth>0 || el.offsetHeight>0 || el.getClientRects().length>0) return true;
      }
      return false;
    }
    function checkAndUpdate(){
      try{
        setInstrVisible(!isAnyLectureVisible());
      }catch(e){}
    }
    // initial check
    setTimeout(checkAndUpdate, 50);
    // observe changes in the DOM that might show/hide viewers
    var observer = new MutationObserver(function(){ setTimeout(checkAndUpdate, 30); });
    observer.observe(document.body, {attributes:true, childList:true, subtree:true, attributeFilter:['style','class','hidden']});
    // also listen for likely open/close clicks (defensive)
    document.addEventListener('click', function(e){
      var t = e.target;
      var text = (t.textContent||'').toLowerCase();
      var aria = (t.getAttribute && (t.getAttribute('aria-label')||'')).toLowerCase();
      var dataAction = (t.getAttribute && (t.getAttribute('data-action')||'')).toLowerCase();
      if(text.includes('show lecture viewer') || dataAction.includes('lecture') || aria.includes('lecture')){
        setTimeout(checkAndUpdate, 50);
      }
      if(text.trim()==='x' || text.includes('close') || (t.className && t.className.toLowerCase().indexOf('close')!==-1) || aria==='close'){
        setTimeout(checkAndUpdate, 50);
      }
    }, true);
  }catch(e){}
});
</script>
<!-- Move Instructions, Saved, Import buttons under the question dropdown -->
<script>
document.addEventListener('DOMContentLoaded', function(){
  try{
    var jump = document.getElementById('jump-select');
    var qEl = document.getElementById('question');
    // If neither exists yet, bail (will remain as default positions)
    if(!jump && !qEl) return;
    var containerId = 'controls-under-jump';
    var container = document.getElementById(containerId);
    if(!container){
      container = document.createElement('div');
      container.id = containerId;
      container.style.display = 'flex';
      container.style.gap = '0.5rem';
      container.style.alignItems = 'center';
      container.style.marginTop = '0.25rem';
      container.style.font = 'inherit';
      // IMPORTANT: insert the container *after the question element itself* so it is not removed
      // when the question's innerHTML (which contains the jump-select) is replaced on navigation.
      if(qEl && qEl.parentNode){
        qEl.parentNode.insertBefore(container, qEl.nextSibling);
      } else if(jump && jump.parentNode){
        // fallback: place after the existing jump-select
        jump.parentNode.insertBefore(container, jump.nextSibling);
      } else {
        // last resort: append to quiz-card
        var quiz = document.getElementById('quiz-card');
        if(quiz) quiz.appendChild(container);
        else document.body.appendChild(container);
      }
    }

    // list of button ids to move (in desired order)
    var ids = ['instr-btn','review-menu-btn','import-btn'];
    ids.forEach(function(id){
      var el = document.getElementById(id);
      if(!el) return;
      // if element already inside container, skip
      if(el.parentElement && el.parentElement.id === containerId) return;
      // Move the element into the persistent container
      container.appendChild(el);
      // small visual tweak so they appear neat below the select (do not modify other behavior)
      el.style.margin = '0';
      el.style.padding = el.style.padding || '';
      // ensure they don't float away
      el.style.float = 'none';
    });

    // If any of the controls were previously absolutely positioned near bottom-left,
    // attempt to remove such positioning so they sit naturally in the flow.
    ['instr-btn','review-menu-btn','import-btn'].forEach(function(id){
      var b = document.getElementById(id);
      if(!b) return;
      // only reset problematic inline styles; leave classes intact
      if(b.style.position && b.style.position !== 'static'){
        b.style.position = 'static';
      }
      // remove left/top/right offsets if present inline
      ['left','right','bottom','top','zIndex'].forEach(function(s){ if(b.style[s]) b.style[s] = ''; });
    });

  }catch(e){
    console.warn('move-controls script error', e);
  }
});
</script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  var lectureSection = document.getElementById('resources-toggle');
  if(lectureSection){
    lectureSection.style.display = 'none';
  }
  var viewerBtn = document.getElementById('viewer-toggle-btn');
  if(viewerBtn && lectureSection){
    viewerBtn.addEventListener('click', function(){
      lectureSection.style.display = '';
    });
  }
});
</script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  var lectureSection = document.getElementById('resources-toggle');
  if(lectureSection){
    lectureSection.style.display = 'none';
  }
  var viewerBtn = document.getElementById('viewer-toggle-btn');
  if(viewerBtn && lectureSection){
    viewerBtn.addEventListener('click', function(){
      lectureSection.style.display = '';
    });
  }
  var closeBtn = document.getElementById('pdf-close-btn');
  if(closeBtn && lectureSection){
    closeBtn.addEventListener('click', function(){
      lectureSection.style.display = 'none';
    });
  }
  // In case the close button is dynamically created later
  var observer = new MutationObserver(function(){
    var cb = document.getElementById('pdf-close-btn');
    if(cb && !cb.dataset.listenerAdded){
      cb.addEventListener('click', function(){
        lectureSection.style.display = 'none';
      });
      cb.dataset.listenerAdded = 'true';
    }
  });
  observer.observe(document.body, {childList:true, subtree:true});
});
</script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  var detailsEl = document.getElementById('resources-toggle');
  if(!detailsEl) return;
  var summary = detailsEl.querySelector('summary');
  var content = Array.from(detailsEl.children).filter(el => el.tagName.toLowerCase() !== 'summary')[0];
  if(!summary || !content) return;

  // Prepare for animation
  content.style.overflow = 'hidden';
  content.style.height = '0px';
  content.style.transition = 'height 0.3s ease';

  // Force closed state initially
  detailsEl.removeAttribute('open');

  summary.addEventListener('click', function(e){
    e.preventDefault();
    if(detailsEl.hasAttribute('open')){
      // Closing
      content.style.height = content.scrollHeight + 'px';
      requestAnimationFrame(() => {
        content.style.height = '0px';
      });
      detailsEl.removeAttribute('open');
    } else {
      // Opening
      detailsEl.setAttribute('open', '');
      content.style.height = content.scrollHeight + 'px';
      content.addEventListener('transitionend', function handler(){
        content.style.height = 'auto';
        content.removeEventListener('transitionend', handler);
      });
    }
  });
});
</script>
<script>

// Auto-load when a .json file is selected in the import input (no need to press "Load" button).
(function(){
  try{
    var importJSON = document.getElementById('importJSON') || window.importJSON;
    var importLoad = document.getElementById('importLoad') || window.importLoad;
    if(importJSON){
      importJSON.addEventListener('change', function(){
        if(importJSON.files && importJSON.files[0]){
          // If the Load button has an onclick handler, call it; otherwise call the import handler directly if available.
          try{
            if(typeof importLoad === 'object' && importLoad !== null && importLoad.click) {
              importLoad.click();
            } else if(typeof window.loadImportedJSON === 'function') {
              // If the page exposes a load function, call it.
              window.loadImportedJSON();
            }
          }catch(e){
            console && console.warn && console.warn('Auto-load listener error', e);
          }
        }
      });
    }
  }catch(e){}
})();

</script>

<script>
(function(){
  function $(id){return document.getElementById(id);}
  function esc(s){return (s||"").toString().replace(/[&<>]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[m]));}
  function ensureUI(){
    var qEl = $('question');
    if(!qEl || !qEl.parentNode) return;
    // If toolbar already exists, skip creating again
    if($('evidence-toolbar')) return;
    // Insert toolbar right after the #question element so it persists across innerHTML updates
    var bar = document.createElement('div');
    bar.id = 'evidence-toolbar';
    var btn = document.createElement('button');
    btn.id = 'evidence-toggle-btn';
    btn.type = 'button';
    btn.textContent = 'Show Evidence';
    bar.appendChild(btn);
    qEl.parentNode.insertBefore(bar, qEl.nextSibling);

    var panel = document.createElement('div');
    panel.id = 'evidence-panel';
    qEl.parentNode.insertBefore(panel, bar.nextSibling);

    btn.addEventListener('click', function(){
      if(panel.style.display === 'none' || !panel.style.display){
        populateEvidence(panel);
        panel.style.display = 'block';
        btn.textContent = 'Hide Evidence';
      }else{
        panel.style.display = 'none';
        btn.textContent = 'Show Evidence';
      }
    });
  }

  function populateEvidence(panel){
    try{
      // Access globals declared by the quiz app
      if(typeof questions==='undefined' || typeof order==='undefined' || typeof current==='undefined'){
        panel.innerHTML = '<div class="ev-row">Evidence data unavailable.</div>';
        return;
      }
      var idx = order[current];
      var it = (Array.isArray(questions) && idx!=null) ? questions[idx] : null;
      if(!it){
        panel.innerHTML = '<div class="ev-row">No question loaded.</div>';
        return;
      }
      // Extract metadata
      var meta = it._meta || {};
      var slide = it.slide!=null ? it.slide : (Array.isArray(meta.slide_range) ? meta.slide_range[0] : undefined);
      var slideTitle = meta.slide_title || '';
      var slideUID = meta.slide_uid || '';
      var range = Array.isArray(meta.slide_range) ? meta.slide_range.join('–') : (slide!=null? String(slide):'');
      var evidence = meta.evidence || '';
      var anchors = Array.isArray(meta.anchors) ? meta.anchors : [];

      var html = '';
      html += '<div class="ev-row"><span class="ev-key">Slide:</span><strong>' + esc(range) + '</strong>' 
              + (slideTitle ? ' — ' + esc(slideTitle) : '') + '</div>';
      if(slideUID){ html += '<div class="ev-row"><span class="ev-key">Slide ID:</span><code>'+esc(slideUID)+'</code></div>'; }
      if(evidence){ html += '<div class="ev-row"><span class="ev-key">Evidence:</span>' + esc(evidence) + '</div>'; }
      if(anchors && anchors.length){
        html += '<div class="anchors">';
        for(var i=0;i<anchors.length;i++){
          var a=anchors[i];
          var frag = (a && a.text) ? esc(a.text) : '';
          var off = (a && (a.start!=null) && (a.end!=null)) ? ' ['+a.start+'–'+a.end+']' : '';
          html += '<div class="anchor-item">• ' + frag + off + '</div>';
        }
        html += '</div>';
      }
      if(!html) html = '<div class="ev-row">No evidence metadata present for this question.</div>';
      panel.innerHTML = html;
    }catch(e){
      panel.innerHTML = '<div class="ev-row">Error building evidence panel.</div>';
    }
  }

  function onQuestionChanged(){
    // If panel is open, refresh content to reflect current question
    var panel = document.getElementById('evidence-panel');
    var btn = document.getElementById('evidence-toggle-btn');
    if(panel && btn && panel.style.display==='block'){
      populateEvidence(panel);
    }
  }

  // Observe #question content changes to know when a new question is shown
  function attachObserver(){
    var qEl = document.getElementById('question');
    if(!qEl) return;
    try{
      var obs = new MutationObserver(function(muts){ onQuestionChanged(); });
      obs.observe(qEl, {childList:true, subtree:true, characterData:true});
    }catch(e){}
  }

  document.addEventListener('DOMContentLoaded', function(){
    ensureUI();
    attachObserver();
  });

  // Also run after window load as a fallback
  window.addEventListener('load', function(){
    ensureUI();
    attachObserver();
  });

})();
</script>

<script>
(function(){
  function $(id){ return document.getElementById(id); }
  document.addEventListener('DOMContentLoaded', function(){
    var viewerBtn = $('viewer-toggle-btn');
    if(viewerBtn){
      viewerBtn.textContent = 'Lecture Slides';
    }
    var uploadBtn = $('upload-lectures-btn');
    var fileInput = $('lecture-upload-input');
    var resourcesList = document.getElementById('resources-list');
    var iframe = document.getElementById('pdf-iframe');
    var titleEl = document.getElementById('pdf-title');

    if(uploadBtn && fileInput){
      uploadBtn.addEventListener('click', function(e){
        e.preventDefault();
        fileInput.click();
      });
    }

    function showViewer(){
      // programmatically click the existing viewer toggle to ensure pane is visible
      if(viewerBtn) viewerBtn.click();
    }

    function addResourceEntry(name, url, meta){
      if(!resourcesList) return;
      var li = document.createElement('li');
      var a = document.createElement('a');
      a.href = '#';
      a.className = 'resources-link';
      a.setAttribute('data-view', url);
      // meta type
      var titleSpan = document.createElement('span');
      titleSpan.className = 'resources-title';
      titleSpan.textContent = name;
      var metaSpan = document.createElement('span');
      metaSpan.className = 'resources-meta';
      metaSpan.textContent = meta || 'FILE';
      a.appendChild(titleSpan);
      a.appendChild(metaSpan);
      li.appendChild(a);
      resourcesList.appendChild(li);

      a.addEventListener('click', function(ev){
        ev.preventDefault();
        showViewer();
        if(iframe) iframe.src = url;
        if(titleEl) titleEl.textContent = name;
        var resourcesToggle = document.getElementById('resources-toggle');
        if(resourcesToggle) resourcesToggle.open = false;
      });
    }

    if(fileInput){
      fileInput.addEventListener('change', function(){
        if(!this.files || !this.files.length) return;
        // Add all selected files to resources and open the first
        var firstUrl = null, firstName = null;
        Array.from(this.files).forEach(function(f, idx){
          var url = URL.createObjectURL(f);
          var ext = (f.name.split('.').pop()||'').toUpperCase();
          var meta = ext === 'PDF' ? 'PDF' : (ext==='PPTX'?'PPTX':(ext==='PPT'?'PPT':'FILE'));
          window.addResourceEntry ? window.addResourceEntry(f.name, url, meta) : addResourceEntry(f.name, url, meta);
          if(idx===0){ firstUrl = url; firstName = f.name; }
        });
        if(firstUrl){
          showViewer();
          if(iframe) iframe.src = firstUrl;
          if(titleEl) titleEl.textContent = firstName;
        }
        // clear the input so the same file can be re-selected later
        this.value = '';
      });
    }
  });
})();
</script>


<script>
(function(){
  function $(id){ return document.getElementById(id); }
  const LECTURE_FILES = (window.__LECTURE_FILES__ = window.__LECTURE_FILES__ || new Map());

  // Ensure PPTX overlay exists
  function ensureOverlay(){
    const pane = $('pdf-pane');
    if(!pane) return null;
    let ov = $('pptx-overlay');
    if(!ov){
      ov = document.createElement('div');
      ov.id = 'pptx-overlay';
      ov.innerHTML = [
        '<h3>PowerPoint preview not supported in-browser</h3>',
        '<p>This viewer can display PDFs directly. To view a PowerPoint here, please export it as PDF and re-upload.</p>',
        '<p>Tip: In PowerPoint: <em>File → Save As → PDF</em>.</p>'
      ].join('');
      pane.appendChild(ov);
    }
    return ov;
  }

  document.addEventListener('DOMContentLoaded', function(){
    var resourcesList = document.getElementById('resources-list');
    var iframe = document.getElementById('pdf-iframe');
    var titleEl = document.getElementById('pdf-title');
    var viewerBtn = document.getElementById('viewer-toggle-btn');

    // Wrap the existing addResourceEntry if present, else define ours (compatible with v4)
    window.addResourceEntry = window.addResourceEntry || function(name, url, meta){
      if(!resourcesList) return;
      var li = document.createElement('li');
      var a = document.createElement('a');
      a.href = '#';
      a.className = 'resources-link';
      a.setAttribute('data-view', url);
      a.addEventListener('click', function(ev){
        ev.preventDefault();
      });
      var titleSpan = document.createElement('span');
      titleSpan.className = 'resources-title';
      titleSpan.textContent = name;
      var metaSpan = document.createElement('span');
      metaSpan.className = 'resources-meta';
      metaSpan.textContent = meta || 'FILE';
      a.appendChild(titleSpan);
      a.appendChild(metaSpan);
      li.appendChild(a);

      // Remove "X"
      var rm = document.createElement('span');
      rm.className = 'resource-remove';
      rm.title = 'Remove from list';
      rm.textContent = '×';
      rm.addEventListener('click', function(e){
        e.stopPropagation();
        e.preventDefault();
        // If this resource is showing, clear viewer
        if(titleEl && titleEl.textContent === name){
          titleEl.textContent = '—';
          if(iframe) iframe.src = 'about:blank';
          var ov = $('pptx-overlay'); if(ov) ov.style.display = 'none';
        }
        // Revoke object URL, if we own it
        if(LECTURE_FILES.has(url)){
          try{ URL.revokeObjectURL(url); }catch(_){}
          LECTURE_FILES.delete(url);
        }
        li.remove();
      });
      li.appendChild(rm);

      resourcesList.appendChild(li);

      // Click handler to display in viewer
      a.addEventListener('click', function(ev){
        ev.preventDefault();
        if(viewerBtn) viewerBtn.click(); // open pane
        if(titleEl) titleEl.textContent = name;

        var ext = (name.split('.').pop()||'').toLowerCase();
        var isPDF = (ext === 'pdf');
        var isPPT = (ext === 'ppt' || ext === 'pptx');

        if(isPDF){
          if(iframe) iframe.src = url;
          var ov = $('pptx-overlay'); if(ov) ov.style.display = 'none';
        }else if(isPPT){
          // Prevent download trigger: do NOT navigate iframe to PPT/PPTX.
          if(iframe) iframe.src = 'about:blank';
          var ov = ensureOverlay();
          if(ov) ov.style.display = 'block';
        }else{
          // Unknown file type: show a neutral notice overlay
          if(iframe) iframe.src = 'about:blank';
          var ov = ensureOverlay();
          if(ov){
            ov.innerHTML = '<h3>Preview not available for this file type</h3><p>Please upload a PDF to view here.</p>';
            ov.style.display = 'block';
          }
        }
      });
    };

    // Hook into the uploader from v4 to store file handles
    var fileInput = $('lecture-upload-input');
    if(fileInput){
      fileInput.addEventListener('change', function(){
        if(!this.files || !this.files.length) return;
        Array.from(this.files).forEach(function(f, idx){
          var url = URL.createObjectURL(f);
          var ext = (f.name.split('.').pop()||'').toUpperCase();
          var meta = ext === 'PDF' ? 'PDF' : (ext==='PPTX'?'PPTX':(ext==='PPT'?'PPT':'FILE'));
          LECTURE_FILES.set(url, f);
          window.window.addResourceEntry ? window.addResourceEntry(f.name, url, meta) : addResourceEntry(f.name, url, meta);
        });
        this.value = '';
      });
    }

    // Patch existing list items (if any static ones exist) to add remove buttons
    if(resourcesList){
      Array.from(resourcesList.querySelectorAll('li')).forEach(function(li){
        if(li.querySelector('.resource-remove')) return;
        var anchor = li.querySelector('a.resources-link');
        if(!anchor) return;
        var nameEl = anchor.querySelector('.resources-title') || anchor;
        var name = nameEl.textContent.trim();
        var url = anchor.getAttribute('data-view') || anchor.getAttribute('href') || '';
        var rm = document.createElement('span');
        rm.className = 'resource-remove';
        rm.title = 'Remove from list';
        rm.textContent = '×';
        rm.addEventListener('click', function(e){
          e.stopPropagation(); e.preventDefault();
          if(LECTURE_FILES.has(url)){ try{ URL.revokeObjectURL(url); }catch(_){ } LECTURE_FILES.delete(url); }
          if(name && $('pdf-title') && $('pdf-title').textContent===name){
            if($('pdf-iframe')) $('pdf-iframe').src='about:blank';
            var ov = $('pptx-overlay'); if(ov) ov.style.display='none';
            $('pdf-title').textContent='—';
          }
          li.remove();
        });
        li.appendChild(rm);
      });
    }
  });
})();
</script>


<script>
(function(){
  function $(id){ return document.getElementById(id); }
  const LECTURE_FILES = (window.__LECTURE_FILES__ = window.__LECTURE_FILES__ || new Map());
  const UNDO_STACK = (window.__LECTURE_UNDO__ = window.__LECTURE_UNDO__ || []);

  function ensureOverlay(){
    const pane = $('pdf-pane');
    if(!pane) return null;
    let ov = $('pptx-overlay');
    if(!ov){
      ov = document.createElement('div');
      ov.id = 'pptx-overlay';
      ov.innerHTML = [
        '<h3>PowerPoint preview not supported in-browser</h3>',
        '<p>This viewer can display PDFs directly. To view a PowerPoint here, please export it as PDF and re-upload.</p>',
        '<p>Tip: In PowerPoint: <em>File → Save As → PDF</em>.</p>'
      ].join('');
      pane.appendChild(ov);
    }
    return ov;
  }

  function createResourceLI(name, url, meta){
    var li = document.createElement('li');
    // selection box
    var sel = document.createElement('span');
    sel.className = 'resource-select';
    li.appendChild(sel);

    var a = document.createElement('a');
    a.href = '#';
    a.className = 'resources-link';
    a.setAttribute('data-view', url);

    var titleSpan = document.createElement('span');
    titleSpan.className = 'resources-title';
    titleSpan.textContent = name;

    var metaSpan = document.createElement('span');
    metaSpan.className = 'resources-meta';
    metaSpan.textContent = meta || 'FILE';

    a.appendChild(titleSpan);
    a.appendChild(metaSpan);
    li.appendChild(a);

    // click handler (normal view)
    a.addEventListener('click', function(ev){
      const resourcesContainer = $('resources-section') || document.body;
      const inSelectMode = resourcesContainer.classList.contains('select-mode');
      if(inSelectMode){
        ev.preventDefault();
        li.classList.toggle('selected');
        updateDeleteButtonVisibility();
        return;
      }
      ev.preventDefault();
      openInViewer(name, url);
    });

    // clicking checkbox area toggles selection in select mode
    sel.addEventListener('click', function(ev){
      ev.preventDefault();
      ev.stopPropagation();
      li.classList.toggle('selected');
      updateDeleteButtonVisibility();
    });

    return li;
  }

  function addResourceEntry(name, url, meta){
    var resourcesList = $('resources-list');
    if(!resourcesList) return null;
    var li = createResourceLI(name, url, meta);
    resourcesList.appendChild(li);
    return li;
  }

  function openInViewer(name, url){
    var viewerBtn = $('viewer-toggle-btn');
    var titleEl = $('pdf-title');
    var iframe = $('pdf-iframe');
    if(viewerBtn) viewerBtn.click();
    if(titleEl) titleEl.textContent = name;

    var ext = (name.split('.').pop()||'').toLowerCase();
    var isPDF = (ext === 'pdf');
    var isPPT = (ext === 'ppt' || ext === 'pptx');

    if(isPDF){
      if(iframe) iframe.src = url;
      var ov = $('pptx-overlay'); if(ov) ov.style.display = 'none';
    }else if(isPPT){
      if(iframe) iframe.src = 'about:blank';
      var ov = ensureOverlay();
      if(ov) ov.style.display = 'block';
    }else{
      if(iframe) iframe.src = 'about:blank';
      var ov = ensureOverlay();
      if(ov){
        ov.innerHTML = '<h3>Preview not available for this file type</h3><p>Please upload a PDF to view here.</p>';
        ov.style.display = 'block';
      }
    }
  }

  function getSelectedLis(){
    var list = $('resources-list');
    if(!list) return [];
    return Array.from(list.querySelectorAll('li.selected'));
  }

  function updateDeleteButtonVisibility(){
    var btn = $('bulk-delete-lectures-btn');
    if(!btn) return;
    var count = getSelectedLis().length;
    btn.style.display = count > 0 ? 'inline-block' : 'none';
    btn.textContent = count > 1 ? 'Delete ('+count+')' : 'Delete';
  }

  function enterSelectMode(){
    var container = $('resources-section') || document.body;
    container.classList.add('select-mode');
    // clear any previous selections
    Array.from(($('resources-list')||document.createElement('ul')).children).forEach(function(li){ li.classList.remove('selected'); });
    updateDeleteButtonVisibility();
  }

  function exitSelectMode(){
    var container = $('resources-section') || document.body;
    container.classList.remove('select-mode');
    Array.from(($('resources-list')||document.createElement('ul')).children).forEach(function(li){ li.classList.remove('selected'); });
    updateDeleteButtonVisibility();
  }

  function deleteSelected(){
    var list = $('resources-list');
    if(!list) return;
    var selected = getSelectedLis();
    if(!selected.length) return;
    // record positions & data for undo
    var snapshot = selected.map(function(li){
      var anchor = li.querySelector('a.resources-link');
      var name = (anchor && (anchor.querySelector('.resources-title')||anchor).textContent.trim()) || '';
      var url = anchor ? (anchor.getAttribute('data-view') || anchor.getAttribute('href') || '') : '';
      var metaEl = anchor ? anchor.querySelector('.resources-meta') : null;
      var meta = metaEl ? metaEl.textContent : 'FILE';
      var idx = Array.prototype.indexOf.call(list.children, li);
      return { name:name, url:url, meta:meta, index:idx };
    });
    // push to undo stack
    UNDO_STACK.push({ type:'delete', items:snapshot });

    // remove from DOM
    selected.forEach(function(li){ li.remove(); });

    // clear viewer if currently showing any of these
    var titleEl = $('pdf-title');
    var showing = titleEl ? titleEl.textContent.trim() : '';
    if(showing && snapshot.some(function(it){ return it.name === showing; })){
      if($('pdf-iframe')) $('pdf-iframe').src = 'about:blank';
      var ov = $('pptx-overlay'); if(ov) ov.style.display = 'none';
      titleEl.textContent = '—';
    }

    updateDeleteButtonVisibility();
  }

  function undo(){
    var action = UNDO_STACK.pop();
    if(!action) return;
    if(action.type === 'delete'){
      var list = $('resources-list');
      if(!list) return;
      // restore in original order by index
      action.items.sort(function(a,b){ return a.index - b.index; }).forEach(function(it){
        var li = createResourceLI(it.name, it.url, it.meta);
        var refNode = list.children[it.index] || null;
        list.insertBefore(li, refNode);
      });
    }
  }

  document.addEventListener('DOMContentLoaded', function(){
    // Remove any stray per-item X buttons from prior versions
    Array.from(document.querySelectorAll('.resource-remove')).forEach(function(el){ el.remove(); });

    // Override global addResourceEntry for new behavior
    window.addResourceEntry = addResourceEntry;

    // Wire up select & delete buttons
    var selectBtn = $('select-lectures-btn');
    var deleteBtn = $('bulk-delete-lectures-btn');
    if(selectBtn){
      selectBtn.addEventListener('click', function(e){
        e.preventDefault();
        var container = $('resources-section') || document.body;
        var selecting = !container.classList.contains('select-mode');
        if(selecting){
          enterSelectMode();
          selectBtn.textContent = 'Done';
        }else{
          exitSelectMode();
          selectBtn.textContent = 'Select';
        }
      });
    }
    if(deleteBtn){
      deleteBtn.addEventListener('click', function(e){
        e.preventDefault();
        deleteSelected();
      });
    }

    // Ctrl+Z to undo
    document.addEventListener('keydown', function(ev){
      if((ev.ctrlKey || ev.metaKey) && (ev.key === 'z' || ev.key === 'Z')){
        ev.preventDefault();
        undo();
      }
    });
  });
})();
</script>


<script>
(function(){
  function $(id){ return document.getElementById(id); }
  const UNDO_STACK = (window.__LECTURE_UNDO__ = window.__LECTURE_UNDO__ || []);

  function updateButtons(){
    var det = $('resources-toggle');
    var selBtn = $('pdfs-select-btn');
    var delBtn = $('pdfs-remove-btn');
    if(!det || !selBtn || !delBtn) return;
    if(det.open){
      selBtn.style.display = 'inline-block';
      // delete only shows when at least one selected
      var count = getSelectedLis().length;
      delBtn.style.display = count > 0 ? 'inline-block' : 'none';
      delBtn.textContent = count>1 ? 'Remove ('+count+')' : 'Remove';
    }else{
      selBtn.style.display = 'none';
      delBtn.style.display = 'none';
    }
  }

  function getSelectedLis(){
    var list = $('resources-list');
    if(!list) return [];
    return Array.from(list.querySelectorAll('li.selected'));
  }

  function toggleSelectMode(force){
    var det = $('resources-toggle');
    if(!det) return;
    var inMode = det.classList.contains('select-mode');
    var should = (typeof force === 'boolean') ? force : !inMode;
    if(should){
      det.classList.add('select-mode');
    }else{
      det.classList.remove('select-mode');
      // clear selections on exit
      var list = $('resources-list');
      if(list){ Array.from(list.children).forEach(li=>li.classList.remove('selected')); }
    }
    var selBtn = $('pdfs-select-btn');
    if(selBtn) selBtn.textContent = det.classList.contains('select-mode') ? 'Done' : 'Select';
    updateButtons();
  }

  function deleteSelected(){
    var list = $('resources-list');
    if(!list) return;
    var selected = getSelectedLis();
    if(!selected.length) return;
    // snapshot for undo
    var snapshot = selected.map(function(li){
      var a = li.querySelector('a.resources-link');
      var name = a ? (a.querySelector('.resources-title')||a).textContent.trim() : '';
      var url = a ? (a.getAttribute('data-view') || a.getAttribute('href') || '') : '';
      var metaEl = a ? a.querySelector('.resources-meta') : null;
      var meta = metaEl ? metaEl.textContent : 'FILE';
      var idx = Array.prototype.indexOf.call(list.children, li);
      return { name:name, url:url, meta:meta, index:idx };
    });
    UNDO_STACK.push({type:'delete', items:snapshot});
    // remove
    selected.forEach(li=>li.remove());
    // clear viewer if showing one removed
    var titleEl = $('pdf-title');
    var current = titleEl ? titleEl.textContent.trim() : '';
    if(current && snapshot.some(it=>it.name===current)){
      var iframe = $('pdf-iframe'); if(iframe) iframe.src='about:blank';
      var ov = $('pptx-overlay'); if(ov) ov.style.display='none';
      titleEl.textContent = '—';
    }
    updateButtons();
  }

  function undo(){
    var action = UNDO_STACK.pop();
    if(!action) return;
    if(action.type === 'delete'){
      var list = $('resources-list');
      if(!list) return;
      action.items.sort((a,b)=>a.index-b.index).forEach(function(it){
        // Recreate LI structure consistent with addResourceEntry in v6
        var li = document.createElement('li');
        var a = document.createElement('a');
        a.href = '#';
        a.className = 'resources-link';
        a.setAttribute('data-view', it.url);
        var titleSpan = document.createElement('span');
        titleSpan.className = 'resources-title';
        titleSpan.textContent = it.name;
        var metaSpan = document.createElement('span');
        metaSpan.className = 'resources-meta';
        metaSpan.textContent = it.meta || 'FILE';
        a.appendChild(titleSpan);
        a.appendChild(metaSpan);
        li.appendChild(a);
        // Click behavior: reuse global handler if defined
        a.addEventListener('click', function(ev){
          // If in select mode, toggle selection
          var det = $('resources-toggle');
          if(det && det.classList.contains('select-mode')){
            ev.preventDefault();
            li.classList.toggle('selected');
            updateButtons();
            return;
          }
          // else delegate to existing click behavior defined elsewhere (v6 script)
        }, true);
        var ref = list.children[it.index] || null;
        list.insertBefore(li, ref);
      });
    }
    updateButtons();
  }

  document.addEventListener('DOMContentLoaded', function(){
    var det = $('resources-toggle');
    var list = $('resources-list');
    var selBtn = $('pdfs-select-btn');
    var delBtn = $('pdfs-remove-btn');

    // Initially hide; will show when details opens
    updateButtons();

    // Toggle shows/hides on opening the details
    if(det){
      det.addEventListener('toggle', updateButtons);
    }

    // Wire select button
    if(selBtn){
      selBtn.addEventListener('click', function(e){
        e.preventDefault();
        toggleSelectMode();
      });
    }

    // Wire delete button
    if(delBtn){
      delBtn.addEventListener('click', function(e){
        e.preventDefault();
        deleteSelected();
      });
    }

    // List click delegation for selection highlighting
    if(list){
      list.addEventListener('click', function(ev){
        var det = $('resources-toggle');
        if(!(det && det.classList.contains('select-mode'))) return;
        // find LI ancestor
        var li = ev.target.closest('li');
        if(!li) return;
        ev.preventDefault();
        li.classList.toggle('selected');
        updateButtons();
      }, true);
    }

    // Ctrl/Cmd + Z for undo
    document.addEventListener('keydown', function(ev){
      if((ev.ctrlKey || ev.metaKey) && (ev.key === 'z' || ev.key === 'Z')){
        ev.preventDefault();
        undo();
      }
    });
  });
})();
</script>


<script>
(function(){
  const details = document.getElementById('resources-toggle');
  const selectBtn = document.getElementById('pdfs-select-btn');
  const removeBtn = document.getElementById('pdfs-remove-btn');
  const list = document.getElementById('resources-list');
  if(!details || !selectBtn || !removeBtn || !list){ return; }

  let selectMode = false;
  const selections = new Set();
  const undoStack = []; // each entry: [{parent, index, node}, ...]

  function ensureDecorations(){
    list.querySelectorAll('li').forEach(li => {
      if(!li.querySelector('.resource-select')){
        const box = document.createElement('span');
        box.className = 'resource-select';
        li.prepend(box);
      }
    });
  }
  ensureDecorations();

  function clearSelections(){
    list.querySelectorAll('li.selected').forEach(li => li.classList.remove('selected'));
    selections.clear();
  }

  function enterSelectMode(){
    selectMode = true;
    details.classList.add('select-mode');
    clearSelections();
    updateButtons();
  }
  function exitSelectMode(){
    selectMode = false;
    details.classList.remove('select-mode');
    clearSelections();
    updateButtons();
  }

  function updateButtons(){
    const open = details.open === true;
    selectBtn.style.display = open ? 'inline-flex' : 'none';
    removeBtn.style.display = (open && selections.size > 0) ? 'inline-flex' : 'none';
  }

  details.addEventListener('toggle', () => {
    if(!details.open){ exitSelectMode(); }
    updateButtons();
  });
  updateButtons();

  selectBtn.addEventListener('click', (e) => {
    e.preventDefault();
    if(selectMode){ exitSelectMode(); } else { enterSelectMode(); }
  });

  list.addEventListener('click', (e) => {
    if(!selectMode) return;
    const li = e.target.closest('li');
    if(!li) return;
    e.preventDefault();
    li.classList.toggle('selected');
    if(li.classList.contains('selected')) selections.add(li);
    else selections.delete(li);
    updateButtons();
  });

  removeBtn.addEventListener('click', (e) => {
    e.preventDefault();
    if(selections.size === 0) return;
    const snapshot = [];
    Array.from(selections).forEach(li => {
      const parent = li.parentNode;
      const index = Array.prototype.indexOf.call(parent.children, li);
      snapshot.push({ parent, index, node: li });
    });
    snapshot.sort((a,b) => a.index - b.index);
    undoStack.push(snapshot);
    Array.from(selections).forEach(li => { li.remove(); });
    selections.clear();
    updateButtons();
  });

  document.addEventListener('keydown', (e) => {
    const isUndo = (e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'Z');
    if(!isUndo) return;
    const last = undoStack.pop();
    if(!last || !last.length) return;
    last.forEach(({parent, index, node}) => {
      const ref = parent.children[index] || null;
      parent.insertBefore(node, ref);
    });
    ensureDecorations();
    updateButtons();
    e.preventDefault();
  });

  const mo = new MutationObserver(() => ensureDecorations());
  mo.observe(list, { childList: true });
})();
</script>


<script>
(function(){
  const details = document.getElementById('resources-toggle');
  const selectBtn = document.getElementById('pdfs-select-btn');
  const removeBtn = document.getElementById('pdfs-remove-btn');
  const list = document.getElementById('resources-list');
  if(!details || !selectBtn || !removeBtn || !list){ return; }

  let selectMode = false;
  const selections = new Set();
  const undoStack = [];

  function ensureDecorations(){
    list.querySelectorAll('li').forEach(li => {
      if(!li.querySelector('.resource-select')){
        const box = document.createElement('span');
        box.className = 'resource-select';
        li.prepend(box);
      }
    });
  }
  ensureDecorations();

  function clearSelections(){
    list.querySelectorAll('li.selected').forEach(li => li.classList.remove('selected'));
    selections.clear();
  }

  function enterSelectMode(){
    selectMode = true;
    details.classList.add('select-mode');
    clearSelections();
    updateButtons();
  }
  function exitSelectMode(){
    selectMode = false;
    details.classList.remove('select-mode');
    clearSelections();
    updateButtons();
  }

  function updateButtons(){
    const open = details.open === true;
    selectBtn.style.display = open ? 'inline-flex' : 'none';
    removeBtn.style.display = (open && selections.size > 0) ? 'inline-flex' : 'none';
  }

  details.addEventListener('toggle', () => {
    if(!details.open){ exitSelectMode(); }
    updateButtons();
  });
  updateButtons();

  // Prevent summary toggle when clicking the action buttons
  ['click','mousedown','mouseup'].forEach(evt => {
    selectBtn.addEventListener(evt, (e)=>{ e.stopPropagation(); if(evt==='click'){ e.preventDefault(); toggleSelectMode(); } }, true);
    removeBtn.addEventListener(evt, (e)=>{ e.stopPropagation(); if(evt==='click'){ e.preventDefault(); handleRemove(); } }, true);
  });

  function toggleSelectMode(){
    if(selectMode){ exitSelectMode(); } else { enterSelectMode(); }
  }

  function handleRemove(){
    if(selections.size === 0) return;
    const snapshot = [];
    Array.from(selections).forEach(li => {
      const parent = li.parentNode;
      const index = Array.prototype.indexOf.call(parent.children, li);
      snapshot.push({ parent, index, node: li });
    });
    snapshot.sort((a,b) => a.index - b.index);
    undoStack.push(snapshot);
    Array.from(selections).forEach(li => { li.remove(); });
    selections.clear();
    updateButtons();
  }

  // In select mode, clicking anywhere on the item OR the blue box toggles selection
  list.addEventListener('click', (e) => {
    if(!selectMode) return;
    const li = e.target.closest('li');
    if(!li) return;
    e.preventDefault();
    li.classList.toggle('selected');
    if(li.classList.contains('selected')) selections.add(li);
    else selections.delete(li);
    updateButtons();
  });

  // Ctrl/Cmd + Z to undo
  document.addEventListener('keydown', (e) => {
    const isUndo = (e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'Z');
    if(!isUndo) return;
    const last = undoStack.pop();
    if(!last || !last.length) return;
    last.forEach(({parent, index, node}) => {
      const ref = parent.children[index] || null;
      parent.insertBefore(node, ref);
    });
    ensureDecorations();
    updateButtons();
    e.preventDefault();
  });

  // Keep decorations for future uploads
  const mo = new MutationObserver(() => ensureDecorations());
  mo.observe(list, { childList: true });
})();
</script>


<script>
(function(){
  const details = document.getElementById('resources-toggle');
  const list = document.getElementById('resources-list');
  const selectBtn = document.getElementById('pdfs-select-btn');
  const removeBtn = document.getElementById('pdfs-remove-btn');
  if(!details || !list || !selectBtn || !removeBtn) return;

  const selections = new Set();
  const undoStack = (window.__LECTURE_UNDO__ = window.__LECTURE_UNDO__ || []);

  function inSelectMode(){ return details.classList.contains('select-mode'); }
  function setSelectMode(on){
    if(on){ details.classList.add('select-mode'); }
    else{ details.classList.remove('select-mode'); selections.clear(); }
    updateButtons();
  }
  function getSelectedCount(){
    return list.querySelectorAll('li.selected').length;
  }
  function updateButtons(){
    const open = details.open === true;
    if(open){
      selectBtn.style.display = 'inline-flex';
      removeBtn.style.display = getSelectedCount() > 0 ? 'inline-flex' : 'none';
    }else{
      selectBtn.style.display = 'none';
      removeBtn.style.display = 'none';
    }
  }

  function ensureBoxes(){
    list.querySelectorAll('li').forEach(li => {
      if(!li.querySelector('.resource-select')){
        const box = document.createElement('span');
        box.className = 'resource-select';
        li.prepend(box);
      }
    });
  }
  ensureBoxes();
  new MutationObserver(ensureBoxes).observe(list, {childList:true, subtree:true});

  function toggleLi(li){
    li.classList.toggle('selected');
    updateButtons();
  }

  // Make Select a mode toggle and force details to stay open
  ['pointerdown','click'].forEach(evt => {
    selectBtn.addEventListener(evt, (e) => {
      e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
      details.open = true; // force stay open
      setSelectMode(!inSelectMode());
    }, true);
  });

  // Remove selected
  ['pointerdown','click'].forEach(evt => {
    removeBtn.addEventListener(evt, (e) => {
      if(!inSelectMode()) return;
      e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
      const snapshot = [];
      list.querySelectorAll('li.selected').forEach(li => {
        const parent = li.parentNode;
        const index = Array.prototype.indexOf.call(parent.children, li);
        snapshot.push({ parent, index, node: li });
      });
      snapshot.sort((a,b) => a.index - b.index);
      undoStack.push(snapshot);
      snapshot.forEach(({node}) => node.remove());
      updateButtons();
    }, true);
  });

  // Global intercept: if in select mode, capture pointerdown/click inside the list
  function intercept(e){
    if (e.type === 'click' && e.button !== undefined && e.button !== 0) return;
    if(!inSelectMode()) return;
    const li = e.target && e.target.closest && e.target.closest('#resources-list li');
    if(!li) return;
    e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
    toggleLi(li);
  }
  // pointerdown disabled to prevent double-toggle on left-click
// document.addEventListener('pointerdown', intercept, true);
  document.addEventListener('click', intercept, true);

  // Undo
  document.addEventListener('keydown', (e) => {
    const isUndo = (e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'Z');
    if(!isUndo) return;
    const last = undoStack.pop();
    if(!last || !last.length) return;
    last.forEach(({parent, index, node}) => {
      const ref = parent.children[index] || null;
      parent.insertBefore(node, ref);
    });
    ensureBoxes();
    updateButtons();
    e.preventDefault();
  });

  // Keep buttons in sync with details open/close
  details.addEventListener('toggle', () => {
    if(!details.open){ setSelectMode(false); }
    updateButtons();
  });

  // Initial
  updateButtons();
})();
</script>


<!-- Patch: Keep Lecture PDFs panel open on first "Select" click -->
<script>
(function(){
  try {
    function closest(el, sel){
      while (el && el.nodeType === 1) { if (el.matches(sel)) return el; el = el.parentElement; }
      return null;
    }
    function text(el){
      return (el && (el.textContent || el.innerText) || "").trim().toLowerCase();
    }
    function isSelectControl(el){
      if (!el) return false;
      // Common patterns
      if (el.matches && el.matches('#pdfs-select-btn, [data-select], [data-role="select"], .btn-select, .select-button')) return true;
      const label = text(el);
      if (label === 'select' || label.startsWith('select ')) return true;
      return false;
    }
    function isLecturePDFsSummary(summary){
      if (!summary) return false;
      const t = text(summary);
      if (t.includes('lecture') && t.includes('pdf')) return true;
      // fallback: parent details has id/class hint
      const d = closest(summary, 'details');
      if (!d) return false;
      const idc = ((d.id||"") + " " + (d.className||"")).toLowerCase();
      return /pdf/.test(idc) && /lecture/.test(idc);
    }

    function guardEvent(e){
      const target = e.target;
      const summary = closest(target, 'summary');
      if (!summary) return;
      if (!isLecturePDFsSummary(summary)) return;

      // If the click originated on an element that *behaves* like Select, prevent default toggle
      let btn = target;
      if (!isSelectControl(btn)) btn = closest(target, 'button,[role="button"],a');
      if (!isSelectControl(btn)) return;

      // Prevent the <summary> default toggle (which would close the panel)
      e.preventDefault();
      e.stopPropagation();

      const details = closest(summary, 'details');
      if (details) {
        // Force-open and mark select-mode immediately
        details.open = true;
        details.classList.add('select-mode');

        // If your app listens for a mode event, emit one
        try {
          details.dispatchEvent(new CustomEvent('enter-select-mode', { bubbles: true }));
        } catch(_) {}

        // Double-ensure open after the event loop
        setTimeout(function(){
          try { if (!details.open) details.open = true; } catch(_){}
        }, 0);
      }
    }

    // Capture-phase listeners so we intercept before <summary> toggles.
    ['pointerdown','mousedown','click'].forEach(function(type){
      document.addEventListener(type, guardEvent, true);
    });

  } catch (err) {
    try { console.warn('Lecture PDFs Select first-click patch error:', err); } catch(_){}
  }
})();
</script>

<!-- === Robust Select/Remove behavior + persistent deletions === -->
<style>
  /* Visual cue when in remove mode */
  details.remove-mode { outline: 2px dashed #e11d48; outline-offset: 4px; }
  details.remove-mode summary { background: rgba(225,29,72,.08); }
  details.remove-mode a, details.remove-mode li, details.remove-mode [role="button"] { cursor: not-allowed !important; }
</style>
<script>
(function(){
  'use strict';

  // ---------- Utilities ----------
  function closest(el, sel){
    while (el && el.nodeType === 1){
      if (el.matches(sel)) return el;
      el = el.parentElement;
    }
    return null;
  }
  function normText(el){
    return (el && (el.textContent || el.innerText) || '').replace(/\s+/g,' ').trim();
  }
  function norm(s){ return (s||'').replace(/\s+/g,' ').trim().toLowerCase(); }

  function findLecturePDFsDetails(){
    var all = document.querySelectorAll('details');
    for (var i=0;i<all.length;i++){
      var d = all[i];
      var sum = d.querySelector(':scope > summary');
      if (!sum) continue;
      var t = norm(sum);
      if (t.includes('lecture') && t.includes('pdf')) return d;
      // fallbacks via id/class hints
      var idc = norm((d.id||'') + ' ' + (d.className||''));
      if (idc.includes('lecture') && idc.includes('pdf')) return d;
    }
    return null;
  }

  function findControl(summary, label){
    // Prefer explicit controls
    var sel = summary.querySelector('[data-role="'+label+'"], [data-'+label+'], .btn-'+label+', #pdfs-'+label+'-btn, [aria-controls*="'+label+'"]');
    if (sel) return sel;
    // Generic interactive candidates
    var candidates = summary.querySelectorAll('button,[role="button"],a,[data-action]');
    label = norm(label);
    for (var i=0;i<candidates.length;i++){
      var c = candidates[i];
      var t = norm(c.getAttribute('aria-label') || c.getAttribute('data-action') || c.textContent || '');
      var idc = norm((c.id||'') + ' ' + (c.className||''));
      if (t.startsWith(label) || t === label || idc.includes(label)) return c;
    }
    return null;
  }

  function isLectureItem(node){
    if (!node || !node.matches) return false;
    if (node.matches('[data-lecture], .lecture-item, li.lecture, a.resources-link')) return true;
    if (node.matches('a[href$=".pdf"], a[href$=".ppt"], a[href$=".pptx"]')) return true;
    if (node.matches('li, a, button, [role="button"]')) {
      var t = normText(node).toLowerCase();
      if (t.includes('lecture') || /\.pdf\b/.test(t) || /\.pptx?\b/.test(t)) return true;
    }
    return false;
  }

  function keyForItem(el){
    if (!el) return '';
    // Prefer explicit stable IDs or data-id
    var id = el.getAttribute && (el.getAttribute('data-id') || el.id);
    if (id) return 'id:'+id;
    // Prefer anchor hrefs
    var a = el.closest && (el.closest('a[href]') || (el.tagName === 'A' ? el : null));
    if (a && a.getAttribute('href')) return 'href:'+a.getAttribute('href');
    // data-name as fallback
    var nm = el.getAttribute && el.getAttribute('data-name');
    if (nm) return 'name:'+nm;
    // Last resort: text hash-ish
    return 'text:'+normText(el).toLowerCase().slice(0,200);
  }

  function loadRemoved(){
    try { return new Set(JSON.parse(localStorage.getItem('lecture_pdfs_removed_v2') || '[]')); }
    catch(_) { return new Set(); }
  }
  function saveRemoved(set){
    try { localStorage.setItem('lecture_pdfs_removed_v2', JSON.stringify(Array.from(set))); } catch(_){}
  }

  // ---------- Main bindings ----------
  var details = findLecturePDFsDetails();
  if (!details) return;
  var summary = details.querySelector(':scope > summary');
  var selectBtn = findControl(summary, 'select');
  var removeBtn = findControl(summary, 'remove');

  var removedSet = loadRemoved();

  function applyPersistentRemovals(root){
    var scope = root || details;
    var items = scope.querySelectorAll('a.resources-link, [data-lecture], .lecture-item, li, a');
    for (var i=0;i<items.length;i++){
      var el = items[i];
      if (!isLectureItem(el)) continue;
      var key = keyForItem(el);
      if (key && removedSet.has(key)) {
        el.remove();
      }
    }
  }

  // On load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function(){ applyPersistentRemovals(); });
  } else {
    applyPersistentRemovals();
  }

  // Observe for new items (uploads) => filter removed + optionally auto-collapse
  if (window.MutationObserver){
    var mo = new MutationObserver(function(recs){
      var added = false;
      recs.forEach(function(r){
        if (r.addedNodes && r.addedNodes.length) added = true;
      });
      if (added){
        applyPersistentRemovals();
        // Auto-collapse after upload/add (but not while in remove mode)
        if (!isRemoveMode()){
          setTimeout(function(){ details.open = false; }, 100);
        }
      }
    });
    mo.observe(details, { childList: true, subtree: true });
  }

  // Guard summary auto-toggle when clicking select/remove controls
  function guard(e){
    var t = e.target;
    var inSelect = selectBtn && (t === selectBtn || t.closest && t.closest(selectBtn.tagName) === selectBtn);
    var inRemove = removeBtn && (t === removeBtn || t.closest && t.closest(removeBtn.tagName) === removeBtn);
    if (inSelect || inRemove){
      e.preventDefault(); e.stopPropagation();
    }
  }
  if (summary){
    ['pointerdown','mousedown','click'].forEach(function(type){
      summary.addEventListener(type, guard, true);
    });
  }

  // ---- Select toggle behavior ----
  function enterSelectMode(){
    details.open = true;
    details.classList.add('select-mode');
    details.dataset.selectMode = '1';
    setTimeout(function(){ if (!details.open) details.open = true; }, 0);
  }
  function exitSelectModeAndClose(){
    details.classList.remove('select-mode');
    details.dataset.selectMode = '';
    details.open = false;
  }
  function inSelectMode(){ return details.dataset.selectMode === '1'; }

  if (selectBtn){
    ['pointerdown','mousedown','click'].forEach(function(type){
      selectBtn.addEventListener(type, function(e){ e.preventDefault(); e.stopPropagation(); }, true);
    });
    selectBtn.addEventListener('click', function(){
      // If remove mode is on, turn it off before toggling select behavior
      if (isRemoveMode()) exitRemoveMode();
      if (!inSelectMode()) enterSelectMode(); else exitSelectModeAndClose();
    });
  }

  details.addEventListener('click', function(e){
    // Auto-collapse after clicking a lecture to load (only when NOT in remove mode)
    if (isRemoveMode()) return;
    if (e.target && e.target.closest('summary')) return;
    var item = e.target && e.target.closest('a, li, [data-lecture], .lecture-item, [role="button"]');
    if (!item || !isLectureItem(item)) return;
    setTimeout(function(){ details.open = false; }, 180);
  }, true);

  // ---- Remove mode behavior ----
  function enterRemoveMode(){
    details.open = true;
    details.classList.add('remove-mode');
    details.dataset.removeMode = '1';
    if (removeBtn) removeBtn.setAttribute('aria-pressed','true');
  }
  function exitRemoveMode(){
    details.classList.remove('remove-mode');
    details.dataset.removeMode = '';
    if (removeBtn) removeBtn.setAttribute('aria-pressed','false');
  }
  function isRemoveMode(){ return details.dataset.removeMode === '1'; }

  if (removeBtn){
    ['pointerdown','mousedown','click'].forEach(function(type){
      removeBtn.addEventListener(type, function(e){ e.preventDefault(); e.stopPropagation(); }, true);
    });
    removeBtn.addEventListener('click', function(){
      if (!isRemoveMode()) enterRemoveMode(); else exitRemoveMode();
    });
  } else {
    // Failsafe: bind a document-level handler for any element labeled "Remove" in the summary
    document.addEventListener('click', function(e){
      var t = e.target;
      if (!summary || !summary.contains(t)) return;
      var label = norm(t.getAttribute('aria-label') || t.textContent || '');
      if (label !== 'remove') return;
      e.preventDefault(); e.stopPropagation();
      if (!isRemoveMode()) enterRemoveMode(); else exitRemoveMode();
    }, true);
  }

  // While in remove mode, clicking a lecture removes it immediately + persists
  details.addEventListener('click', function(e){
    if (!isRemoveMode()) return;
    if (e.target && e.target.closest('summary')) return;
    var item = e.target && e.target.closest('a, li, [data-lecture], .lecture-item, [role="button"]');
    if (!item || !isLectureItem(item)) return;
    e.preventDefault(); e.stopPropagation(); if (e.stopImmediatePropagation) e.stopImmediatePropagation();
    var key = keyForItem(item);
    if (key){ removedSet.add(key); saveRemoved(removedSet); }
    item.remove();
  }, true);

  // Keyboard support for removal (Enter/Space on focused item)
  details.addEventListener('keydown', function(e){
    if (!isRemoveMode()) return;
    var k = e.key || e.code;
    if (k === 'Enter' || k === ' ' || k === 'Spacebar'){
      var a = document.activeElement;
      if (a && isLectureItem(a)){
        e.preventDefault(); e.stopPropagation();
        var key = keyForItem(a);
        if (key){ removedSet.add(key); saveRemoved(removedSet); }
        a.remove();
      }
    }
  }, true);
})();
</script>

<!-- Minimal persistence + auto-collapse on upload -->
<script>
(function(){
  'use strict';
  var details = document.getElementById('resources-toggle');
  var list = document.getElementById('resources-list');
  var upload = document.getElementById('lecture-upload-input');
  var STORAGE = 'lecture_pdfs_list_html_v2';

  if (!list) return;

  function saveList(){
    try {
      localStorage.setItem(STORAGE, list.innerHTML);
    } catch(e) {}
  }

  function restoreList(){
    try {
      var html = localStorage.getItem(STORAGE);
      if (html && html.trim()){
        // Replace list items with the saved version (preserves order + deletions + additions)
        list.innerHTML = html;
      } else {
        // First-run baseline
        saveList();
      }
    } catch(e) {}
  }

  // Restore once DOM is ready
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', restoreList, { once: true });
  } else {
    restoreList();
  }

  // Persist whenever items are added/removed under the list
  if (window.MutationObserver){
    var mo = new MutationObserver(function(records){
      for (var i=0;i<records.length;i++){
        var r = records[i];
        if ((r.addedNodes && r.addedNodes.length) || (r.removedNodes && r.removedNodes.length)){
          // Let DOM settle briefly, then snapshot
          setTimeout(saveList, 50);
          break;
        }
      }
    });
    mo.observe(list, { childList: true });
  }

  // Also snapshot after clicks that trigger delete handlers elsewhere
  list.addEventListener('click', function(){
    setTimeout(saveList, 60);
  }, true);

  // Auto-collapse the Lecture PDFs tab after choosing files to upload
  if (upload && details){
    upload.addEventListener('change', function(){
      // Give any upload handler a beat to insert new items, then close
      setTimeout(function(){ try{ details.open = false; }catch(e){} }, 120);
    });
  }
})();
</script>

<script>
(function(){
  const SELS = {
    details: 'details#resources-toggle, details[data-section="lectures"], details.lectures, details#lecture-pdfs, details.lecture-pdfs',
    list: '#resources-list, ul#lecture-list, ul.resources',
    selectBtn: '#pdfs-select-btn, #select-lectures-btn, button[data-action="select-lectures"], .select-lectures-btn',
    deleteBtn: '#pdfs-remove-btn, #bulk-delete-lectures-btn, button[data-action="delete-lectures"], .delete-lectures-btn',
    viewerIframe: '#pdf-iframe, #viewer-iframe, #doc-iframe, .viewer iframe',
    viewerTitle: '#pdf-title, #viewer-title, .viewer-title',
    resourcesLink: 'a.resources-link, a.lecture-link'
  };

  function qs(sel){ return document.querySelector(sel); }
  function qsf(key){ return qs(SELS[key]); }

  const details = qsf('details');
  const list = qsf('list');
  const selectBtn = qsf('selectBtn');
  const deleteBtn = qsf('deleteBtn');
  const iframe = qsf('viewerIframe');
  const titleEl = qsf('viewerTitle');

  if(!details || !list || !selectBtn){ return; }

  // ---------- Select-mode state ----------
  let SELECT_MODE = false; // fallback if CSS class host is absent
  function inSelect(){
    if(details) return details.classList.contains('select-mode');
    return SELECT_MODE;
  }
  function setSelect(on){
    if(details){
      details.classList.toggle('select-mode', !!on);
      // make sure panel is open when entering select
      if(on && !details.open){ details.open = true; }
    }else{
      SELECT_MODE = !!on;
    }
    if(!on){
      // clear any selected rows and hide delete
      list.querySelectorAll('li.selected').forEach(li => li.classList.remove('selected'));
      if(deleteBtn) deleteBtn.style.display = 'none';
    }else{
      // show/hide delete based on selection count
      updateDeleteVisibility();
    }
  }
  function toggleSelect(){ setSelect(!inSelect()); }

  function updateDeleteVisibility(){
    if(!deleteBtn) return;
    const count = list.querySelectorAll('li.selected').length;
    deleteBtn.style.display = inSelect() && count > 0 ? 'inline-flex' : 'none';
  }

  // ---------- Make Select a true toggle (replace node to drop old handlers) ----------
  try {
    const clone = selectBtn.cloneNode(true);
    selectBtn.parentNode.replaceChild(clone, selectBtn);
    clone.addEventListener('click', function(e){
      e.preventDefault(); e.stopPropagation();
      toggleSelect();
    }, true);
  } catch(_) {
    // fallback if cloning fails
    selectBtn.addEventListener('click', function(e){
      e.preventDefault(); e.stopPropagation();
      toggleSelect();
    }, true);
  }

  // ---------- Click outside lectures exits select mode (document-capture, robust) ----------
  document.addEventListener('click', function(e){
    if(!inSelect()) return;
    // If click is inside the lectures/details area or on select/delete buttons, ignore.
    if(e.target.closest(SELS.details) ||
       e.target.closest(SELS.list) ||
       e.target.closest(SELS.selectBtn) ||
       e.target.closest(SELS.deleteBtn)){
      return;
    }
    // Anywhere else cancels selection (this includes the dark blue question box area).
    setSelect(false);
  }, true); // capture to beat other stopPropagation

  // ---------- List click behavior ----------
  list.addEventListener('click', function(e){
    const a = e.target.closest(SELS.resourcesLink);
    const li = e.target.closest('li');
    if(!a && !li) return;

    if(inSelect()){
      // Selection mode: toggle visual selection, don't open viewer
      e.preventDefault(); e.stopPropagation();
      if(li) li.classList.toggle('selected');
      updateDeleteVisibility();
      return;
    }

    // Normal mode: open in viewer
    if(a){
      e.preventDefault(); e.stopPropagation();
      const url = a.getAttribute('data-view') || a.getAttribute('href') || '';
      if(!url) return;
      if(titleEl){
        const t = a.querySelector('.resources-title');
        titleEl.textContent = t ? t.textContent.trim() : 'Lecture Viewer';
      }
      const iframeEl = qsf('viewerIframe');
      if(iframeEl){ iframeEl.src = url; }
      if(details) details.open = false;
      const work = document.getElementById('work-area') || document.querySelector('.work-area');
      if(work) work.classList.add('viewer-open');
    }
  }, true);

  // Closing the details while in select mode should exit it
  details.addEventListener('toggle', function(){
    if(!details.open) setSelect(false);
  });

  // ---------- Persistence (localStorage) ----------
  const STORAGE_KEY = 'lectures_list_v1';

  function inferMetaFromUrl(url){
    if(/\.pdf(\?|$)/i.test(url)) return 'PDF';
    if(/\.(pptx?|ppsx?)(\?|$)/i.test(url)) return 'PPTX';
    return 'File';
  }

  function serializeList(){
    const out = [];
    list.querySelectorAll('li').forEach(li => {
      const a = li.querySelector(SELS.resourcesLink);
      if(!a) return;
      const url = a.getAttribute('data-view') || a.getAttribute('href') || '';
      const titleNode = a.querySelector('.resources-title');
      const title = titleNode ? titleNode.textContent.trim() : (a.textContent || '').trim();
      out.push({ title, url, meta: inferMetaFromUrl(url) });
    });
    return out;
  }

  function renderList(items){
    // Clear list safely
    while(list.firstChild) list.removeChild(list.firstChild);
    (items || []).forEach(it => {
      const li = document.createElement('li');
      const a = document.createElement('a');
      a.className = 'resources-link';
      if(it.url) a.href = it.url;
      a.setAttribute('data-view', it.url || '');
      const t = document.createElement('span');
      t.className = 'resources-title';
      t.textContent = it.title || (it.url ? (it.url.split('/').pop() || 'Lecture') : 'Lecture');
      const m = document.createElement('span');
      m.className = 'resources-meta';
      m.textContent = it.meta || inferMetaFromUrl(it.url || '');
      a.appendChild(t); a.appendChild(m);
      li.appendChild(a);
      list.appendChild(li);
    });
  }

  function saveList(){
    try{
      const data = serializeList();
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      // Presence flag not strictly needed, but harmless
      localStorage.setItem(STORAGE_KEY + '_present', '1');
    }catch(_){}
  }

  function loadList(){
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw === null) return null;
    try{
      return JSON.parse(raw);
    }catch(_){
      return null;
    }
  }

  // Rehydrate after page scripts finish (avoid fighting initial seeding)
  window.addEventListener('load', function(){
    const stored = loadList();
    if(stored){
      renderList(stored);
    }else if(stored && Array.isArray(stored) && stored.length === 0){
      // Explicit empty list should still clear any seeded items
      renderList([]);
    }else{
      // No stored list yet; initialize from current DOM so subsequent deletes persist.
      saveList();
    }
  });

  // Persist on any list changes (including when you delete ALL items)
  const mo = new MutationObserver(function(){
    saveList();
  });
  mo.observe(list, { childList: true, subtree: false });

  // Also persist when the delete button is used (in case DOM mutations are batched)
  if(deleteBtn){
    deleteBtn.addEventListener('click', function(){
      // Give existing delete logic time to modify DOM, then save
      setTimeout(saveList, 50);
    }, true);
  }
})();
</script>

<script>
/*** === PPTX viewer integration (Google Docs / Office Online) === ***/
(function(){
  "use strict";
  const $ = (id) => document.getElementById(id);
  const workArea = $("work-area");
  const pdfIframe = $("pdf-iframe");
  const pdfTitle  = $("pdf-title");
  const uploadInp = $("lecture-upload-input");
  const resourcesList = $("resources-list");

  // Choose your default: "google" or "office"
  const PPTX_VIEWER = "office";

  function ensureViewerOpen(){
    try{
      if (workArea && !workArea.classList.contains("viewer-open")) {
        workArea.classList.add("viewer-open");
      }
    }catch(e){}
  }

  function fileExtFromName(name=""){
    const m = String(name).toLowerCase().match(/\.([a-z0-9]+)(?:\?.*)?$/);
    return m ? m[1] : "";
  }

  function isHttpUrl(u){ return /^https?:\/\//i.test(String(u||"")); }

  function googleEmbed(url){
    return "https://docs.google.com/gview?embedded=1&url=" + encodeURIComponent(url);
  }
  function officeEmbed(url){
    return "https://view.officeapps.live.com/op/embed.aspx?src=" + encodeURIComponent(url);
  }

  function embedFor(url, ext){
    try{
      if (ext === "pdf") return url; // native PDF in iframe
      if (ext === "ppt" || ext === "pptx") {
        return (PPTX_VIEWER === "google") ? googleEmbed(url) : officeEmbed(url);
      }
      return url;
    }catch(e){ return url; }
  }

  function loadInViewer(url, title, ext){
    ensureViewerOpen();
    try{ if (pdfTitle) pdfTitle.textContent = title || "Lecture Viewer"; }catch(e){}
    try{ if (pdfIframe) pdfIframe.src = embedFor(url, ext); }catch(e){}
  }

  // Create an overlay prompting for a public URL when local PPTX is selected
  function ensurePptxOverlay(){
    let ov = document.getElementById("pptx-overlay");
    if (!ov){
      ov = document.createElement("div");
      ov.id = "pptx-overlay";
      ov.style.display = "none";
      ov.style.position = "absolute";
      ov.style.inset = "46px 10px 10px 10px";
      ov.style.background = "rgba(20,20,20,0.85)";
      ov.style.color = "#fff";
      ov.style.padding = "18px";
      ov.style.borderRadius = "8px";
      ov.style.overflow = "auto";
      ov.innerHTML = [
        '<h3 style="margin:0 0 8px 0;font-size:1.05rem">PPT/PPTX requires a public link</h3>',
        '<p style="margin:0 0 8px 0;font-size:.95rem">Paste a public URL (Google Drive, OneDrive/SharePoint, or Dropbox direct link) to view here.</p>',
        '<input id="pptx-url" type="url" placeholder="https://..." ',
        'style="width:100%;padding:.5rem;border-radius:6px;border:1px solid rgba(255,255,255,.22);background:#0f172a;color:#e5e7eb;margin-bottom:.5rem">',
        '<div style="display:flex;gap:.5rem;flex-wrap:wrap">',
          '<button id="pptx-use-google" style="padding:.35rem .6rem;border-radius:8px;border:1px solid rgba(255,255,255,.2);background:rgba(255,255,255,.06);cursor:pointer">Use Google Viewer</button>',
          '<button id="pptx-use-office" style="padding:.35rem .6rem;border-radius:8px;border:1px solid rgba(255,255,255,.2);background:rgba(255,255,255,.06);cursor:pointer">Use Office Viewer</button>',
          '<button id="pptx-cancel" style="margin-left:auto;padding:.35rem .6rem;border-radius:8px;border:1px solid rgba(255,255,255,.2);background:rgba(255,255,255,.06);cursor:pointer">Cancel</button>',
        '</div>'
      ].join("");

      const pdfPane = document.getElementById("pdf-pane") || document.body;
      pdfPane.appendChild(ov);

      const urlInput = ov.querySelector("#pptx-url");
      const useGoogle = ov.querySelector("#pptx-use-google");
      const useOffice = ov.querySelector("#pptx-use-office");
      const cancelBtn = ov.querySelector("#pptx-cancel");

      function useLink(viewer){
        const link = (urlInput && urlInput.value || "").trim();
        if (!isHttpUrl(link)) return;
        const src = (viewer === "google") ? googleEmbed(link) : officeEmbed(link);
        loadInViewer(src, "PPTX", "pptx");
        ov.style.display = "none";
      }
      if (useGoogle) useGoogle.addEventListener("click", ()=>useLink("google"));
      if (useOffice) useOffice.addEventListener("click", ()=>useLink("office"));
      if (cancelBtn) cancelBtn.addEventListener("click", ()=>{ ov.style.display = "none"; });
    }
    return ov;
  }

  // Hook file uploads
  if (uploadInp){
    uploadInp.addEventListener("change", (e)=>{
      try{
        const files = Array.from(e.target.files || []);
        for (const f of files){
          const ext = fileExtFromName(f.name);
          if (ext === "pdf"){
            const url = URL.createObjectURL(f);
            loadInViewer(url, f.name, "pdf");
          } else if (ext === "ppt" || ext === "pptx"){
            // Local PPTX cannot be embedded directly; prompt for public link
            const ov = ensurePptxOverlay();
            ov.style.display = "block";
          } else {
            // ignore other types
          }
        }
      }catch(err){ console.error(err); }
      // allow reselecting the same file
      try{ uploadInp.value = ""; }catch(_){}
    });
  }

  // Hook clicks in Lecture list: if it's an http(s) PPTX, embed directly; if local, prompt
  if (resourcesList){
    resourcesList.addEventListener("click", (e)=>{
      const a = e.target && e.target.closest && e.target.closest("a.resources-link");
      if (!a) return;
      e.preventDefault();
      const src = a.getAttribute("data-view") || a.getAttribute("href") || "";
      const ext = fileExtFromName(src);
      const title = (a.textContent || "Lecture").trim();
      if ((ext === "ppt" || ext === "pptx")){
        if (isHttpUrl(src)){
          // Direct http(s) link -> embed with chosen viewer
          const finalSrc = (PPTX_VIEWER === "google") ? googleEmbed(src) : officeEmbed(src);
          loadInViewer(finalSrc, title, ext);
        } else {
          // Non-http source -> prompt overlay
          const ov = ensurePptxOverlay();
          ov.style.display = "block";
        }
      } else if (ext === "pdf"){
        loadInViewer(src, title, "pdf");
      } else {
        // fallback try (unknown ext)
        loadInViewer(src, title, ext);
      }
    });
  }
})();
</script>
<script>
(function(){
  function nukeOverlay(){
    var el = document.getElementById('pptx-overlay');
    if (el && el.parentNode){ try{ el.parentNode.removeChild(el); }catch(e){} }
  }
  // Run now and keep watching
  try{ nukeOverlay(); }catch(e){}
  try{
    var mo = new MutationObserver(function(){ nukeOverlay(); });
    mo.observe(document.documentElement || document.body, { childList:true, subtree:true });
  }catch(e){}
  // Also hide on common interactions
  document.addEventListener('click', nukeOverlay, true);
  document.addEventListener('change', nukeOverlay, true);
  document.addEventListener('keyup', nukeOverlay, true);
})();
</script>

<!-- === Local PPTX→PDF integration (Exact mode default) === -->
<style>#pptx-overlay{display:none!important;visibility:hidden!important;pointer-events:none!important;}
/* PATCH: Welcome page overlay */
#welcome-overlay{
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.50);
  z-index: 10010;
}
#welcome-card{
  background: #1f2937;
  border: 2px solid #374151;
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.45);
  width: min(92vw, 780px);
  padding: 1.2rem 1.25rem 1rem;
  color: #e2e8f0;
  text-align: center;
}
#welcome-card h2{
  margin: 0 0 .35rem 0;
  font-size: 1.6rem;
  background-image: var(--g);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  color: transparent;
}
#welcome-card p{ margin:.25rem 0 .75rem 0; opacity:.9; }
.welcome-actions{
  display: inline-flex;
  gap: .6rem;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center;
  margin-top: .5rem;
}
.welcome-actions button{
  padding: .55rem .9rem;
  border-radius: 10px;
  border: 1px solid var(--bd);
  background: var(--bg);
  background-image: var(--g);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  color: transparent;
  cursor: pointer;
}


/* PATCH: Welcome visual refresh */
#welcome-overlay{
  /* full-screen themed background */
  background:
    radial-gradient(1200px 800px at 20% 20%, rgba(96,165,250,0.12), transparent 60%),
    radial-gradient(1000px 700px at 80% 70%, rgba(244,114,182,0.10), transparent 60%),
    linear-gradient(135deg, rgba(15,23,42,0.96), rgba(2,6,23,0.98));
}
#welcome-overlay::before{
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: .14;
  /* subtle grid sheen matching the UI */
  background:
    repeating-linear-gradient(to bottom, rgba(255,255,255,0.05), rgba(255,255,255,0.05) 1px, transparent 1px, transparent 14px),
    repeating-linear-gradient(to right,  rgba(255,255,255,0.05), rgba(255,255,255,0.05) 1px, transparent 1px, transparent 14px);
  mix-blend-mode: screen;
}
#welcome-card{
  /* keep same palette but add a soft glow */
  box-shadow: 0 14px 40px rgba(0,0,0,0.55), 0 0 0 1px rgba(55,65,81,0.55);
}

</style>
<script>
(function(){
  "use strict";
  const CONVERT_URL = "http://127.0.0.1:8000/convert?mode=imagepdf";
  const $ = (id) => document.getElementById(id);

  function ensureViewerOpen(){
    const wa = $("work-area");
    if (wa && !wa.classList.contains("viewer-open")) wa.classList.add("viewer-open");
  }
  function setViewer(title, url){
    ensureViewerOpen();
    const t = $("pdf-title");
    const f = $("pdf-iframe");
    if (t) t.textContent = title || "Lecture Viewer";
    if (f) f.src = url;
  }

  // === IndexedDB persistence ===
  const DB_NAME = "quizViewerDB";
  const DB_STORE = "resources";
  function openDB(){
    return new Promise((resolve,reject)=>{
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = (e)=>{
        const db = req.result;
        if (!db.objectStoreNames.contains(DB_STORE)){
          const store = db.createObjectStore(DB_STORE, { keyPath: "id" });
          store.createIndex("createdAt", "createdAt", { unique: false });
        }
      };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }
  async function saveResource(rec){
    try{
      const db = await openDB();
      await new Promise((resolve,reject)=>{
        const tx = db.transaction(DB_STORE, "readwrite");
        tx.objectStore(DB_STORE).put(rec);
        tx.oncomplete = resolve;
        tx.onerror = ()=> reject(tx.error);
      });
      addResourceListItem(rec);
    }catch(err){
      console.warn("Persist failed", err);
    }
  }
  async function getAllResources(){
    const db = await openDB();
    return await new Promise((resolve,reject)=>{
      const tx = db.transaction(DB_STORE, "readonly");
      const store = tx.objectStore(DB_STORE);
      const req = store.getAll();
      req.onsuccess = ()=> resolve(req.result || []);
      req.onerror = ()=> reject(req.error);
    });
  }
  function addResourceListItem(rec){
    const list = $("resources-list");
    if (!list) return;
    const li = document.createElement("li");
    const a = document.createElement("a");
    a.className = "resources-link";
    a.href = "#";
    a.setAttribute("data-view", rec.objectUrl);
    a.innerHTML = '<span class="resources-title"></span><span class="resources-meta">PDF</span>';
    li.appendChild(a);
    list.prepend(li);
    const tt = a.querySelector(".resources-title");
    if (tt) tt.textContent = rec.title || rec.filename || "PDF";
    a.addEventListener("click", (e)=>{ e.preventDefault(); setViewer(rec.title || rec.filename, rec.objectUrl); });
  }
  async function restoreResources(){
    try{
      if (navigator.storage && navigator.storage.persist){
        try { await navigator.storage.persist(); } catch(_){}
      }
      const items = await getAllResources();
      items.sort((a,b)=> (b.createdAt||0) - (a.createdAt||0));
      for (const rec of items){
        try{
          if (!rec.objectUrl){
            rec.objectUrl = URL.createObjectURL(new Blob([rec.blob], { type: rec.mime || "application/pdf" }));
          }
          addResourceListItem(rec);
        }catch(err){
          console.warn("Failed to restore item", err);
        }
      }
    }catch(err){
      console.warn("restoreResources error", err);
    }
  }
  document.addEventListener("DOMContentLoaded", restoreResources, { once: true });  function addResource(title, url){
    const list = $("resources-list");
    if (!list) return;
    const li = document.createElement("li");
    const a = document.createElement("a");
    a.className = "resources-link";
    a.href = "#";
    a.setAttribute("data-view", url);
    a.innerHTML = '<span class="resources-title"></span><span class="resources-meta">PDF</span>';
    li.appendChild(a);
    list.prepend(li);
    const tt = a.querySelector(".resources-title");
    if (tt) tt.textContent = title;
    a.addEventListener("click", (e)=>{ e.preventDefault(); setViewer(title, url); });
  }
  function fileExt(name=""){
    const m = String(name).toLowerCase().match(/\.([a-z0-9]+)(?:\?.*)?$/);
    return m ? m[1] : "";
  }
  async function convertPptx(file){
    const form = new FormData();
    form.append("file", file, file.name);
    const res = await fetch(CONVERT_URL, { method: "POST", body: form });
    if (!res.ok){
      const msg = await res.text();
      throw new Error(msg || "Conversion failed");
    }
    const backend = res.headers.get("X-Converter-Backend") || "";
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    const badge = $("backend-badge");
    if (badge) badge.textContent = backend ? ("Converted via: " + backend) : "";
    return url;
  }

  function wire(){
    const btn = $("upload-lectures-btn");
    const input = $("lecture-upload-input");
    if (!btn || !input) return;

    // Capture-phase change listener to pre-empt old handlers
    document.addEventListener("change", async (e)=>{
      if (e.target !== input) return;
      try{
        const files = Array.from(input.files || []);
        if (!files.length) return;
        for (const f of files){
          const ext = fileExt(f.name);
          if (ext === "pdf"){
            const url = URL.createObjectURL(f);
            addResource(f.name, url);
            setViewer(f.name, url);
          } else if (ext === "ppt" || ext === "pptx"){
            const url = await convertPptx(f);
            const title = (f.name || "PPTX").replace(/\.(pptx|ppt)$/i, ".pdf");
            addResource(title, url);
            setViewer(title, url);
          }
        }
      } catch(err){
        alert("Upload error: " + (err && err.message ? err.message : String(err)));
      } finally {
        try{ input.value = ""; }catch(_){}
      }
      e.stopImmediatePropagation();
      e.preventDefault();
      return false;
    }, { capture: true });

    // Open file chooser
    btn.addEventListener("click", ()=> input && input.click(), { capture: true });
  }

  if (document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", wire);
  } else {
    wire();
  }
})();
</script>

<script>
(function(){
  "use strict";
  const $ = (id) => document.getElementById(id);

  // If present, hide and lock exact-mode checkbox to "on"
  const exactEl = $("exact-mode");
  if (exactEl){
    try { exactEl.checked = true; exactEl.disabled = true; exactEl.style.display = "none"; } catch(_) {}
  }
  const vc = document.getElementById("viewer-controls");
  if (vc) { vc.style.display = "none"; }

  // Override convertWithBackend to ALWAYS use image-PDF (exact) mode
  window.convertWithBackend = async function(file){
    const form = new FormData();
    form.append("file", file, file.name);
    const url = "http://127.0.0.1:8000/convert?mode=imagepdf";
    const res = await fetch(url, { method: "POST", body: form });
    if (!res.ok){
      const msg = await res.text().catch(()=> "");
      throw new Error("Conversion failed: " + (msg || res.status + " " + res.statusText));
    }
    const backend = res.headers.get("X-Converter-Backend") || "";
    const blob = await res.blob();
    const objUrl = URL.createObjectURL(blob);
    const badge = $("backend-badge");
    if (badge) badge.textContent = backend ? ("Converted via: " + backend) : "";
    return { url: objUrl, backend };
  };

  // Helper
  function ensureViewerOpen(){
    const wa = $("work-area");
    if (wa && !wa.classList.contains("viewer-open")) wa.classList.add("viewer-open");
  }
  function setViewer(title, url){
    ensureViewerOpen();
    const t = $("pdf-title");
    const f = $("pdf-iframe");
    if (t) t.textContent = title || "Lecture Viewer";
    if (f) f.src = url;
  }
  function fileExt(name=""){
    const m = String(name).toLowerCase().match(/\.([a-z0-9]+)(?:\?.*)?$/);
    return m ? m[1] : "";
  }

  async function handleFiles(files){
    const ifr = $("pdf-iframe");
    const titleEl = $("pdf-title");
    const nowId = () => Date.now() + "-" + Math.random().toString(36).slice(2);

    for (const f of files){
      const ext = fileExt(f.name);
      if (ext === "pdf"){
        const url = URL.createObjectURL(f);
        if (titleEl) titleEl.textContent = f.name;
        if (ifr){
          ensureViewerOpen();
          ifr.removeAttribute("src");
          ifr.src = url;
        }
        const rec = {
          id: nowId(),
          title: f.name,
          filename: f.name,
          createdAt: Date.now(),
          mime: "application/pdf",
          blob: f,
          source: "upload",
          objectUrl: url
        };
        await (window.saveResource ? window.saveResource(rec) : saveResource(rec));
      } else if (ext === "ppt" || ext === "pptx"){
        // Show converting status in the viewer
        if (titleEl) titleEl.textContent = "Converting to PDF…";
        if (ifr){
          ensureViewerOpen();
          ifr.removeAttribute("src");
          ifr.srcdoc = '<!doctype html><html><body style="margin:0;display:flex;align-items:center;justify-content:center;height:100vh;font:16px system-ui">Converting to PDF…<script>
/* === PATCH (Hide Reset element at runtime for safety) === */
(function(){
  try{
    var r = document.getElementById('reset-btn');
    if (r){
      r.setAttribute('hidden','');
      r.setAttribute('aria-hidden','true');
      r.setAttribute('tabindex','-1');
      r.style.display='none';
      r.style.pointerEvents='none';
    }
  }catch(_e){}
})();
</script>
<script>
/* === PATCH: Remove leaked inline code text from UI === */
(function(){
  function stripLeakedCodeText(root){
    try{
      var walker = document.createTreeWalker(root || document.body, NodeFilter.SHOW_TEXT, null);
      var toRemove = [];
      var re = /(convertWithBackend|lecture-upload-input|nowId\(\)|handleFiles\s*\(|setViewer\(|"PPTX"\)\.replace|\)\s*;\s*\}\)\(\);)/i;
      while(walker.nextNode()){
        var n = walker.currentNode;
        if (!n || !n.nodeValue) continue;
        if (re.test(n.nodeValue) && n.nodeValue.length > 80){
          toRemove.push(n);
        }
      }
      for (var i=0;i<toRemove.length;i++){
        var n = toRemove[i];
        var parent = n.parentNode;
        if (parent && /^(pre|code)$/i.test(parent.nodeName)){
          parent.style.display = "none";
          parent.setAttribute("hidden","");
        } else if (parent && parent.childNodes.length === 1){
          parent.style.display = "none";
          parent.setAttribute("hidden","");
        } else {
          n.nodeValue = "";
        }
      }
    }catch(_e){}
  }
  if (document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", function(){ stripLeakedCodeText(document.body); });
  } else {
    stripLeakedCodeText(document.body);
  }
  // Watch for future insertions
  try{
    var mo = new MutationObserver(function(muts){
      for (var i=0;i<muts.length;i++){
        var m = muts[i];
        if (m.addedNodes && m.addedNodes.length){
          for (var j=0;j<m.addedNodes.length;j++){
            var node = m.addedNodes[j];
            if (node.nodeType === 3 /* TEXT_NODE */){
              if (/(convertWithBackend|lecture-upload-input|nowId\(\)|handleFiles\s*\()/.test(node.nodeValue || "")){
                stripLeakedCodeText(node.parentNode || document.body);
              }
            } else if (node.nodeType === 1 /* ELEMENT_NODE */){
              stripLeakedCodeText(node);
            }
          }
        }
      }
    });
    mo.observe(document.body, { childList:true, subtree:true });
  }catch(_e){}
})();
</script>

<!-- PATCH: Compact Mode sync with new JSON imports -->
<script type="text/plain" data-disabled="removed-compact-restore">
(function(){
  try{
    var d = document;
    function getKeys(){
      var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
      var SKEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz');
      return {
        QKEY: QKEY,
        BASE: QKEY + '_baseFullSet',
        BACKUP: QKEY + '_backupCompactOrig',
        CONF: SKEY + '_compactConfidence',
        MARK_SIG: SKEY + '_compactMarkSig',
        MARK_HASH: SKEY + '_compactMarkHash'
      };
    }
    function isValidQuestions(raw){
      if(!raw) return false;
      try{
        var arr = JSON.parse(raw);
        return Array.isArray(arr) && arr.length > 0;
      }catch(_e){ return false; }
    }
    function resetCompactCaches(){
      var K = getKeys();
      try{ localStorage.removeItem(K.BASE); }catch(_e){}
      try{ localStorage.removeItem(K.BACKUP); }catch(_e){}
      try{ localStorage.removeItem(K.CONF); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_SIG); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_HASH); }catch(_e){}
    }
    function rebuildIfOpen(){
      var ov = d.getElementById('compact-overlay');
      if(ov && ov.style && ov.style.display !== 'none'){
        // Close and re-open to force a fresh build from new data
        ov.style.display = 'none';
        var cb = d.getElementById('compact-btn');
        if(cb && cb.click){
          setTimeout(function(){ cb.click(); }, 50);
        }
      }
    }
    function syncNow(){
      var K = getKeys();
      var raw = localStorage.getItem(K.QKEY);
      if(!isValidQuestions(raw)) return;
      // Clear caches so Compact Mode rebuilds against the new set
      resetCompactCaches();
      // Optionally prime BASE with the new set so Focus/Restore works immediately
      try{ localStorage.setItem(K.BASE, raw); }catch(_e){}
      try{ localStorage.setItem(K.BACKUP, raw); }catch(_e){}
      rebuildIfOpen();
    }
    function hookImport(){
      var importBtn = d.getElementById('import-load-json') || d.getElementById('importLoad');
      var fileInput = d.getElementById('import-json-file') || d.getElementById('importJSON');
      function schedule(){ setTimeout(syncNow, 600); }
      if(importBtn && !importBtn.__cmSync1){
        importBtn.__cmSync1 = true;
        importBtn.addEventListener('click', schedule, true);
      }
      if(fileInput && !fileInput.__cmSync2){
        fileInput.__cmSync2 = true;
        fileInput.addEventListener('change', schedule, true);
      }
      // Also listen to storage changes for QUESTIONS_KEY updates
      if(!window.__cmSyncStorage){
        window.__cmSyncStorage = true;
        window.addEventListener('storage', function(e){
          var K = getKeys();
          if(e && e.key === K.QKEY) syncNow();
        });
      }
    }
    function boot(){
      hookImport();
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    } else {
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();
</script>


<!-- PATCH: Compact Mode sync — include welcome Import button -->
<script type="text/plain" data-disabled="import-popup" type="text/plain" data-disabled="removed-compact-restore">
(function(){
  try{
    var d = document;
    function getKeys(){
      var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
      var SKEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz');
      return {
        QKEY: QKEY,
        BASE: QKEY + '_baseFullSet',
        BACKUP: QKEY + '_backupCompactOrig',
        CONF: SKEY + '_compactConfidence',
        MARK_SIG: SKEY + '_compactMarkSig',
        MARK_HASH: SKEY + '_compactMarkHash'
      };
    }
    function isValidQuestions(raw){
      if(!raw) return false;
      try{ var arr = JSON.parse(raw); return Array.isArray(arr) && arr.length > 0; }catch(_e){ return false; }
    }
    function resetCompactCaches(){
      var K = getKeys();
      try{ localStorage.removeItem(K.BASE); }catch(_e){}
      try{ localStorage.removeItem(K.BACKUP); }catch(_e){}
      try{ localStorage.removeItem(K.CONF); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_SIG); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_HASH); }catch(_e){}
    }
    function rebuildIfOpen(){
      var ov = d.getElementById('compact-overlay');
      if(ov && ov.style && ov.style.display !== 'none'){
        ov.style.display = 'none';
        var cb = d.getElementById('compact-btn');
        if(cb && cb.click){ setTimeout(function(){ cb.click(); }, 50); }
      }
    }
    function syncNow(){
      var K = getKeys();
      var raw = localStorage.getItem(K.QKEY);
      if(!isValidQuestions(raw)) return false;
      resetCompactCaches();
      try{ localStorage.setItem(K.BASE, raw); }catch(_e){}
      try{ localStorage.setItem(K.BACKUP, raw); }catch(_e){}
      rebuildIfOpen();
      return true;
    }
    function startImportPoll(){
      var K = getKeys();
      var t0 = Date.now();
      (function tick(){
        var ok = syncNow();
        if(!ok && Date.now() - t0 < 6000){ setTimeout(tick, 200); }
      })();
    }
    function hookWelcomeImport(){
      var openImport = d.getElementById('import-btn'); // welcome import button also uses this id
      if(openImport && !openImport.__cmWelcomeHook){
        openImport.__cmWelcomeHook = true;
        openImport.addEventListener('click', function(){ setTimeout(startImportPoll, 0); }, true);
      }
      var fileInput = d.getElementById('import-json-file') || d.getElementById('importJSON');
      if(fileInput && !fileInput.__cmWelcomeFile){
        fileInput.__cmWelcomeFile = true;
        fileInput.addEventListener('change', function(){ setTimeout(startImportPoll, 0); }, true);
      }
      var loadBtn = d.getElementById('import-load-json') || d.getElementById('importLoad');
      if(loadBtn && !loadBtn.__cmWelcomeLoad){
        loadBtn.__cmWelcomeLoad = true;
        loadBtn.addEventListener('click', function(){ setTimeout(startImportPoll, 0); }, true);
      }
    }
    function boot(){
      hookWelcomeImport();
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    } else {
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();
</script>


<!-- PATCH: Auto-resize quiz card when explanation shows/hides -->
<script>
(function(){
  try{
    var d = document;
    function adjustQuizHeight(){
      var quiz = d.getElementById('quiz-card');
      var exp = d.getElementById('explanation');
      if(!quiz || !exp) return;
      // Measure by letting height be auto briefly, then lock to measured content
      var prevPos = quiz.style.position;
      var prevH = quiz.style.height;
      // Keep fixed positioning (used by the layout), but clear height to compute content
      // Some builds set position fixed; if not set inline, reading style returns '' which we won't change.
      try{
        // Temporarily clear height to allow natural content size
        quiz.style.height = '';
        // Force reflow
        void quiz.offsetHeight;
        var needed = Math.max(200, quiz.scrollHeight);
        // Reapply explicit height to match content so the explanation is fully visible
        quiz.style.height = needed + 'px';
        // If the app re-applies user sizes, keep dataset.userHeight in sync so it won't revert
        if(quiz.dataset) quiz.dataset.userHeight = quiz.style.height;
      }catch(_e){
        // Fallback: leave as-is
        quiz.style.height = prevH;
      }
    }
    function onMutation(){
      // Debounce adjustments during rapid DOM updates
      if(onMutation.t){ cancelAnimationFrame(onMutation.t); }
      onMutation.t = requestAnimationFrame(adjustQuizHeight);
    }
    function boot(){
      var exp = d.getElementById('explanation');
      if(!exp) return;
      // Observe explanation content/visibility changes
      try{
        var mo = new MutationObserver(onMutation);
        mo.observe(exp, { attributes:true, childList:true, subtree:true });
      }catch(_e){}
      // Also run once on load and after small delay to catch initial show
      setTimeout(adjustQuizHeight, 0);
      setTimeout(adjustQuizHeight, 300);
    }
    if(d.readyState === 'loading'){
      d.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    } else {
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();
</script>

</body></html>';
        }
        try{
          const conv = await window.convertWithBackend(f);
          // Read blob back from object URL so we can persist
          const blob = await fetch(conv.url).then(r=> r.blob());
          const title = (f.name || "PPTX").replace(/\.(pptx?|PPTX?)$/, ".pdf");
          const rec = {
            id: nowId(),
            title,
            filename: title,
            createdAt: Date.now(),
            mime: "application/pdf",
            blob,
            source: "converted",
            objectUrl: conv.url
          };
          // Open in viewer
          setViewer(title, conv.url);
          // Persist and add to list
          await (window.saveResource ? window.saveResource(rec) : saveResource(rec));
        }catch(err){
          alert("Upload error: " + (err && err.message ? err.message : String(err)));
        }
      }
    }
  }
  // Fix: stop duplicate file-picker opens and no-op first selection
  const btn = $("upload-lectures-btn");
  const input = $("lecture-upload-input");

  if (btn && input){
    // Capture-phase click handler: prevent any other handlers and open ONCE
    btn.addEventListener("click", function(e){
      e.preventDefault();
      e.stopPropagation();
      if (e.stopImmediatePropagation) e.stopImmediatePropagation();
      input.click();
    }, true);

    // Capture-phase change handler: process files then clear input
    input.addEventListener("change", async function(e){
      try {
        const files = Array.from(this.files || []);
        if (!files.length) return;
        await (window.handleFiles ? window.handleFiles(files) : handleFiles(files));
      } finally {
        try { this.value = ""; } catch(_){}
      }
      e.preventDefault();
      e.stopPropagation();
      if (e.stopImmediatePropagation) e.stopImmediatePropagation();
      return false;
    }, true);
  }
})();
</script>

<!-- PATCH: Compact Mode sync with new JSON imports -->
<script type="text/plain" data-disabled="removed-compact-restore">
(function(){
  try{
    var d = document;
    function getKeys(){
      var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
      var SKEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz');
      return {
        QKEY: QKEY,
        BASE: QKEY + '_baseFullSet',
        BACKUP: QKEY + '_backupCompactOrig',
        CONF: SKEY + '_compactConfidence',
        MARK_SIG: SKEY + '_compactMarkSig',
        MARK_HASH: SKEY + '_compactMarkHash'
      };
    }
    function isValidQuestions(raw){
      if(!raw) return false;
      try{
        var arr = JSON.parse(raw);
        return Array.isArray(arr) && arr.length > 0;
      }catch(_e){ return false; }
    }
    function resetCompactCaches(){
      var K = getKeys();
      try{ localStorage.removeItem(K.BASE); }catch(_e){}
      try{ localStorage.removeItem(K.BACKUP); }catch(_e){}
      try{ localStorage.removeItem(K.CONF); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_SIG); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_HASH); }catch(_e){}
    }
    function rebuildIfOpen(){
      var ov = d.getElementById('compact-overlay');
      if(ov && ov.style && ov.style.display !== 'none'){
        // Close and re-open to force a fresh build from new data
        ov.style.display = 'none';
        var cb = d.getElementById('compact-btn');
        if(cb && cb.click){
          setTimeout(function(){ cb.click(); }, 50);
        }
      }
    }
    function syncNow(){
      var K = getKeys();
      var raw = localStorage.getItem(K.QKEY);
      if(!isValidQuestions(raw)) return;
      // Clear caches so Compact Mode rebuilds against the new set
      resetCompactCaches();
      // Optionally prime BASE with the new set so Focus/Restore works immediately
      try{ localStorage.setItem(K.BASE, raw); }catch(_e){}
      try{ localStorage.setItem(K.BACKUP, raw); }catch(_e){}
      rebuildIfOpen();
    }
    function hookImport(){
      var importBtn = d.getElementById('import-load-json') || d.getElementById('importLoad');
      var fileInput = d.getElementById('import-json-file') || d.getElementById('importJSON');
      function schedule(){ setTimeout(syncNow, 600); }
      if(importBtn && !importBtn.__cmSync1){
        importBtn.__cmSync1 = true;
        importBtn.addEventListener('click', schedule, true);
      }
      if(fileInput && !fileInput.__cmSync2){
        fileInput.__cmSync2 = true;
        fileInput.addEventListener('change', schedule, true);
      }
      // Also listen to storage changes for QUESTIONS_KEY updates
      if(!window.__cmSyncStorage){
        window.__cmSyncStorage = true;
        window.addEventListener('storage', function(e){
          var K = getKeys();
          if(e && e.key === K.QKEY) syncNow();
        });
      }
    }
    function boot(){
      hookImport();
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    } else {
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();
</script>


<!-- PATCH: Compact Mode sync — include welcome Import button -->
<script type="text/plain" data-disabled="import-popup" type="text/plain" data-disabled="removed-compact-restore">
(function(){
  try{
    var d = document;
    function getKeys(){
      var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
      var SKEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz');
      return {
        QKEY: QKEY,
        BASE: QKEY + '_baseFullSet',
        BACKUP: QKEY + '_backupCompactOrig',
        CONF: SKEY + '_compactConfidence',
        MARK_SIG: SKEY + '_compactMarkSig',
        MARK_HASH: SKEY + '_compactMarkHash'
      };
    }
    function isValidQuestions(raw){
      if(!raw) return false;
      try{ var arr = JSON.parse(raw); return Array.isArray(arr) && arr.length > 0; }catch(_e){ return false; }
    }
    function resetCompactCaches(){
      var K = getKeys();
      try{ localStorage.removeItem(K.BASE); }catch(_e){}
      try{ localStorage.removeItem(K.BACKUP); }catch(_e){}
      try{ localStorage.removeItem(K.CONF); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_SIG); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_HASH); }catch(_e){}
    }
    function rebuildIfOpen(){
      var ov = d.getElementById('compact-overlay');
      if(ov && ov.style && ov.style.display !== 'none'){
        ov.style.display = 'none';
        var cb = d.getElementById('compact-btn');
        if(cb && cb.click){ setTimeout(function(){ cb.click(); }, 50); }
      }
    }
    function syncNow(){
      var K = getKeys();
      var raw = localStorage.getItem(K.QKEY);
      if(!isValidQuestions(raw)) return false;
      resetCompactCaches();
      try{ localStorage.setItem(K.BASE, raw); }catch(_e){}
      try{ localStorage.setItem(K.BACKUP, raw); }catch(_e){}
      rebuildIfOpen();
      return true;
    }
    function startImportPoll(){
      var K = getKeys();
      var t0 = Date.now();
      (function tick(){
        var ok = syncNow();
        if(!ok && Date.now() - t0 < 6000){ setTimeout(tick, 200); }
      })();
    }
    function hookWelcomeImport(){
      var openImport = d.getElementById('import-btn'); // welcome import button also uses this id
      if(openImport && !openImport.__cmWelcomeHook){
        openImport.__cmWelcomeHook = true;
        openImport.addEventListener('click', function(){ setTimeout(startImportPoll, 0); }, true);
      }
      var fileInput = d.getElementById('import-json-file') || d.getElementById('importJSON');
      if(fileInput && !fileInput.__cmWelcomeFile){
        fileInput.__cmWelcomeFile = true;
        fileInput.addEventListener('change', function(){ setTimeout(startImportPoll, 0); }, true);
      }
      var loadBtn = d.getElementById('import-load-json') || d.getElementById('importLoad');
      if(loadBtn && !loadBtn.__cmWelcomeLoad){
        loadBtn.__cmWelcomeLoad = true;
        loadBtn.addEventListener('click', function(){ setTimeout(startImportPoll, 0); }, true);
      }
    }
    function boot(){
      hookWelcomeImport();
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    } else {
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();
</script>


<!-- PATCH: Auto-resize quiz card when explanation shows/hides -->
<script>
(function(){
  try{
    var d = document;
    function adjustQuizHeight(){
      var quiz = d.getElementById('quiz-card');
      var exp = d.getElementById('explanation');
      if(!quiz || !exp) return;
      // Measure by letting height be auto briefly, then lock to measured content
      var prevPos = quiz.style.position;
      var prevH = quiz.style.height;
      // Keep fixed positioning (used by the layout), but clear height to compute content
      // Some builds set position fixed; if not set inline, reading style returns '' which we won't change.
      try{
        // Temporarily clear height to allow natural content size
        quiz.style.height = '';
        // Force reflow
        void quiz.offsetHeight;
        var needed = Math.max(200, quiz.scrollHeight);
        // Reapply explicit height to match content so the explanation is fully visible
        quiz.style.height = needed + 'px';
        // If the app re-applies user sizes, keep dataset.userHeight in sync so it won't revert
        if(quiz.dataset) quiz.dataset.userHeight = quiz.style.height;
      }catch(_e){
        // Fallback: leave as-is
        quiz.style.height = prevH;
      }
    }
    function onMutation(){
      // Debounce adjustments during rapid DOM updates
      if(onMutation.t){ cancelAnimationFrame(onMutation.t); }
      onMutation.t = requestAnimationFrame(adjustQuizHeight);
    }
    function boot(){
      var exp = d.getElementById('explanation');
      if(!exp) return;
      // Observe explanation content/visibility changes
      try{
        var mo = new MutationObserver(onMutation);
        mo.observe(exp, { attributes:true, childList:true, subtree:true });
      }catch(_e){}
      // Also run once on load and after small delay to catch initial show
      setTimeout(adjustQuizHeight, 0);
      setTimeout(adjustQuizHeight, 300);
    }
    if(d.readyState === 'loading'){
      d.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    } else {
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();
</script>

</body></html>
<script>
(function(){
  // Make any button labeled "Reset" act as a full page reset if it doesn't already have an onclick.
  function makeResetButton(btn){
    if(!btn) return;
    btn.addEventListener('click', function(e){
      e.preventDefault();
      // Reload the page to its original starting state
      window.location.reload();
    });
  }

  // Try to find existing reset-like buttons by id or text
  var candidates = [];
  var byId = document.getElementById('reset-layout-btn') || document.getElementById('reset-progress') || document.getElementById('full-reset-btn');
  if(byId) candidates.push(byId);
  // buttons with innerText Reset (case-insensitive)
  document.querySelectorAll('button').forEach(function(b){
    if(b.innerText && b.innerText.trim().toLowerCase() === 'reset') candidates.push(b);
  });
  // make them reset
  candidates.forEach(makeResetButton);

  // If none found, insert a Reset button at top-left inside #work-area
  if(candidates.length === 0){
    var area = document.getElementById('work-area') || document.body;
    var btn = document.createElement('button');
    btn.id = 'full-reset-btn';
    btn.type = 'button';
    btn.innerText = 'Reset';
    btn.title = 'Reset page to original state';
    btn.style.position = 'fixed';
    btn.style.left = '12px';
    btn.style.top = '12px';
    btn.style.zIndex = 2000;
    btn.style.padding = '6px 10px';
    btn.style.borderRadius = '8px';
    btn.style.border = '1px solid rgba(0,0,0,0.12)';
    btn.style.background = 'rgba(255,255,255,0.92)';
    btn.style.color = '#222';
    btn.style.cursor = 'pointer';
    document.body.appendChild(btn);
    makeResetButton(btn);
  }
})();
</script>
<script>
(function(){
  var iframe = document.getElementById('pdf-iframe');
  var slider = document.getElementById('pdf-zoom-slider');
  var zoomIn = document.getElementById('pdf-zoom-in');
  var zoomOut = document.getElementById('pdf-zoom-out');
  var zoomReset = document.getElementById('pdf-zoom-reset');
  var pane = document.getElementById('pdf-pane');
  if(!iframe || !pane) return;

  // read existing zoom value or default
  var zoom = 1.0;
  function readSlider(){
    if(slider) return parseFloat(slider.value)/100;
    return zoom;
  }
  if(slider) zoom = readSlider();

  // Keep applyZoom function in sync with existing implementation if present
  function applyZoom(z){
    zoom = Math.min(2.5, Math.max(0.5, z));
    iframe.style.transformOrigin = '0 0';
    iframe.style.transform = 'scale(' + zoom + ')';
    iframe.style.width = (100/zoom) + '%';
    iframe.style.height = (100/zoom) + '%';
    if(slider) slider.value = Math.round(zoom*100);
    if(zoomReset) zoomReset.textContent = Math.round(zoom*100) + '%';
  }

  // Hook up buttons/slider if not already hooked
  if(zoomIn && !zoomIn._zoomHooked) { zoomIn.addEventListener('click', function(){ applyZoom(zoom + 0.1); }); zoomIn._zoomHooked = true; }
  if(zoomOut && !zoomOut._zoomHooked) { zoomOut.addEventListener('click', function(){ applyZoom(zoom - 0.1); }); zoomOut._zoomHooked = true; }
  if(zoomReset && !zoomReset._zoomHooked) { zoomReset.addEventListener('click', function(){ applyZoom(1); }); zoomReset._zoomHooked = true; }
  if(slider && !slider._zoomHooked){ slider.addEventListener('input', function(e){ applyZoom(e.target.value/100); }); slider._zoomHooked = true; }

  // Touch pinch handling (touch devices)
  var pinch = {startDist:0, startZoom:zoom, active:false};
  function dist(p1,p2){ var dx = p2.clientX - p1.clientX; var dy = p2.clientY - p1.clientY; return Math.sqrt(dx*dx + dy*dy); }

  pane.addEventListener('touchstart', function(e){
    if(e.touches && e.touches.length === 2){
      pinch.active = true;
      pinch.startDist = dist(e.touches[0], e.touches[1]);
      pinch.startZoom = zoom;
      e.preventDefault();
    }
  }, {passive:false});

  pane.addEventListener('touchmove', function(e){
    if(pinch.active && e.touches && e.touches.length === 2){
      var d = dist(e.touches[0], e.touches[1]);
      var scale = d / pinch.startDist;
      applyZoom(pinch.startZoom * scale);
      e.preventDefault();
    }
  }, {passive:false});

  pane.addEventListener('touchend', function(e){
    if(pinch.active){
      if(!e.touches || e.touches.length < 2) pinch.active = false;
    }
  });

  // Trackpad pinch (many browsers send wheel events with ctrlKey during pinch)
  pane.addEventListener('wheel', function(e){
    if(e.ctrlKey){
      // interpret ctrl-wheel as pinch gesture; deltaY positive -> zoom out
      var factor = 1 - (e.deltaY * 0.0016);
      applyZoom(zoom * factor);
      e.preventDefault();
    }
  }, {passive:false});

  // Safari-like gesture events (gesturestart/gesturechange) support
  pane.addEventListener('gesturestart', function(e){
    if(e.scale){ pinch.active = true; pinch.startZoom = zoom; pinch.startDist = 0; e.preventDefault(); }
  }, false);
  pane.addEventListener('gesturechange', function(e){
    if(e.scale && pinch.active){ applyZoom(pinch.startZoom * e.scale); e.preventDefault(); }
  }, false);
  pane.addEventListener('gestureend', function(e){ pinch.active = false; }, false);

  // Initialize UI state
  applyZoom(zoom);
})();
</script>




<script>
/*** === In-house PPTX→PDF via LibreOffice backend ===
  - Requires running the provided FastAPI server on http://127.0.0.1:8000
  - When a local .ppt/.pptx is selected, we upload to /convert and display the returned PDF.
***/
(function(){
  "use strict";
  const $ = (id) => document.getElementById(id);
  const uploadInp = $("lecture-upload-input");
  const workArea = $("work-area");
  const pdfTitle = $("pdf-title");
  const pdfIframe = $("pdf-iframe");
  const resourcesList = $("resources-list");

  const CONVERTER_URL = "http://127.0.0.1:8000/convert";

  function ensureViewerOpen(){
    try{
      if (workArea && !workArea.classList.contains("viewer-open")) {
        workArea.classList.add("viewer-open");
      }
    }catch(e){}
  }
  function setViewer(title, url){
    ensureViewerOpen();
    try{ if (pdfTitle) pdfTitle.textContent = title || "Lecture Viewer"; }catch(e){}
    try{ if (pdfIframe) pdfIframe.src = url; }catch(e){}
  }
  function fileExtFromName(name=""){
    const m = String(name).toLowerCase().match(/\.([a-z0-9]+)(?:\?.*)?$/);
    return m ? m[1] : "";
  }
  function showConvertingOverlay(){
    let ov = document.getElementById("pptx-convert-overlay");
    if (!ov){
      ov = document.createElement("div");
      ov.id = "pptx-convert-overlay";
      ov.style.position = "absolute";
      ov.style.inset = "46px 10px 10px 10px";
      ov.style.background = "rgba(20,20,20,0.85)";
      ov.style.color = "#fff";
      ov.style.padding = "18px";
      ov.style.borderRadius = "8px";
      ov.style.display = "none";
      ov.style.zIndex = "2001";
      ov.innerHTML = '<div style="font-size:1rem">Converting PowerPoint to PDF…</div>';
      const pdfPane = document.getElementById("pdf-pane") || document.body;
      pdfPane.appendChild(ov);
    }
    ov.style.display = "block";
    return ov;
  }
  function hideOverlay(ov){
    if (ov) ov.style.display = "none";
  }
  async function convertWithBackend(file){
    const form = new FormData();
    form.append("file", file, file.name);
    const exactEl = document.getElementById("exact-mode");
    const mode = exactEl && exactEl.checked ? "imagepdf" : "pdf";
    const url = "http://127.0.0.1:8000/convert?mode=" + mode;
    const res = await fetch(url, { method: "POST", body: form });
    if (!res.ok){
      const msg = await res.text();
      throw new Error("Conversion failed: " + msg);
    }
    const backend = res.headers.get("X-Converter-Backend") || "unknown";
    const blob = await res.blob();
    const objUrl = URL.createObjectURL(blob);
    return { url: objUrl, backend };
  });
    if (!res.ok){
      const msg = await res.text();
      throw new Error("Conversion failed: " + msg);
    }
    const backend = res.headers.get("X-Converter-Backend") || "unknown";
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    return { url, backend };
  });
    if (!res.ok){
      const msg = await res.text();
      throw new Error("Conversion failed: " + msg);
    }
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    return url;
  }
  function addResourceToList(title, url){
    try{
      if (!resourcesList) return;
      const li = document.createElement("li");
      const a = document.createElement("a");
      a.className = "resources-link";
      a.href = url;
      a.setAttribute("data-view", url);
      a.innerHTML = '<span class="resources-title"></span><span class="resources-meta">PDF</span>';
      li.appendChild(a);
      resourcesList.prepend(li);
      const t = a.querySelector(".resources-title");
      if (t) t.textContent = title;
      // Click to open
      a.addEventListener("click", (e)=>{
        e.preventDefault();
        setViewer(title, url);
      });
    }catch(e){}
  }

  if (uploadInp){
    // Capture-phase listener: runs before previously-registered handlers.
    uploadInp.addEventListener("change", async (e)=>{
      try{
        const files = Array.from(e.target.files || []);
        if (!files.length) return;
        const ov = showConvertingOverlay();
        for (const f of files){
          const ext = fileExtFromName(f.name);
          if (ext === "pdf"){
            const url = URL.createObjectURL(f);
            addResourceToList(f.name, url);
            setViewer(f.name, url);
          } else if (ext === "ppt" || ext === "pptx"){
            try{
              const { url: pdfUrl, backend } = await convertWithBackend(f);
              const title = (f.name || "PPTX").replace(/\.(pptx|ppt)$/i, ".pdf");
              addResourceToList(title, pdfUrl);
              setViewer(title, pdfUrl);
              (function(){ const el = document.getElementById('backend-badge'); if (el) el.textContent = 'Converted via: ' + backend; })();
              title, pdfUrl);
              setViewer(title, pdfUrl);
            }catch(err){
              alert(err.message || String(err));
            }
          } else {
            // ignore others
          }
        }
        hideOverlay(ov);
      }catch(err){
        console.error(err);
        alert("Error: " + (err && err.message ? err.message : String(err)));
      }finally{
        try{ uploadInp.value = ""; }catch(_){}
      }
      // Prevent earlier "overlay" handler from running
      e.stopImmediatePropagation();
      e.preventDefault();
      return false;
    }, {capture:true});
  }
})();
</script>


<script type="text/plain" data-disabled="removed-compact-restore">
(function(){
  "use strict";
  const $ = (id) => document.getElementById(id);

  // ---------- Persistence Layer (IndexedDB + optional File System Access handles) ----------
  const DB_NAME = "quizViewerDB";
  const DB_STORE = "resources";

  function openDB(){
    return new Promise((resolve,reject)=>{
      const req = indexedDB.open(DB_NAME, 2);
      req.onupgradeneeded = ()=>{
        const db = req.result;
        if (!db.objectStoreNames.contains(DB_STORE)){
          const store = db.createObjectStore(DB_STORE, { keyPath: "id" });
          store.createIndex("createdAt", "createdAt", { unique: false });
        }
      };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }

  async function idbPut(rec){
    const db = await openDB();
    await new Promise((resolve,reject)=>{
      const tx = db.transaction(DB_STORE, "readwrite");
      tx.objectStore(DB_STORE).put(rec);
      tx.oncomplete = resolve;
      tx.onerror = ()=> reject(tx.error);
    });
  }

  async function idbGetAll(){
    const db = await openDB();
    return await new Promise((resolve,reject)=>{
      const tx = db.transaction(DB_STORE, "readonly");
      const req = tx.objectStore(DB_STORE).getAll();
      req.onsuccess = ()=> resolve(req.result || []);
      req.onerror = ()=> reject(req.error);
    });
  }

  // Add to UI list
  function addResourceListItem(rec){
    const list = $("resources-list");
    if (!list) return;
    const li = document.createElement("li");
    const a = document.createElement("a");
    a.className = "resources-link";
    a.href = "#";
    a.setAttribute("data-view", rec.objectUrl || "");
    a.innerHTML = '<span class="resources-title"></span><span class="resources-meta">PDF</span>';
    li.appendChild(a);
    list.prepend(li);
    const tt = a.querySelector(".resources-title");
    if (tt) tt.textContent = rec.title || rec.filename || "PDF";
    a.addEventListener("click", async (e)=>{
      e.preventDefault();
      // If we have a handle, re-resolve to a blob URL
      if (!rec.objectUrl && rec.handle && rec.handle.getFile){
        try {
          const file = await rec.handle.getFile();
          rec.objectUrl = URL.createObjectURL(file);
        } catch(_){ /* permission may be needed; click will do nothing */ }
      }
      const url = rec.objectUrl;
      if (url){
        const ifr = $("pdf-iframe");
        const titleEl = $("pdf-title");
        if (titleEl) titleEl.textContent = rec.title || rec.filename;
        if (ifr){
          ifr.removeAttribute("srcdoc");
          ifr.src = url;
        }
      }
    });
  }

  async function restoreResources(){
    try{
      const items = await idbGetAll();
      items.sort((a,b)=> (b.createdAt||0) - (a.createdAt||0));
      for (const rec of items){
        // Attempt to reconstruct objectUrl from handle first
        if (!rec.objectUrl && rec.handle && rec.handle.getFile){
          try {
            const file = await rec.handle.getFile();
            rec.objectUrl = URL.createObjectURL(file);
          } catch(_){ /* user may need to grant permission later */ }
        }
        addResourceListItem(rec);
      }
    }catch(err){
      console.warn("restoreResources error", err);
    }
  }
  document.addEventListener("DOMContentLoaded", restoreResources, { once: true });

  // Save helper that prefers saving to disk and storing a file handle; falls back to blob-in-IDB
  async function saveResource(rec){
    try{
      // Prefer File System Access API when available and we have a blob
      const canFS = !!window.showSaveFilePicker && rec && rec.blob instanceof Blob;
      if (canFS){
        const handle = await window.showSaveFilePicker({
          suggestedName: rec.filename || rec.title || "lecture.pdf",
          types: [{ description: "PDF", accept: { "application/pdf": [".pdf"] } }]
        });
        const writable = await handle.createWritable();
        await writable.write(rec.blob);
        await writable.close();
        rec.handle = handle;       // store the file handle (serializable)
        rec.objectUrl = "";        // will be resolved on demand
        rec.blob = undefined;      // no need to keep the blob in the DB
      } else {
        // If we cannot save to disk, keep blob in DB and objectUrl for current session
        if (!rec.objectUrl && rec.blob){
          rec.objectUrl = URL.createObjectURL(rec.blob);
        }
      }
      await idbPut(rec);
      addResourceListItem(rec);
    }catch(err){
      console.warn("saveResource failed", err);
      // Still add to list at least, if we have a URL
      try { addResourceListItem(rec); } catch(_){}
    }
  }

  // Expose on window so earlier code can call
  window.saveResource = saveResource;
  window.addResourceListItem = addResourceListItem;

  // Utility
  const ensureViewerOpen = ()=>{
    const wa = $("work-area");
    if (wa && !wa.classList.contains("viewer-open")) wa.classList.add("viewer-open");
  };
  const fileExt = (name="") => {
    const m = String(name).toLowerCase().match(/\.([a-z0-9]+)(?:\?.*)?$/);
    return m ? m[1] : "";
  };
  const setViewer = (title, url)=>{
    ensureViewerOpen();
    const t = $("pdf-title");
    const f = $("pdf-iframe");
    if (t) t.textContent = title || "Lecture Viewer";
    if (f) { f.removeAttribute("srcdoc"); f.src = url; }
  };

  // Override handleFiles to integrate disk-saving flow
  window.handleFiles = async function(files){
    const ifr = $("pdf-iframe");
    const titleEl = $("pdf-title");
    const nowId = () => Date.now() + "-" + Math.random().toString(36).slice(2);

    for (const f of files){
      const ext = fileExt(f.name);
      if (ext === "pdf"){
        // Show immediately
        const url = URL.createObjectURL(f);
        setViewer(f.name, url);
        const rec = {
          id: nowId(),
          title: f.name,
          filename: f.name,
          createdAt: Date.now(),
          mime: "application/pdf",
          blob: f,
          source: "upload",
          objectUrl: url
        };
        await saveResource(rec);
      } else if (ext === "ppt" || ext === "pptx"){
        // Show converting status
        if (titleEl) titleEl.textContent = "Converting to PDF…";
        if (ifr){
          ensureViewerOpen();
          ifr.removeAttribute("src");
          ifr.srcdoc = '<!doctype html><html><body style="margin:0;display:flex;align-items:center;justify-content:center;height:100vh;font:16px system-ui">Converting to PDF…
<!-- PATCH: Compact Mode sync with new JSON imports -->
<script>
(function(){
  try{
    var d = document;
    function getKeys(){
      var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
      var SKEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz');
      return {
        QKEY: QKEY,
        BASE: QKEY + '_baseFullSet',
        BACKUP: QKEY + '_backupCompactOrig',
        CONF: SKEY + '_compactConfidence',
        MARK_SIG: SKEY + '_compactMarkSig',
        MARK_HASH: SKEY + '_compactMarkHash'
      };
    }
    function isValidQuestions(raw){
      if(!raw) return false;
      try{
        var arr = JSON.parse(raw);
        return Array.isArray(arr) && arr.length > 0;
      }catch(_e){ return false; }
    }
    function resetCompactCaches(){
      var K = getKeys();
      try{ localStorage.removeItem(K.BASE); }catch(_e){}
      try{ localStorage.removeItem(K.BACKUP); }catch(_e){}
      try{ localStorage.removeItem(K.CONF); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_SIG); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_HASH); }catch(_e){}
    }
    function rebuildIfOpen(){
      var ov = d.getElementById('compact-overlay');
      if(ov && ov.style && ov.style.display !== 'none'){
        // Close and re-open to force a fresh build from new data
        ov.style.display = 'none';
        var cb = d.getElementById('compact-btn');
        if(cb && cb.click){
          setTimeout(function(){ cb.click(); }, 50);
        }
      }
    }
    function syncNow(){
      var K = getKeys();
      var raw = localStorage.getItem(K.QKEY);
      if(!isValidQuestions(raw)) return;
      // Clear caches so Compact Mode rebuilds against the new set
      resetCompactCaches();
      // Optionally prime BASE with the new set so Focus/Restore works immediately
      try{ localStorage.setItem(K.BASE, raw); }catch(_e){}
      try{ localStorage.setItem(K.BACKUP, raw); }catch(_e){}
      rebuildIfOpen();
    }
    function hookImport(){
      var importBtn = d.getElementById('import-load-json') || d.getElementById('importLoad');
      var fileInput = d.getElementById('import-json-file') || d.getElementById('importJSON');
      function schedule(){ setTimeout(syncNow, 600); }
      if(importBtn && !importBtn.__cmSync1){
        importBtn.__cmSync1 = true;
        importBtn.addEventListener('click', schedule, true);
      }
      if(fileInput && !fileInput.__cmSync2){
        fileInput.__cmSync2 = true;
        fileInput.addEventListener('change', schedule, true);
      }
      // Also listen to storage changes for QUESTIONS_KEY updates
      if(!window.__cmSyncStorage){
        window.__cmSyncStorage = true;
        window.addEventListener('storage', function(e){
          var K = getKeys();
          if(e && e.key === K.QKEY) syncNow();
        });
      }
    }
    function boot(){
      hookImport();
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    } else {
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();
</script><script type="text/plain" data-disabled="removed-compact-restore">
(function(){
  try{
    var d = document;
    function getKeys(){
      var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
      var SKEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz');
      return {
        QKEY: QKEY,
        BASE: QKEY + '_baseFullSet',
        BACKUP: QKEY + '_backupCompactOrig',
        CONF: SKEY + '_compactConfidence',
        MARK_SIG: SKEY + '_compactMarkSig',
        MARK_HASH: SKEY + '_compactMarkHash'
      };
    }
    function isValidQuestions(raw){
      if(!raw) return false;
      try{
        var arr = JSON.parse(raw);
        return Array.isArray(arr) && arr.length > 0;
      }catch(_e){ return false; }
    }
    function resetCompactCaches(){
      var K = getKeys();
      try{ localStorage.removeItem(K.BASE); }catch(_e){}
      try{ localStorage.removeItem(K.BACKUP); }catch(_e){}
      try{ localStorage.removeItem(K.CONF); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_SIG); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_HASH); }catch(_e){}
    }
    function rebuildIfOpen(){
      var ov = d.getElementById('compact-overlay');
      if(ov && ov.style && ov.style.display !== 'none'){
        // Close and re-open to force a fresh build from new data
        ov.style.display = 'none';
        var cb = d.getElementById('compact-btn');
        if(cb && cb.click){
          setTimeout(function(){ cb.click(); }, 50);
        }
      }
    }
    function syncNow(){
      var K = getKeys();
      var raw = localStorage.getItem(K.QKEY);
      if(!isValidQuestions(raw)) return;
      // Clear caches so Compact Mode rebuilds against the new set
      resetCompactCaches();
      // Optionally prime BASE with the new set so Focus/Restore works immediately
      try{ localStorage.setItem(K.BASE, raw); }catch(_e){}
      try{ localStorage.setItem(K.BACKUP, raw); }catch(_e){}
      rebuildIfOpen();
    }
    function hookImport(){
      var importBtn = d.getElementById('import-load-json') || d.getElementById('importLoad');
      var fileInput = d.getElementById('import-json-file') || d.getElementById('importJSON');
      function schedule(){ setTimeout(syncNow, 600); }
      if(importBtn && !importBtn.__cmSync1){
        importBtn.__cmSync1 = true;
        importBtn.addEventListener('click', schedule, true);
      }
      if(fileInput && !fileInput.__cmSync2){
        fileInput.__cmSync2 = true;
        fileInput.addEventListener('change', schedule, true);
      }
      // Also listen to storage changes for QUESTIONS_KEY updates
      if(!window.__cmSyncStorage){
        window.__cmSyncStorage = true;
        window.addEventListener('storage', function(e){
          var K = getKeys();
          if(e && e.key === K.QKEY) syncNow();
        });
      }
    }
    function boot(){
      hookImport();
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    } else {
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();
</script>


<!-- PATCH: Compact Mode sync — include welcome Import button -->
<script type="text/plain" data-disabled="import-popup" type="text/plain" data-disabled="removed-compact-restore">
(function(){
  try{
    var d = document;
    function getKeys(){
      var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
      var SKEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz');
      return {
        QKEY: QKEY,
        BASE: QKEY + '_baseFullSet',
        BACKUP: QKEY + '_backupCompactOrig',
        CONF: SKEY + '_compactConfidence',
        MARK_SIG: SKEY + '_compactMarkSig',
        MARK_HASH: SKEY + '_compactMarkHash'
      };
    }
    function isValidQuestions(raw){
      if(!raw) return false;
      try{ var arr = JSON.parse(raw); return Array.isArray(arr) && arr.length > 0; }catch(_e){ return false; }
    }
    function resetCompactCaches(){
      var K = getKeys();
      try{ localStorage.removeItem(K.BASE); }catch(_e){}
      try{ localStorage.removeItem(K.BACKUP); }catch(_e){}
      try{ localStorage.removeItem(K.CONF); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_SIG); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_HASH); }catch(_e){}
    }
    function rebuildIfOpen(){
      var ov = d.getElementById('compact-overlay');
      if(ov && ov.style && ov.style.display !== 'none'){
        ov.style.display = 'none';
        var cb = d.getElementById('compact-btn');
        if(cb && cb.click){ setTimeout(function(){ cb.click(); }, 50); }
      }
    }
    function syncNow(){
      var K = getKeys();
      var raw = localStorage.getItem(K.QKEY);
      if(!isValidQuestions(raw)) return false;
      resetCompactCaches();
      try{ localStorage.setItem(K.BASE, raw); }catch(_e){}
      try{ localStorage.setItem(K.BACKUP, raw); }catch(_e){}
      rebuildIfOpen();
      return true;
    }
    function startImportPoll(){
      var K = getKeys();
      var t0 = Date.now();
      (function tick(){
        var ok = syncNow();
        if(!ok && Date.now() - t0 < 6000){ setTimeout(tick, 200); }
      })();
    }
    function hookWelcomeImport(){
      var openImport = d.getElementById('import-btn'); // welcome import button also uses this id
      if(openImport && !openImport.__cmWelcomeHook){
        openImport.__cmWelcomeHook = true;
        openImport.addEventListener('click', function(){ setTimeout(startImportPoll, 0); }, true);
      }
      var fileInput = d.getElementById('import-json-file') || d.getElementById('importJSON');
      if(fileInput && !fileInput.__cmWelcomeFile){
        fileInput.__cmWelcomeFile = true;
        fileInput.addEventListener('change', function(){ setTimeout(startImportPoll, 0); }, true);
      }
      var loadBtn = d.getElementById('import-load-json') || d.getElementById('importLoad');
      if(loadBtn && !loadBtn.__cmWelcomeLoad){
        loadBtn.__cmWelcomeLoad = true;
        loadBtn.addEventListener('click', function(){ setTimeout(startImportPoll, 0); }, true);
      }
    }
    function boot(){
      hookWelcomeImport();
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    } else {
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();
</script>


<!-- PATCH: Auto-resize quiz card when explanation shows/hides -->
<script>
(function(){
  try{
    var d = document;
    function adjustQuizHeight(){
      var quiz = d.getElementById('quiz-card');
      var exp = d.getElementById('explanation');
      if(!quiz || !exp) return;
      // Measure by letting height be auto briefly, then lock to measured content
      var prevPos = quiz.style.position;
      var prevH = quiz.style.height;
      // Keep fixed positioning (used by the layout), but clear height to compute content
      // Some builds set position fixed; if not set inline, reading style returns '' which we won't change.
      try{
        // Temporarily clear height to allow natural content size
        quiz.style.height = '';
        // Force reflow
        void quiz.offsetHeight;
        var needed = Math.max(200, quiz.scrollHeight);
        // Reapply explicit height to match content so the explanation is fully visible
        quiz.style.height = needed + 'px';
        // If the app re-applies user sizes, keep dataset.userHeight in sync so it won't revert
        if(quiz.dataset) quiz.dataset.userHeight = quiz.style.height;
      }catch(_e){
        // Fallback: leave as-is
        quiz.style.height = prevH;
      }
    }
    function onMutation(){
      // Debounce adjustments during rapid DOM updates
      if(onMutation.t){ cancelAnimationFrame(onMutation.t); }
      onMutation.t = requestAnimationFrame(adjustQuizHeight);
    }
    function boot(){
      var exp = d.getElementById('explanation');
      if(!exp) return;
      // Observe explanation content/visibility changes
      try{
        var mo = new MutationObserver(onMutation);
        mo.observe(exp, { attributes:true, childList:true, subtree:true });
      }catch(_e){}
      // Also run once on load and after small delay to catch initial show
      setTimeout(adjustQuizHeight, 0);
      setTimeout(adjustQuizHeight, 300);
    }
    if(d.readyState === 'loading'){
      d.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    } else {
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();
</script>

</body></html>';
        }
        try{
          const conv = await (window.convertWithBackend ? window.convertWithBackend(f) : Promise.reject(new Error("Converter missing")));
          // Fetch blob from the object URL
          const blob = await fetch(conv.url).then(r=> r.blob());
          const title = (f.name || "PPTX").replace(/\.(pptx?|PPTX?)$/, ".pdf");
          // Open in viewer
          setViewer(title, conv.url);
          // Persist (prefer saving to disk)
          const rec = {
            id: nowId(),
            title,
            filename: title,
            createdAt: Date.now(),
            mime: "application/pdf",
            blob,
            source: "converted",
            objectUrl: conv.url
          };
          await saveResource(rec);
        }catch(err){
          alert("Upload error: " + (err && err.message ? err.message : String(err)));
          // Clear status doc if failed
          if (ifr){ ifr.removeAttribute("srcdoc"); }
        }
      }
    }
  };
})();
</script>


<script>
(function(){
  "use strict";
  const $ = (id) => document.getElementById(id);

  function ensureViewerOpen(){
    const wa = $("work-area");
    if (wa && !wa.classList.contains("viewer-open")) wa.classList.add("viewer-open");
  }
  function setViewer(title, url){
    ensureViewerOpen();
    const t = $("pdf-title");
    const f = $("pdf-iframe");
    if (t) t.textContent = title || "Lecture Viewer";
    if (f){
      f.removeAttribute("srcdoc");
      f.src = url;
    }
  }

  async function ensureObjectUrl(rec){
    if (rec.objectUrl) return rec.objectUrl;
    // Try file handle flow
    try{
      if (rec.handle && (rec.handle.queryPermission || rec.handle.requestPermission)){
        let perm = (rec.handle.queryPermission ? await rec.handle.queryPermission({mode:"read"}) : "prompt");
        if (perm !== "granted" && rec.handle.requestPermission){
          perm = await rec.handle.requestPermission({mode:"read"});
        }
        if (perm === "granted"){
          const file = await rec.handle.getFile();
          rec.objectUrl = URL.createObjectURL(file);
          return rec.objectUrl;
        } else {
          alert("Please allow access to open the saved file.");
          return "";
        }
      }
    }catch(e){
      console.warn("ensureObjectUrl handle error", e);
    }
    // Fallback to blob if present
    if (rec.blob instanceof Blob){
      rec.objectUrl = URL.createObjectURL(rec.blob);
      return rec.objectUrl;
    }
    return "";
  }

  // Override the global addResourceListItem with a more robust version
  window.addResourceListItem = function(rec){
    const list = $("resources-list");
    if (!list) return;
    const li = document.createElement("li");
    const a = document.createElement("a");
    a.className = "resources-link";
    a.href = "#";
    a.setAttribute("data-view", rec.objectUrl || "");
    a.innerHTML = '<span class="resources-title"></span><span class="resources-meta">PDF</span>';
    li.appendChild(a);
    list.prepend(li);

    const tt = a.querySelector(".resources-title");
    if (tt) tt.textContent = rec.title || rec.filename || "PDF";

    a.addEventListener("click", async (e)=>{
      e.preventDefault();
      const url = await ensureObjectUrl(rec);
      if (!url) return;
      setViewer(rec.title || rec.filename, url);
    });
  };
})();
</script>


<script>
(function(){
  "use strict";
  const $ = (id) => document.getElementById(id);

  // Utility
  function ensureViewerOpen(){
    const wa = $("work-area");
    if (wa && !wa.classList.contains("viewer-open")) wa.classList.add("viewer-open");
  }
  function setViewer(title, url){
    ensureViewerOpen();
    const t = $("pdf-title");
    const f = $("pdf-iframe");
    if (t) t.textContent = title || "Lecture Viewer";
    if (f){
      f.removeAttribute("srcdoc");
      f.src = url || "about:blank";
    }
  }

  // --- DB helpers (reuse if present) ---
  const DB_NAME = "quizViewerDB";
  const DB_STORE = "resources";

  function openDB(){
    return new Promise((resolve,reject)=>{
      const req = indexedDB.open(DB_NAME, 3);
      req.onupgradeneeded = ()=>{
        const db = req.result;
        if (!db.objectStoreNames.contains(DB_STORE)){
          const store = db.createObjectStore(DB_STORE, { keyPath: "id" });
          store.createIndex("createdAt", "createdAt", { unique: false });
        }
      };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }
  async function idbPut(rec){
    const db = await openDB();
    await new Promise((resolve,reject)=>{
      const tx = db.transaction(DB_STORE, "readwrite");
      tx.objectStore(DB_STORE).put(rec);
      tx.oncomplete = resolve;
      tx.onerror = ()=> reject(tx.error);
    });
  }
  async function idbGetAll(){
    const db = await openDB();
    return await new Promise((resolve,reject)=>{
      const tx = db.transaction(DB_STORE, "readonly");
      const req = tx.objectStore(DB_STORE).getAll();
      req.onsuccess = ()=> resolve(req.result || []);
      req.onerror = ()=> reject(req.error);
    });
  }

  async function ensureObjectUrl(rec){
    // Already have one?
    if (rec.objectUrl) return rec.objectUrl;
    // Try handle
    try{
      if (rec.handle && (rec.handle.queryPermission || rec.handle.requestPermission)){
        let perm = (rec.handle.queryPermission ? await rec.handle.queryPermission({mode:"read"}) : "prompt");
        if (perm !== "granted" && rec.handle.requestPermission){
          perm = await rec.handle.requestPermission({mode:"read"});
        }
        if (perm === "granted"){
          const file = await rec.handle.getFile();
          rec.objectUrl = URL.createObjectURL(file);
          return rec.objectUrl;
        }
      }
    }catch(e){ console.warn("ensureObjectUrl handle error", e); }
    // Try blob
    if (rec.blob instanceof Blob){
      rec.objectUrl = URL.createObjectURL(rec.blob);
      return rec.objectUrl;
    }
    return "";
  }

  // Replace/define global list item renderer
  window.addResourceListItem = function(rec){
    const list = $("resources-list");
    if (!list) return;
    const li = document.createElement("li");
    const a = document.createElement("a");
    a.className = "resources-link";
    a.href = "#";
    a.setAttribute("data-view", rec.objectUrl || "");
    a.innerHTML = '<span class="resources-title"></span><span class="resources-meta">PDF</span>';
    li.appendChild(a);
    list.prepend(li);
    const tt = a.querySelector(".resources-title");
    tt.textContent = rec.title || rec.filename || "PDF";

    a.addEventListener("click", async (e)=>{
      e.preventDefault();
      const url = await ensureObjectUrl(rec);
      if (!url){
        alert("Could not open file. If prompted, please grant read access.");
        return;
      }
      setViewer(rec.title || rec.filename, url);
    });
  };

  // Define robust saveResource that gracefully falls back to blob if handle cannot be stored
  window.saveResource = async function(rec){
    // Prefer saving to disk if blob present and FS API available
    const wantFS = !!window.showSaveFilePicker && rec && rec.blob instanceof Blob;
    if (wantFS){
      try{
        const handle = await window.showSaveFilePicker({
          suggestedName: rec.filename || rec.title || "lecture.pdf",
          types: [{ description: "PDF", accept: { "application/pdf": [".pdf"] } }]
        });
        const writable = await handle.createWritable();
        await writable.write(rec.blob);
        await writable.close();
        rec.handle = handle;
        rec.objectUrl = ""; // will be resolved lazily
        rec.blob = undefined;
        try {
          await idbPut(rec);       // attempt to store handle
        } catch(err){
          console.warn("Handle not storable, falling back to blob in IDB:", err && err.name);
          // Fall back to blob in IDB so it still works after refresh
          // Recreate blob by reading from handle
          try{
            const file = await handle.getFile();
            rec.blob = file;
            rec.handle = undefined;
            rec.objectUrl = "";
            await idbPut(rec);
          }catch(e2){
            console.warn("Fallback blob save failed:", e2);
          }
        }
      }catch(err){
        console.warn("User canceled or FS save failed:", err);
        // Fall through: keep blob in IDB
        if (!rec.blob){ /* keep as is */ }
        try { await idbPut(rec); } catch(e){ console.warn("IDB save failed:", e); }
      }
    } else {
      // No FS API: store blob in IDB and keep objectUrl for live view
      try { await idbPut(rec); } catch(e){ console.warn("IDB save failed:", e); }
    }
    // Always render or re-render list entry with forced "PDF" meta
    window.addResourceListItem(rec);
  };

  // Rebuild list AFTER everything (fixes earlier listeners/text like 'file')
  window.rebuildResources = async function(){
    const list = $("resources-list");
    if (!list) return;
    list.innerHTML = "";
    try{
      const items = await idbGetAll();
      items.sort((a,b)=> (b.createdAt||0) - (a.createdAt||0));
      for (const rec of items){
        // Normalize titles/mime
        if (!rec.title && rec.filename) rec.title = rec.filename;
        window.addResourceListItem(rec);
      }
    }catch(err){
      console.warn("rebuildResources error", err);
    }
  };

  window.addEventListener("load", ()=> {
    // Run our rebuild after all other DOMContentLoaded handlers
    window.rebuildResources();
  });
})();
</script>


<script type="text/plain" data-disabled="removed-compact-restore">
/* === Harden persistence: use IndexedDB blobs only; optional "Save Copy" per item === */
(function(){
  "use strict";
  const $ = (id) => document.getElementById(id);

  // UI helpers
  function ensureViewerOpen(){
    const wa = $("work-area");
    if (wa && !wa.classList.contains("viewer-open")) wa.classList.add("viewer-open");
  }
  function setViewer(title, url){
    ensureViewerOpen();
    const t = $("pdf-title");
    const f = $("pdf-iframe");
    if (t) t.textContent = title || "Lecture Viewer";
    if (f){
      f.removeAttribute("srcdoc");
      f.src = url || "about:blank";
    }
  }
  const fileExt = (name="") => {
    const m = String(name).toLowerCase().match(/\.([a-z0-9]+)(?:\?.*)?$/);
    return m ? m[1] : "";
  };

  // Request durable storage
  (async ()=>{
    if (navigator.storage && navigator.storage.persist){
      try { await navigator.storage.persist(); } catch(_){}
    }
  })();

  // === IndexedDB (blob) ===
  const DB_NAME = "quizViewerDB";
  const DB_STORE = "resources";
  function openDB(){
    return new Promise((resolve,reject)=>{
      const req = indexedDB.open(DB_NAME, 5);
      req.onupgradeneeded = ()=>{
        const db = req.result;
        if (!db.objectStoreNames.contains(DB_STORE)){
          const store = db.createObjectStore(DB_STORE, { keyPath: "id" });
          store.createIndex("createdAt", "createdAt", { unique: false });
        }
      };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }
  async function idbPut(rec){
    const db = await openDB();
    await new Promise((resolve,reject)=>{
      const tx = db.transaction(DB_STORE, "readwrite");
      tx.objectStore(DB_STORE).put(rec);
      tx.oncomplete = resolve;
      tx.onerror = ()=> reject(tx.error);
    });
  }
  async function idbGetAll(){
    const db = await openDB();
    return await new Promise((resolve,reject)=>{
      const tx = db.transaction(DB_STORE, "readonly");
      const req = tx.objectStore(DB_STORE).getAll();
      req.onsuccess = ()=> resolve(req.result || []);
      req.onerror = ()=> reject(req.error);
    });
  }

  // Build list item with forced "PDF" label + Save Copy button
  function addResourceListItem(rec){
    const list = $("resources-list");
    if (!list) return;
    const li = document.createElement("li");
    const a = document.createElement("a");
    a.className = "resources-link";
    a.href = "#";
    a.setAttribute("data-view", "");
    a.innerHTML = '<span class="resources-title"></span><span class="resources-meta">PDF</span>';
    li.appendChild(a);

    // Save copy button
    const saveBtn = document.createElement("button");
    saveBtn.textContent = "Save copy";
    saveBtn.className = "ml-2 px-2 py-1 text-xs rounded border";
    saveBtn.addEventListener("click", async (e)=>{
      e.preventDefault();
      e.stopPropagation();
      try{
        const blob = rec.blob instanceof Blob ? rec.blob : null;
        if (!blob){
          // Try to fetch objectUrl or reconstruct from IDB by reloading record
          try {
            const all = await idbGetAll();
            const found = all.find(r => r.id === rec.id);
            if (found && found.blob instanceof Blob){
              const url = URL.createObjectURL(found.blob);
              downloadBlob(found.filename || found.title || "lecture.pdf", found.blob, url);
              return;
            }
          } catch(_) {}
          alert("No local blob available to save. Re-upload to save a copy.");
          return;
        }
        const url = URL.createObjectURL(blob);
        downloadBlob(rec.filename || rec.title || "lecture.pdf", blob, url);
      }catch(err){
        console.warn("Save copy failed", err);
      }
    });
    li.appendChild(saveBtn);

    list.prepend(li);
    const tt = a.querySelector(".resources-title");
    tt.textContent = rec.title || rec.filename || "PDF";

    a.addEventListener("click", async (e)=>{
      e.preventDefault();
      // Build object URL from blob (always) for reliability
      try{
        const blob = rec.blob instanceof Blob ? rec.blob : null;
        if (!blob){
          // Reload from IDB if this in-memory copy was lost
          const all = await idbGetAll();
          const found = all.find(r => r.id === rec.id);
          if (found && found.blob instanceof Blob){
            rec = found;
          }
        }
        if (rec.blob instanceof Blob){
          const url = URL.createObjectURL(rec.blob);
          setViewer(rec.title || rec.filename, url);
        } else {
          alert("Could not open this item. Please re-upload it with this version so it persists.");
        }
      }catch(err){
        console.warn("Open failed", err);
      }
    });
  }

  function downloadBlob(filename, blob, objUrl){
    const a = document.createElement("a");
    a.href = objUrl;
    a.download = filename || "lecture.pdf";
    document.body.appendChild(a);
    a.click();
    a.remove();
    // Don't revoke immediately; allow download to start
    setTimeout(()=> URL.revokeObjectURL(objUrl), 2000);
  }

  async function rebuildResources(){
    const list = $("resources-list");
    if (!list) return;
    list.innerHTML = "";
    try{
      const items = await idbGetAll();
      items.sort((a,b)=> (b.createdAt||0) - (a.createdAt||0));
      for (const rec of items){
        // Normalize title/mime, and drop any FS handles from earlier versions
        if (!rec.title && rec.filename) rec.title = rec.filename;
        if (rec.handle) delete rec.handle;
        addResourceListItem(rec);
      }
    }catch(err){
      console.warn("rebuildResources error", err);
    }
  }

  

  // Override global saveResource to *always* store blob in IDB
  window.saveResource = async function(rec){
    try{
      await idbPut(rec);
      addResourceListItem(rec);
    }catch(err){
      console.warn("IDB save failed:", err);
      alert("Your browser blocked saving this file for persistence. Try running the page from http://localhost/ instead of file://");
    }
  };

  // Override global handleFiles to ensure we always keep a blob for persistence
  window.handleFiles = async function(files){
    const ifr = $("pdf-iframe");
    const titleEl = $("pdf-title");
    const nowId = () => Date.now() + "-" + Math.random().toString(36).slice(2);

    for (const f of files){
      const ext = fileExt(f.name);
      if (ext === "pdf"){
        const url = URL.createObjectURL(f);
        setViewer(f.name, url);
        const rec = {
          id: nowId(),
          title: f.name,
          filename: f.name,
          createdAt: Date.now(),
          mime: "application/pdf",
          blob: f,
          source: "upload"
        };
        await window.saveResource(rec);
      } else if (ext === "ppt" || ext === "pptx"){
        if (titleEl) titleEl.textContent = "Converting to PDF…";
        if (ifr){
          ensureViewerOpen();
          ifr.removeAttribute("src");
          ifr.srcdoc = '<!doctype html><html><body style="margin:0;display:flex;align-items:center;justify-content:center;height:100vh;font:16px system-ui">Converting to PDF…
<!-- PATCH: Compact Mode sync with new JSON imports -->
<script>
(function(){
  try{
    var d = document;
    function getKeys(){
      var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
      var SKEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz');
      return {
        QKEY: QKEY,
        BASE: QKEY + '_baseFullSet',
        BACKUP: QKEY + '_backupCompactOrig',
        CONF: SKEY + '_compactConfidence',
        MARK_SIG: SKEY + '_compactMarkSig',
        MARK_HASH: SKEY + '_compactMarkHash'
      };
    }
    function isValidQuestions(raw){
      if(!raw) return false;
      try{
        var arr = JSON.parse(raw);
        return Array.isArray(arr) && arr.length > 0;
      }catch(_e){ return false; }
    }
    function resetCompactCaches(){
      var K = getKeys();
      try{ localStorage.removeItem(K.BASE); }catch(_e){}
      try{ localStorage.removeItem(K.BACKUP); }catch(_e){}
      try{ localStorage.removeItem(K.CONF); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_SIG); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_HASH); }catch(_e){}
    }
    function rebuildIfOpen(){
      var ov = d.getElementById('compact-overlay');
      if(ov && ov.style && ov.style.display !== 'none'){
        // Close and re-open to force a fresh build from new data
        ov.style.display = 'none';
        var cb = d.getElementById('compact-btn');
        if(cb && cb.click){
          setTimeout(function(){ cb.click(); }, 50);
        }
      }
    }
    function syncNow(){
      var K = getKeys();
      var raw = localStorage.getItem(K.QKEY);
      if(!isValidQuestions(raw)) return;
      // Clear caches so Compact Mode rebuilds against the new set
      resetCompactCaches();
      // Optionally prime BASE with the new set so Focus/Restore works immediately
      try{ localStorage.setItem(K.BASE, raw); }catch(_e){}
      try{ localStorage.setItem(K.BACKUP, raw); }catch(_e){}
      rebuildIfOpen();
    }
    function hookImport(){
      var importBtn = d.getElementById('import-load-json') || d.getElementById('importLoad');
      var fileInput = d.getElementById('import-json-file') || d.getElementById('importJSON');
      function schedule(){ setTimeout(syncNow, 600); }
      if(importBtn && !importBtn.__cmSync1){
        importBtn.__cmSync1 = true;
        importBtn.addEventListener('click', schedule, true);
      }
      if(fileInput && !fileInput.__cmSync2){
        fileInput.__cmSync2 = true;
        fileInput.addEventListener('change', schedule, true);
      }
      // Also listen to storage changes for QUESTIONS_KEY updates
      if(!window.__cmSyncStorage){
        window.__cmSyncStorage = true;
        window.addEventListener('storage', function(e){
          var K = getKeys();
          if(e && e.key === K.QKEY) syncNow();
        });
      }
    }
    function boot(){
      hookImport();
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    } else {
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();
</script><script type="text/plain" data-disabled="removed-compact-restore">
(function(){
  try{
    var d = document;
    function getKeys(){
      var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
      var SKEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz');
      return {
        QKEY: QKEY,
        BASE: QKEY + '_baseFullSet',
        BACKUP: QKEY + '_backupCompactOrig',
        CONF: SKEY + '_compactConfidence',
        MARK_SIG: SKEY + '_compactMarkSig',
        MARK_HASH: SKEY + '_compactMarkHash'
      };
    }
    function isValidQuestions(raw){
      if(!raw) return false;
      try{
        var arr = JSON.parse(raw);
        return Array.isArray(arr) && arr.length > 0;
      }catch(_e){ return false; }
    }
    function resetCompactCaches(){
      var K = getKeys();
      try{ localStorage.removeItem(K.BASE); }catch(_e){}
      try{ localStorage.removeItem(K.BACKUP); }catch(_e){}
      try{ localStorage.removeItem(K.CONF); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_SIG); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_HASH); }catch(_e){}
    }
    function rebuildIfOpen(){
      var ov = d.getElementById('compact-overlay');
      if(ov && ov.style && ov.style.display !== 'none'){
        // Close and re-open to force a fresh build from new data
        ov.style.display = 'none';
        var cb = d.getElementById('compact-btn');
        if(cb && cb.click){
          setTimeout(function(){ cb.click(); }, 50);
        }
      }
    }
    function syncNow(){
      var K = getKeys();
      var raw = localStorage.getItem(K.QKEY);
      if(!isValidQuestions(raw)) return;
      // Clear caches so Compact Mode rebuilds against the new set
      resetCompactCaches();
      // Optionally prime BASE with the new set so Focus/Restore works immediately
      try{ localStorage.setItem(K.BASE, raw); }catch(_e){}
      try{ localStorage.setItem(K.BACKUP, raw); }catch(_e){}
      rebuildIfOpen();
    }
    function hookImport(){
      var importBtn = d.getElementById('import-load-json') || d.getElementById('importLoad');
      var fileInput = d.getElementById('import-json-file') || d.getElementById('importJSON');
      function schedule(){ setTimeout(syncNow, 600); }
      if(importBtn && !importBtn.__cmSync1){
        importBtn.__cmSync1 = true;
        importBtn.addEventListener('click', schedule, true);
      }
      if(fileInput && !fileInput.__cmSync2){
        fileInput.__cmSync2 = true;
        fileInput.addEventListener('change', schedule, true);
      }
      // Also listen to storage changes for QUESTIONS_KEY updates
      if(!window.__cmSyncStorage){
        window.__cmSyncStorage = true;
        window.addEventListener('storage', function(e){
          var K = getKeys();
          if(e && e.key === K.QKEY) syncNow();
        });
      }
    }
    function boot(){
      hookImport();
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    } else {
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();
</script>


<!-- PATCH: Compact Mode sync — include welcome Import button -->
<script type="text/plain" data-disabled="import-popup" type="text/plain" data-disabled="removed-compact-restore">
(function(){
  try{
    var d = document;
    function getKeys(){
      var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
      var SKEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz');
      return {
        QKEY: QKEY,
        BASE: QKEY + '_baseFullSet',
        BACKUP: QKEY + '_backupCompactOrig',
        CONF: SKEY + '_compactConfidence',
        MARK_SIG: SKEY + '_compactMarkSig',
        MARK_HASH: SKEY + '_compactMarkHash'
      };
    }
    function isValidQuestions(raw){
      if(!raw) return false;
      try{ var arr = JSON.parse(raw); return Array.isArray(arr) && arr.length > 0; }catch(_e){ return false; }
    }
    function resetCompactCaches(){
      var K = getKeys();
      try{ localStorage.removeItem(K.BASE); }catch(_e){}
      try{ localStorage.removeItem(K.BACKUP); }catch(_e){}
      try{ localStorage.removeItem(K.CONF); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_SIG); }catch(_e){}
      try{ localStorage.removeItem(K.MARK_HASH); }catch(_e){}
    }
    function rebuildIfOpen(){
      var ov = d.getElementById('compact-overlay');
      if(ov && ov.style && ov.style.display !== 'none'){
        ov.style.display = 'none';
        var cb = d.getElementById('compact-btn');
        if(cb && cb.click){ setTimeout(function(){ cb.click(); }, 50); }
      }
    }
    function syncNow(){
      var K = getKeys();
      var raw = localStorage.getItem(K.QKEY);
      if(!isValidQuestions(raw)) return false;
      resetCompactCaches();
      try{ localStorage.setItem(K.BASE, raw); }catch(_e){}
      try{ localStorage.setItem(K.BACKUP, raw); }catch(_e){}
      rebuildIfOpen();
      return true;
    }
    function startImportPoll(){
      var K = getKeys();
      var t0 = Date.now();
      (function tick(){
        var ok = syncNow();
        if(!ok && Date.now() - t0 < 6000){ setTimeout(tick, 200); }
      })();
    }
    function hookWelcomeImport(){
      var openImport = d.getElementById('import-btn'); // welcome import button also uses this id
      if(openImport && !openImport.__cmWelcomeHook){
        openImport.__cmWelcomeHook = true;
        openImport.addEventListener('click', function(){ setTimeout(startImportPoll, 0); }, true);
      }
      var fileInput = d.getElementById('import-json-file') || d.getElementById('importJSON');
      if(fileInput && !fileInput.__cmWelcomeFile){
        fileInput.__cmWelcomeFile = true;
        fileInput.addEventListener('change', function(){ setTimeout(startImportPoll, 0); }, true);
      }
      var loadBtn = d.getElementById('import-load-json') || d.getElementById('importLoad');
      if(loadBtn && !loadBtn.__cmWelcomeLoad){
        loadBtn.__cmWelcomeLoad = true;
        loadBtn.addEventListener('click', function(){ setTimeout(startImportPoll, 0); }, true);
      }
    }
    function boot(){
      hookWelcomeImport();
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    } else {
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();
</script>


<!-- PATCH: Auto-resize quiz card when explanation shows/hides -->
<script>
(function(){
  try{
    var d = document;
    function adjustQuizHeight(){
      var quiz = d.getElementById('quiz-card');
      var exp = d.getElementById('explanation');
      if(!quiz || !exp) return;
      // Measure by letting height be auto briefly, then lock to measured content
      var prevPos = quiz.style.position;
      var prevH = quiz.style.height;
      // Keep fixed positioning (used by the layout), but clear height to compute content
      // Some builds set position fixed; if not set inline, reading style returns '' which we won't change.
      try{
        // Temporarily clear height to allow natural content size
        quiz.style.height = '';
        // Force reflow
        void quiz.offsetHeight;
        var needed = Math.max(200, quiz.scrollHeight);
        // Reapply explicit height to match content so the explanation is fully visible
        quiz.style.height = needed + 'px';
        // If the app re-applies user sizes, keep dataset.userHeight in sync so it won't revert
        if(quiz.dataset) quiz.dataset.userHeight = quiz.style.height;
      }catch(_e){
        // Fallback: leave as-is
        quiz.style.height = prevH;
      }
    }
    function onMutation(){
      // Debounce adjustments during rapid DOM updates
      if(onMutation.t){ cancelAnimationFrame(onMutation.t); }
      onMutation.t = requestAnimationFrame(adjustQuizHeight);
    }
    function boot(){
      var exp = d.getElementById('explanation');
      if(!exp) return;
      // Observe explanation content/visibility changes
      try{
        var mo = new MutationObserver(onMutation);
        mo.observe(exp, { attributes:true, childList:true, subtree:true });
      }catch(_e){}
      // Also run once on load and after small delay to catch initial show
      setTimeout(adjustQuizHeight, 0);
      setTimeout(adjustQuizHeight, 300);
    }
    if(d.readyState === 'loading'){
      d.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    } else {
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();
</script>


<style id="dark-theme-overrides">
/* Darker theme overrides */
:root{
  --bg:#060a12;
  --bd:#1b2230;
}
body{ background:#060a12 !important; color:#e5e7eb; }
#quiz-card{ background:#0f172a !important; border-color:#0b1220 !important; }
.choice{ background:#172033 !important; border-color:#243045 !important; color:#e5e7eb !important; }
.choice:hover{ background:#111a2a !important; }
#evidence-panel{ background:rgba(10,15,26,.65) !important; border-color:#1b2230 !important; }
#pdf-pane{ background:#0a0f1a !important; border-color:#1b2230 !important; }
#pdf-controls button, #pdf-controls input[type="range"]{ border-color:#273246 !important; }
#progress-mini{ background:rgba(255,255,255,.06) !important; }
#progress-mini > i{ background-image:var(--g); }
/* Make the PDF title match the Upload Lectures button (pill + gradient text) */
#pdf-title{
  display:inline-flex; align-items:center; gap:.5rem;
  padding:.45rem .8rem; border-radius:12px;
  border:1px solid rgba(255,255,255,.22);
  background:rgba(255,255,255,.06);
  backdrop-filter:blur(10px);
  font-weight:800; letter-spacing:.01em;
  background-image:var(--g);
  -webkit-background-clip:text; background-clip:text; color:transparent;
  text-shadow:0 0 18px rgba(167,139,250,.25);
}
</style>



<style id="remove-compact-restore-css">
#compact-btn,#restore-original-btn,#compact-overlay { 
  display:none !important; 
  visibility:hidden !important; 
  pointer-events:none !important;
}
</style>

<script id="feature-removals">
(function(){
  function noop(){}
  var d=document;
  var BAD_IDS = ['welcome-overlay','open-tab-btn','compact-btn','restore-original-btn','resources-panel','viewer-toggle-btn','compact-overlay'];

  function nuke(id){
    try{ var el=d.getElementById(id); if(el&&el.parentNode) el.parentNode.removeChild(el);}catch(_e){}
  }
  BAD_IDS.forEach(nuke);

  // Observe DOM and remove if re-created
  try{
    var mo=new MutationObserver(function(muts){
      for(var i=0;i<BAD_IDS.length;i++){ nuke(BAD_IDS[i]); }
    });
    mo.observe(d.documentElement,{childList:true,subtree:true});
  }catch(_e){}

  // Hijack getElementById/querySelector for banned ids
  try{
    var _gid=d.getElementById.bind(d), _qs=d.querySelector.bind(d);
    d.getElementById=function(id){
      if(id && BAD_IDS.indexOf(String(id))>=0){ return null; }
      return _gid(id);
    };
    d.querySelector=function(sel){
      try{
        if(typeof sel==='string' && /#(compact-btn|restore-original-btn|compact-overlay)\b/i.test(sel)) return null;
      }catch(_e){}
      return _qs(sel);
    };
  }catch(_e){}

  // Neutralize any globals that might be defined by disabled scripts
  try{ window.ensureCompactButton=noop; }catch(_e){}
  try{ window.openOverlay=noop; }catch(_e){}
  try{ window.startFocusQuiz=noop; }catch(_e){}
  try{ window.restoreOriginalQuiz=noop; }catch(_e){}
  try{ window.deepResetAndRestore=noop; }catch(_e){}
  try{ window.open=function(){ return null; }; }catch(_e){}

  // Force uploads to go straight into viewer
  try{
    window.addResourceEntry=function(name,url){
      try{
        var iframe=d.getElementById('pdf-iframe'); var titleEl=d.getElementById('pdf-title');
        if(iframe && url){ iframe.src=url; }
        if(titleEl){ titleEl.textContent = name || 'Lecture Viewer'; }
      }catch(_e){}
    };
    window.openInViewer=window.addResourceEntry;
  }catch(_e){}
})();
</script>

<style id="review-theme-overrides">
/* Make Quiz Review match Upload Lectures */
#review-menu-btn{
  margin:.4rem .4rem 0 0 !important;
  display:inline-flex !important;
  align-items:center !important;
  gap:.5rem !important;
  padding:.45rem .8rem !important;
  border-radius:12px !important;
  border:1px solid rgba(255,255,255,.22) !important;
  background:rgba(255,255,255,.06) !important;
  backdrop-filter:blur(10px) !important;
  font-weight:800 !important;
  letter-spacing:.01em !important;
  background-image:var(--g) !important;
  -webkit-background-clip:text !important;
  background-clip:text !important;
  color:transparent !important;
  text-shadow:0 0 18px rgba(96,165,250,.25) !important;
}

#review-menu{
  background:rgba(8,12,22,.92) !important;
  border:1px solid rgba(255,255,255,.1) !important;
  box-shadow:0 18px 44px rgba(0,0,0,.55) !important;
  backdrop-filter:blur(12px) !important;
}

#review-menu .tools-row .tools-label,
#review-menu h3{
  font-weight:800;
  letter-spacing:.01em;
  background-image:var(--g);
  -webkit-background-clip:text;
  background-clip:text;
  color:transparent;
  text-shadow:0 0 18px rgba(167,139,250,.25);
}
#review-menu .tools-btn{
  padding:.45rem .8rem;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.04);
  color:#e5e7eb;
}
#review-menu .tools-btn:hover{
  background:rgba(255,255,255,.08);
}
</style>

<script id="kb-shortcuts">
(function(){
  // Restore A/B/C/D, ←/→, Enter shortcuts
  var d=document;
  function isTypingTarget(el){
    if(!el) return false;
    var tag = el.tagName ? el.tagName.toLowerCase() : '';
    if(tag==='input' || tag==='textarea' || el.isContentEditable) return true;
    return false;
  }
  function clickIf(el){
    try{ if(el && typeof el.click==='function'){ el.click(); return true; } }catch(_e){}
    return false;
  }
  function getChoices(){
    try{ return Array.prototype.slice.call(d.querySelectorAll('#choices .choice')); }catch(_e){ return []; }
  }
  function handleLetter(idx){
    var ch = getChoices();
    if(ch[idx]){ clickIf(ch[idx]); }
  }
  function handleEnter(){
    // Prefer "Next" if present & enabled; otherwise click a "reveal/check" if your UI has one
    var next = d.getElementById('next-btn');
    if(next && !next.disabled){ if(clickIf(next)) return; }
    var reveal = d.getElementById('reveal-btn') || d.querySelector('[data-action="reveal"]');
    if(reveal){ clickIf(reveal); }
  }
  function handleArrow(dir){
    var id = dir<0 ? 'prev-btn' : 'next-btn';
    var btn = d.getElementById(id);
    if(btn && !btn.disabled){ clickIf(btn); }
  }
  d.addEventListener('keydown', function(ev){
    if(ev.defaultPrevented) return;
    if(ev.ctrlKey || ev.metaKey || ev.altKey) return;
    if(isTypingTarget(ev.target)) return;
    var k = ev.key || '';
    var low = k.toLowerCase();
    if(low==='a'){ handleLetter(0); ev.preventDefault(); }
    else if(low==='b'){ handleLetter(1); ev.preventDefault(); }
    else if(low==='c'){ handleLetter(2); ev.preventDefault(); }
    else if(low==='d'){ handleLetter(3); ev.preventDefault(); }
    else if(k==='ArrowLeft'){ handleArrow(-1); ev.preventDefault(); }
    else if(k==='ArrowRight'){ handleArrow(1); ev.preventDefault(); }
    else if(k==='Enter'){ handleEnter(); ev.preventDefault(); }
  }, true);
})();
</script>

<style id="answer-state-colors">
/* Ensure green/red for correct/incorrect override dark theme */
.choice.correct{
  border-color:#22c55e !important; /* emerald-500 */
  background:#14532d !important;   /* emerald-900 */
  color:#e5e7eb !important;
}
.choice.incorrect{
  border-color:#ef4444 !important; /* red-500 */
  background:#7f1d1d !important;   /* red-900 */
  color:#e5e7eb !important;
}
/* Optional: keep hover from muting the colors when already marked */
.choice.correct:hover{ background:#14532d !important; }
.choice.incorrect:hover{ background:#7f1d1d !important; }
</style>









<style id="pdf-close-css">
#pdf-pane{ position: relative; }
#pdf-close-btn{
  position:absolute; top:6px; right:6px;
  display:inline-flex; align-items:center; justify-content:center;
  width:28px; height:28px; border-radius:8px;
  background:white; color:#1f2937; font-weight:900;
  border:1px solid rgba(0,0,0,.1); cursor:pointer;
  box-shadow:0 2px 8px rgba(0,0,0,.25);
  user-select:none;
}
#pdf-close-btn:hover{ transform: translateY(-1px); }
#pdf-close-icon{ pointer-events:none; line-height:1; font-size:16px; }
</style>

<script id="recenter-on-close">
(function(){
  var d=document;
  function $(id){ return d.getElementById(id); }
  function ensureClose(){
    var pane = $('pdf-pane');
    if(!pane) return;
    var btn = $('pdf-close-btn');
    if(!btn){
      btn = d.createElement('button');
      btn.id = 'pdf-close-btn';
      var span = d.createElement('span');
      span.id = 'pdf-close-icon';
      span.textContent = '×';
      btn.appendChild(span);
      pane.insertBefore(btn, pane.firstChild);
    }
  }
  function closeNow(){
    try{
      var work=$('work-area'), pane=$('pdf-pane'), quiz=$('quiz-card');
      if(work){ work.classList.remove('viewer-open'); }
      if(pane){ pane.style.display='none'; } // keep display none
      if(quiz){
        quiz.style.position='';
        quiz.style.left='';
        quiz.style.top='';
        quiz.style.width='';
        quiz.style.height='';
        quiz.style.margin='0 auto';
        quiz.style.transform='';
        quiz.style.transition='';
        quiz.style.willChange='';
      }
    }catch(_e){}
  }
  // Initial ensure
  if(document.readyState === 'loading'){
    d.addEventListener('DOMContentLoaded', ensureClose, {once:true});
  }else{
    ensureClose();
  }
  // If pane gets shown again, ensure there's a button
  try{
    var pane = $('pdf-pane');
    if(pane){
      var mo = new MutationObserver(function(){
        ensureClose();
      });
      mo.observe(pane, { childList:true, subtree:true, attributes:true });
    }
  }catch(_e){}
  // Global click handler for the X
  d.addEventListener('click', function(ev){
    var el = ev.target;
    if(el && el.closest && el.closest('#pdf-close-btn')){
      ev.preventDefault();
      closeNow();
    }
  }, true);
})();
</script>

















<style id="layout-overrides">
/* Keep Upload Lectures and its adjacent actions on one line */
#upload-lectures-btn{ display:inline-flex; vertical-align:middle; }
#top-actions{
  display:inline-flex; vertical-align:middle; gap:10px; margin-left:10px;
}
/* Make sure old toolbar (if exists) is hidden */
#persistent-controls{ display:none !important; }

/* Center the Save button at the bottom of the quiz card */
#quiz-card{ position:relative; }
#save-btn{
  position:absolute !important;
  left:50% !important; transform:translateX(-50%) !important;
  bottom:14px !important;
  z-index:5;
}
/* Give bottom area some extra padding so Save doesn't overlap content */
#quiz-card .content, #quiz-card .question, #quiz-card .choices{
  padding-bottom:56px;
}
/* On very small screens, fallback to normal flow so it doesn't overlap */
@media (max-width: 560px){
  #save-btn{ position:static !important; transform:none !important; margin:8px auto 0 !important; display:inline-flex !important; }
}
</style>

<script id="layout-manager">
(function(){
  var d=document;
  function $(id){ return d.getElementById(id); }

  function placeTopActions(){
    try{
      var up = $('upload-lectures-btn');
      if(!up || !up.parentNode) return;
      var ta = $('top-actions');
      if(!ta){
        ta = d.createElement('span');
        ta.id = 'top-actions';
        if(up.nextSibling){
          up.parentNode.insertBefore(ta, up.nextSibling);
        }else{
          up.parentNode.appendChild(ta);
        }
      }
      ['import-btn','review-menu-btn','instr-btn'].forEach(function(id){
        var el = $(id);
        if(!el) return;
        el.hidden = false;
        el.style.display = 'inline-flex';
        el.style.position = 'static';
        el.style.left = el.style.right = el.style.top = el.style.bottom = '';
        el.style.transform = 'none';
        el.style.margin = '0';
        if(el.parentElement !== ta){
          ta.appendChild(el);
        }
      });
    }catch(_e){}
  }

  // Remove any old persistent toolbar node if present
  function nukeOldToolbar(){
    var old = $('persistent-controls');
    if(old && old.parentNode) try{ old.parentNode.removeChild(old); }catch(_e){}
  }

  function init(){
    nukeOldToolbar();
    placeTopActions();
  }

  if(d.readyState === 'loading'){
    d.addEventListener('DOMContentLoaded', init, {once:true});
  }else{
    init();
  }

  // Keep layout steady when viewer opens/closes or DOM churns
  try{
    var work = $('work-area');
    if(work){
      var mo = new MutationObserver(function(muts){
        placeTopActions();
      });
      mo.observe(work, {attributes:true});
    }
  }catch(_e){}

  try{
    var docMo = new MutationObserver(function(){ placeTopActions(); });
    docMo.observe(d.documentElement, {childList:true, subtree:true});
  }catch(_e){}
})();
</script>









<style id="top-pills-hard-unify">
:is(#upload-lectures-btn,#import-btn,#review-menu-btn,#instr-btn),
:is(#upload-lectures-btn,#import-btn,#review-menu-btn,#instr-btn):hover,
:is(#upload-lectures-btn,#import-btn,#review-menu-btn,#instr-btn):focus{
  box-sizing: border-box !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  gap: .5rem !important;
  padding: .45rem .8rem !important;
  min-height: 36px !important;
  border-radius: 12px !important;
  border: 1px solid rgba(255,255,255,.22) !important;
  background: rgba(255,255,255,.06) !important;
  backdrop-filter: blur(10px) !important;
  -webkit-backdrop-filter: blur(10px) !important;

  /* Typography to match exactly */
  font-weight: 800 !important;
  letter-spacing: .01em !important;
  line-height: 1.25 !important;
  font-size: inherit !important;

  /* Gradient text like Upload Lectures */
  background-image: var(--g) !important;
  -webkit-background-clip: text !important;
  background-clip: text !important;
  color: transparent !important;
  text-shadow: 0 0 18px rgba(167,139,250,.25) !important;

  /* Remove any stray styles from older CSS */
  box-shadow: none !important;
  outline: none !important;
  text-transform: none !important;
  filter: none !important;
}

/* Consistent hover surface (glass stays subtle) */
:is(#upload-lectures-btn,#import-btn,#review-menu-btn,#instr-btn):hover{
  background: rgba(255,255,255,.10) !important;
  background-image: var(--g) !important; /* keep gradient text */
}

/* Normalize any inner spans/icons for alignment */
#upload-lectures-btn > *, #import-btn > *,
#review-menu-btn > *, #instr-btn > *{
  display: inline-flex; align-items: center;
}

/* If any of these had absolute/floating positions elsewhere, kill them */
#upload-lectures-btn, #import-btn, #review-menu-btn, #instr-btn{
  position: static !important;
  left: auto !important; right: auto !important; top: auto !important; bottom: auto !important;
  margin: 0 !important;
  transform: none !important;
}
</style>





<style id="import-direct-css">
/* Hide legacy import popup/menu while keeping its elements alive for logic */
#import-menu{ display:none !important; visibility:hidden !important; }
</style>

<script id="import-direct-js">
(function(){
  var d=document;
  function $(id){ return d.getElementById(id); }

  function wireDirectImport(){
    var btn = $('import-btn');
    var fileInput = $('import-json-file');
    var loadBtn = $('import-load-json');
    if(!btn || !fileInput || !loadBtn) return;

    // Limit to JSON only
    try{ fileInput.setAttribute('accept','.json,application/json'); }catch(_e){}

    // Replace existing click handlers on Import button to avoid toggling popup
    var clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);
    btn = $('import-btn');

    // When clicking Import, open file picker
    btn.addEventListener('click', function(ev){
      ev.preventDefault();
      try{ fileInput.value = ''; }catch(_e){}
      fileInput.click();
    }, true);

    // When a file is chosen, trigger the app's importer
    fileInput.addEventListener('change', function(){
      // If the app expects clicking the "Load" button, call its onclick
      if(typeof loadBtn.onclick === 'function'){
        try{ loadBtn.onclick(); }catch(_e){}
      }else{
        // Fallback: synthesize a click
        try{ loadBtn.click(); }catch(_e){}
      }
    }, true);
  }

  if(document.readyState === 'loading'){
    d.addEventListener('DOMContentLoaded', wireDirectImport, {once:true});
  }else{
    wireDirectImport();
  }
})();
</script>
</body></html>';
        }
        try{
          const conv = await (window.convertWithBackend ? window.convertWithBackend(f) : Promise.reject(new Error("Converter missing")));
          // Fetch blob back
          const blob = await fetch(conv.url).then(r=> r.blob());
          const title = (f.name || "PPTX").replace(/\.(pptx?|PPTX?)$/, ".pdf");
          setViewer(title, conv.url);
          const rec = {
            id: nowId(),
            title,
            filename: title,
            createdAt: Date.now(),
            mime: "application/pdf",
            blob,
            source: "converted"
          };
          await window.saveResource(rec);
        }catch(err){
          alert("Upload error: " + (err && err.message ? err.message : String(err)));
          if (ifr){ ifr.removeAttribute("srcdoc"); }
        }
      }
    }
  };
})();
</script>


<script type="text/plain" data-disabled="removed-compact-restore">
/* Ensure the "PDF lectures" list gets populated even if it's rendered later */
(function(){
  "use strict";
  const $ = (id) => document.getElementById(id);

  // Avoid double-hydration
  let hydratedOnce = false;

  async function tryHydrate(){
    if (hydratedOnce) return;
    const list = $("resources-list");
    if (!list) return;
    hydratedOnce = true;
    if (typeof window.rebuildResources === "function"){
      await window.rebuildResources();
    }
  }

  // 1) Try on DOMContentLoaded and load
  document.addEventListener("DOMContentLoaded", tryHydrate, { once: true });
  window.addEventListener("load", tryHydrate, { once: true });

  // 2) MutationObserver: watch for the list to appear later
  const obs = new MutationObserver(()=> { tryHydrate(); });
  obs.observe(document.documentElement, { childList: true, subtree: true });

  // 3) Fallback: on any click (e.g., opening the Lecture PDFs tab), attempt hydration
  document.addEventListener("click", ()=> { tryHydrate(); }, true);

  // 4) Timed retries for good measure (covers lazy UI frameworks)
  let attempts = 0;
  const intervalId = setInterval(()=>{
    if (hydratedOnce || attempts++ > 30){ clearInterval(intervalId); return; }
    tryHydrate();
  }, 500);
})();


// PATCH: Update instructions content
(function(){ 
  try{
    var __inTxt = "\nROLE\nYou are a quiz generator for my dental/medical slides. Follow this spec EXACTLY. MAKE SURE TO RETURN NOTHING BUT A JSON FILE AS YOUR RESPONSE FOR DOWNLOAD. \n\nSCOPE & SOURCES\n- Use ONLY the lecture file(s) (PDF/PPT/PPTX) I upload in THIS chat. No outside facts, no guessing.\n- Match slide terminology EXACTLY; do not introduce synonyms or pronunciations.\n\nCOVERAGE, ORDER & COUNT\n- Be EXHAUSTIVE for the assigned slides.\n- Keep questions in the SAME chronological order as the slides. This is a very important step, make sure to obey it (very important!)\n- Minimum of 100 questions per set unless I explicitly request a different number. Stop exactly at the requested count.\n\nDELIVERY (VERY IMPORTANT)\n- Return ONE valid JSON array of question objects as a download for me in the chat (this is also very important, make sure to follow this!). Nothing before or after (no prose, no code fences, no comments).\n\nJSON SCHEMA (STRICT)\nEach question object MUST include:\n- \"q\": string \u2014 the stem (self\u2011contained; use slide language for precision).\n- \"c\": array of 4 strings \u2014 EXACTLY four choices.\n- \"a\": integer \u2014 the index (0\u20133) of the correct choice in \"c\".\n- \"e\": string \u2014 concise explanation using slide wording; mention the specific feature/relationship/number that decides the answer.\n- \"w\": array of 4 strings \u2014 one short rationale for why each choice in \"c\" is wrong (same order as \"c\"). Make sure to include actual reason. not just \"not supported by slides\" or anything like that. You may use the internet if the slides do not include information on it, but this is the only time I allow you to go beyond the lecture itself.\n- \"add\": string \u2014 Evidence panel content: slide number(s) + the exact short phrase(s) copied from the slide that justify the answer. Make sure to add the evidence only under this panel, nowhere else (this is very important ) \n- OPTIONAL image media (enable when helpful):\n  \u2022 Shorthand: \"img\": \"<DATA URL>\"\n  \u2022 Preferred: \"_media\": { \"img\": { \"src\": \"<DATA URL>\", \"alt\": \"...\", \"credit\": \"Course slide\", \"license\": \"Educational use\" } }\n\n\nWRITING RULES\n- Exactly one correct answer; three plausible distractors. Keep options parallel in form and length; avoid cues.\n- Positive phrasing unless the slide stresses exceptions.\n- Include some \"none of the above\" or \"all of the above\" or \"except\" questions.\n- Use exact slide conventions: names, landmarks, units, numbers, and \u201cname\u2011change\u201d boundaries (e.g., subclavian\u2192axillary at the lateral border of the 1st rib; axillary\u2192brachial at the inferior border of teres major) when relevant.\n- Prefer clinically meaningful/application stems when slides support them.\n- If a slide is image\u2011only or scanned, you may still ask identification/label questions; otherwise note key observable features.\n- DO NOT produce duplicate questions. This is very important, make sure that you do not generate the same question multiple times. \n\nVALIDATION CHECKS (BEFORE RETURNING JSON)\n- Exactly 4 choices per item.\n- \"a\" is 0, 1, 2, or 3 and matches the correct choice in \"c\".\n- \"w\" has 4 entries in the same order as \"c\".\n- No duplicate choices/placeholders (\u201cOption 1\u201d etc.).\n- Preserve slide order across questions.\n- For image items: ensure the DATA URL renders (valid prefix like data:image/png;base64, or data:image/jpeg;base64,) and the stem matches labels visible on the image.\n- Evidence: \"add\" includes slide number(s) and brief exact phrase(s) from the slide.\n\nTEMPLATES\n\n// Text\u2011only\n{\n  \"q\": \"According to Slide 12, which muscle elevates the hyoid during swallowing?\",\n  \"c\": [\"Mylohyoid\", \"Sternohyoid\", \"Thyrohyoid\", \"Omohyoid\"],\n  \"a\": 0,\n  \"e\": \"Slide 12 lists Mylohyoid as a suprahyoid muscle that elevates the hyoid during swallowing.\",\n  \"w\": [\"Infrahyoid; depresses hyoid\", \"Primarily depresses/stabilizes hyoid\", \"Shortens larynx; not primary elevator\", \"Depresses/tense cervical fascia\"],\n  \"add\": \"Slide 12 \u2014 \u201cMylohyoid elevates the hyoid during swallowing.\u201d\"\n";
    var d = document;
    function applyInstr(){
      var ta = d.getElementById('instr-ta');
      if(ta){ ta.value = __inTxt; }
    }
    if(d.readyState === 'loading'){ d.addEventListener('DOMContentLoaded', applyInstr, { once: true }); }
    else { applyInstr(); }
  }catch(_e){}
})();

// PATCH: Keyboard shortcuts (A/B/C/D, arrows, Enter)
(function(){
  try{
    if (window.__quizShortcutsPatch__) return;
    window.__quizShortcutsPatch__ = true;

    var d = document;
    if(!d || !d.addEventListener) return;

    function isEditable(el){
      if(!el) return false;
      var tag = el.tagName;
      if(tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return true;
      if(el.isContentEditable) return true;
      return false;
    }
    function getChoices(){
      var cont = d.getElementById('choices');
      if(!cont) return [];
      var nodes = cont.querySelectorAll('.choice');
      return Array.prototype.slice.call(nodes);
    }
    function clickChoiceIndex(i){
      var arr = getChoices();
      if(i >= 0 && i < arr.length){
        try{ arr[i].click(); }catch(e){}
      }
    }
    var keyToIndex = { 'a':0, 'b':1, 'c':2, 'd':3 };

    d.addEventListener('keydown', function(ev){
      var ae = d.activeElement;
      if(isEditable(ae)) return;
      if(ev.altKey || ev.ctrlKey || ev.metaKey) return;

      var k = ev.key;
      if(!k) return;

      var lower = (k.length === 1) ? k.toLowerCase() : k;

      if(Object.prototype.hasOwnProperty.call(keyToIndex, lower)){
        clickChoiceIndex(keyToIndex[lower]);
        ev.preventDefault();
        return;
      }

      if(k === 'ArrowLeft'){
        var pb = d.getElementById('prev-btn');
        if(pb && pb.style && pb.style.display !== 'none'){
          try{ pb.click(); }catch(e){}
          ev.preventDefault();
        }
        return;
      }

      if(k === 'ArrowRight' || k === 'Enter'){
        var nb = d.getElementById('next-btn');
        if(nb && nb.style && nb.style.display !== 'none'){
          try{ nb.click(); }catch(e){}
          ev.preventDefault();
        }
        return;
      }
    }, false);
  }catch(_e){}
})();

// PATCH: Welcome page overlay
(function(){
  try{
    var d = document;
    if(!d || !d.body) return;
    if (d.getElementById('welcome-overlay')) return; // idempotent

    var overlay = d.createElement('div');
    overlay.id = 'welcome-overlay';
    overlay.setAttribute('aria-modal', 'true');
    overlay.setAttribute('role', 'dialog');

    var card = d.createElement('div');
    card.id = 'welcome-card';

    var h2 = d.createElement('h2');
    h2.textContent = 'hello there!';
    card.appendChild(h2);

    var p = d.createElement('p');
    p.textContent = 'Use the buttons below to view the instructions or import your questions. You can start the quiz anytime.';
    card.appendChild(p);

    var actions = d.createElement('div');
    actions.className = 'welcome-actions';

    var startBtn = d.createElement('button');
    startBtn.id = 'welcome-start-btn';
    startBtn.textContent = 'Start Quiz';
    // Gate Start until a JSON is imported this session
    startBtn.disabled = true;
    startBtn.setAttribute('aria-disabled','true');
    try{ startBtn.title = 'Upload a JSON first'; }catch(_e){}
    function __enableWelcomeStart(){
      try{
        startBtn.disabled = false;
        startBtn.removeAttribute('aria-disabled');
        startBtn.removeAttribute('title');
        startBtn.style.opacity = '';
        startBtn.style.cursor = '';
      }catch(_e){}
    }
    // Visual gray-out
    try{ startBtn.style.opacity = '0.55'; startBtn.style.cursor = 'not-allowed'; }catch(_e){}

    // Only enable if a JSON was imported during THIS session (not from prior loads)
    try{
      if (sessionStorage.getItem('jsonImportedThisSession') === '1'){
        __enableWelcomeStart();
      }
    }catch(_e){}

    // Patch localStorage.setItem to detect when questions are imported
    (function(){
      try{
        var __origSetItem = localStorage.setItem;
        localStorage.setItem = function(k, v){
          try{
            var qk = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
            if (k === qk){
              try{ sessionStorage.setItem('jsonImportedThisSession','1'); }catch(_e){}
              __enableWelcomeStart();
            }
          }catch(_e){}
          return __origSetItem.apply(this, arguments);
        };
      }catch(_e){}
    })();

    startBtn.addEventListener('click', function(){
            if (startBtn.disabled) { return; }
overlay.style.display = 'none';
    }, false);
    actions.appendChild(startBtn);

    var instrBtn = d.createElement('button');
    instrBtn.id = 'welcome-open-instr';
    instrBtn.textContent = 'Instructions';
    instrBtn.addEventListener('click', function(){
      overlay.style.display = 'none';
      var realInstr = d.getElementById('instr-btn');
      if(realInstr && realInstr.click) realInstr.click();
    }, false);
    actions.appendChild(instrBtn);

    var importBtn = d.createElement('button');
    importBtn.id = 'welcome-open-import';
    importBtn.textContent = 'Import';
    importBtn.addEventListener('click', function(){
      
      // Show inline Import UI on the welcome overlay (do NOT leave the welcome screen)
      (function(){
        try{
          var inline = d.getElementById('welcome-import-inline');
          if(!inline){
            inline = d.createElement('div');
            inline.id = 'welcome-import-inline';
            inline.style.cssText = 'margin-top:.75rem;padding:.75rem;border:1px solid var(--bd);border-radius:10px;background:var(--bg);';
            
            var title = d.createElement('div');
            title.textContent = 'Import questions (.json)';
            title.style.cssText = 'font-weight:700;margin-bottom:.5rem;';
            inline.appendChild(title);

            var row = d.createElement('div');
            row.style.cssText = 'display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;';
            inline.appendChild(row);

            var fi = d.createElement('input');
            fi.type = 'file';
            fi.accept = '.json,application/json';
            fi.id = 'welcome-import-file';
            fi.style.cssText = 'flex:1;min-width:220px;';
            row.appendChild(fi);

            var loadBtn = d.createElement('button');
            loadBtn.id = 'welcome-import-load';
            loadBtn.textContent = 'Load JSON';
            loadBtn.disabled = true;
            loadBtn.style.cssText = 'padding:.5rem .8rem;border-radius:8px;border:1px solid var(--bd);background:var(--bg);';
            row.appendChild(loadBtn);

            var status = d.createElement('div');
            status.id = 'welcome-import-status';
            status.style.cssText = 'margin-top:.5rem;font-size:.9rem;opacity:.8;';
            inline.appendChild(status);

            // Enable load only when a file is chosen
            fi.addEventListener('change', function(){
              loadBtn.disabled = !fi.files || !fi.files.length;
            }, false);

            function ok(msg){
              try{ status.style.color = ''; }catch(_e){}
              status.textContent = msg || 'Done.';
            }
            function err(msg){
              try{ status.style.color = '#ef4444'; }catch(_e){}
              status.textContent = msg || 'Import failed.';
            }
            function isValidQuestions(arr){
              if(!Array.isArray(arr) || !arr.length) return false;
              // Minimal validation for schema: q (string), c (array length 4), a (number 0-3)
              for(var i=0;i<Math.min(arr.length, 5);i++){
                var q = arr[i] || {};
                if(typeof q.q !== 'string') return false;
                if(!Array.isArray(q.c) || q.c.length !== 4) return false;
                if(typeof q.a !== 'number') return false;
              }
              return true;
            }

            function importFile(file){
              if(!file){ err('Pick a .json file first.'); return; }
              var fr = new FileReader();
              fr.onload = function(){
                try{
                  var text = String(fr.result || '');
                  var data = JSON.parse(text);
                  if(!isValidQuestions(data)){
                    err('Invalid JSON format. Expect an array of question objects.');
                    return;
                  }
                  // Persist questions exactly like the quiz UI does
                  var qk = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
                  try{ localStorage.setItem(qk, JSON.stringify(data)); }catch(_e){}
                  // --- PATCH: mirror quiz UI behavior (load into live array + reset state) ---
                  try{
                    // Replace in-memory questions immediately so starting the quiz uses the uploaded set
                    if (typeof questions !== 'undefined' && Array.isArray(questions)) {
                      try { questions.splice(0, questions.length, ...data); } catch(__e){}
                    }
                    // Persist using helper if available
                    try { if (typeof write === 'function' && typeof QUESTIONS_KEY === 'string') write(QUESTIONS_KEY, data); } catch(__e){}
                    // Reset quiz state to the beginning like the quiz import does
                    try {
                      if (typeof order !== 'undefined' && Array.isArray(questions)) { order = [...Array(questions.length).keys()]; }
                      if (typeof shuffle === 'function') try { shuffle(order); } catch(__e){}
                      if (typeof current !== 'undefined') current = 0;
                      if (typeof queued !== 'undefined' && (queued instanceof Set)) queued = new Set();
                      if (typeof choiceMap !== 'undefined') choiceMap = {};
                      if (typeof attemptMap !== 'undefined') attemptMap = {};
                      if (typeof enforceCap === 'function') enforceCap();
                      if (typeof saveState === 'function') saveState();
                      if (typeof showQuestion === 'function') showQuestion();
                      if (typeof renderMenu === 'function') renderMenu();
                      if (typeof updateSaveBtn === 'function') updateSaveBtn();
                      if (typeof updateTitle === 'function') updateTitle();
                    } catch(__e){}
                    // Gate/enable the Start button immediately
                    try { sessionStorage.setItem('jsonImportedThisSession', '1'); } catch(__e){}
                    try {
                      var __start = (typeof d!=='undefined' ? d.getElementById('welcome-start-btn') : document.getElementById('welcome-start-btn'));
                      if (__start) {
                        __start.disabled = false;
                        __start.removeAttribute('aria-disabled');
                        __start.style.opacity = '';
                        __start.style.cursor = '';
                      }
                    } catch(__e){}
                  } catch(__e){} 

                  ok('Loaded ' + data.length + ' questions. You can click Start Quiz now.');
                }catch(e){
                  err('Parse error: ' + (e && e.message ? e.message : String(e)));
                }
              };
              try{ fr.readAsText(file); }catch(e){ err('Read error.'); }
            }

            loadBtn.addEventListener('click', function(ev){
              ev.preventDefault(); ev.stopPropagation();
              try{ importFile(fi.files && fi.files[0]); }catch(_e){}
            }, false);

            // Insert below the actions row
            try{ card.appendChild(inline); }catch(_e){ overlay.appendChild(inline); }
          }else{
            inline.style.display = (inline.style.display === 'none' ? 'block' : 'block');
          }
        }catch(_e){}
      })();
    }, false);
    actions.appendChild(importBtn);

    card.appendChild(actions);
    overlay.appendChild(card);

    function showOverlay(){
      overlay.style.display = 'flex';
    }

    if(d.readyState === 'loading'){
      d.addEventListener('DOMContentLoaded', function(){
        d.body.appendChild(overlay);
        showOverlay();
      }, { once: true });
    }else{
      d.body.appendChild(overlay);
      showOverlay();
    }
  }catch(_e){}
})();



// PATCH: Welcome buttons open panels
(function(){
  try{
    var d = document;
    function attach(){
      var wInstr = d.getElementById('welcome-open-instr');
      var wImport = d.getElementById('welcome-open-import');
      if(wInstr && !wInstr.__patchedInstr){
        wInstr.__patchedInstr = true;
        wInstr.addEventListener('click', function(){
          // Let existing click handlers run, then force panel visible
          setTimeout(function(){
            var p = d.getElementById('instr-panel');
            if(p){ p.style.display = 'block'; }
            var ta = d.getElementById('instr-ta');
            if(ta && ta.focus) ta.focus();
          }, 0);
        }, false);
      }
      if(wImport && !wImport.__patchedImport){
        wImport.__patchedImport = true;
        wImport.addEventListener('click', function(){
          setTimeout(function(){
            var p = d.getElementById('import-menu');
            if(p){ p.style.display = 'block'; }
            var ta = d.getElementById('import-ta');
            if(ta && ta.focus) ta.focus();
          }, 0);
        }, false);
      }
    }
    if(d.readyState === 'loading'){
      d.addEventListener('DOMContentLoaded', function(){ setTimeout(attach, 0); }, { once: true });
    }else{
      setTimeout(attach, 0);
    }
  }catch(_e){}
})();



// PATCH: Welcome copy & title
(function(){ 
  try{
    var d = document;
    function apply(){
      var card = d.getElementById('welcome-card');
      if(!card){ setTimeout(apply, 0); return; }
      var h = card.querySelector('h2');
      if(h) h.textContent = 'Hello There!';
      var p = card.querySelector('p');
      if(p) p.innerHTML = "Press 'instructions' & then copy. Use Chatgpt 5 <strong>Thinking</strong> model  and upload a lecture of your choice alongside the instructions. ChatGPT-5 should return .JSON file, import that file using the 'Import' button.";
    }
    if(d.readyState === 'loading'){ d.addEventListener('DOMContentLoaded', function(){ setTimeout(apply, 0); }, { once: true }); }
    else { setTimeout(apply, 0); }
  }catch(_e){}
})();



// PATCH: Choice strikeout (right-click or eye icon)
(function(){
  try{
    var d = document;
    var root = d.getElementById('choices');
    if(!root) return;

    // Ensure icons exist on current choices; also observe future updates
    function addIcons(container){
      var nodes = container.querySelectorAll('.choice');
      for(var i=0; i<nodes.length; i++){
        var c = nodes[i];
        if(!c.querySelector('.strike-icon')){
          var b = d.createElement('button');
          b.type = 'button';
          b.className = 'strike-icon';
          b.setAttribute('aria-label', 'Strike/Unstrike this choice');
          b.setAttribute('title', 'Strike/Unstrike');
          b.textContent = '👁';
          // prevent this click from selecting the answer
          b.addEventListener('click', function(ev){
            ev.stopPropagation();
            ev.preventDefault();
            var host = ev.currentTarget.closest('.choice');
            if(host){ host.classList.toggle('struck'); }
          }, false);
          c.appendChild(b);
        }
      }
    }

    addIcons(root);

    // Observe dynamic changes to re-add icons when choices rerender
    if('MutationObserver' in window){
      var mo = new MutationObserver(function(muts){
        for(var j=0; j<muts.length; j++){
          var m = muts[j];
          if(m.type === 'childList'){
            // New choice nodes or a re-render; re-scan container
            addIcons(root);
          }
        }
      });
      mo.observe(root, { childList: true, subtree: true });
    }

    // Right-click to toggle strike on a choice only
    root.addEventListener('contextmenu', function(ev){
      var choice = ev.target && ev.target.closest ? ev.target.closest('.choice') : null;
      if(choice){
        ev.preventDefault();
        choice.classList.toggle('struck');
      }
    }, false);
  }catch(_e){}
})();



// PATCH: Session snapshots (Export / Load)
(function(){
  try{
    var d = document;
    function init(){
      var menu = d.getElementById('import-menu');
      if(!menu || menu.__snapshotsPatched) return;
      menu.__snapshotsPatched = true;

      // Buttons
      var exportBtn = d.createElement('button');
      exportBtn.id = 'export-session-btn';
      exportBtn.textContent = 'Export Session';
      exportBtn.style.cssText = 'width:100%;margin:0 0 .5rem;padding:.45rem .7rem;border-radius:10px;border:1px solid var(--bd);background:var(--bg);background-image:var(--g);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;color:transparent;cursor:pointer';

      var importBtn = d.createElement('button');
      importBtn.id = 'import-session-btn';
      importBtn.textContent = 'Load Snapshot';
      importBtn.style.cssText = 'width:100%;margin:0 0 .5rem;padding:.45rem .7rem;border-radius:10px;border:1px solid var(--bd);background:var(--bg);background-image:var(--g);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;color:transparent;cursor:pointer';

      var fileInput = d.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'application/json,.json';
      fileInput.id = 'snapshot-file-input';
      fileInput.style.display = 'none';

      // Insert at top of import-menu
      var ta = d.getElementById('import-ta');
      if(ta && ta.parentNode === menu){
        menu.insertBefore(importBtn, ta);
        menu.insertBefore(exportBtn, importBtn);
        menu.appendChild(fileInput);
      }else{
        // fallback: append at end
        menu.appendChild(exportBtn);
        menu.appendChild(importBtn);
        menu.appendChild(fileInput);
      }

      function readKey(k){
        try{ return localStorage.getItem(k); }catch(_e){ return null; }
      }
      function writeKey(k,v){
        try{
          if(typeof v === 'string'){ localStorage.setItem(k, v); }
          else if(v != null){ localStorage.setItem(k, String(v)); }
        }catch(_e){}
      }

      function collectKeys(){
        var out = {};
        // Known keys (do not mutate names)
        try{
          if (typeof STORAGE_KEY !== 'undefined') out[STORAGE_KEY] = readKey(STORAGE_KEY);
          if (typeof PROG_KEY !== 'undefined') out[PROG_KEY] = readKey(PROG_KEY);
          if (typeof BM_KEY   !== 'undefined') out[BM_KEY]   = readKey(BM_KEY);
          if (typeof QUESTIONS_KEY !== 'undefined') out[QUESTIONS_KEY] = readKey(QUESTIONS_KEY);
        }catch(_e){}

        // Any extras that share the same prefix as STORAGE_KEY
        try{
          var prefix = (typeof STORAGE_KEY === 'string') ? STORAGE_KEY.split('_')[0] : STORAGE_KEY;
          for(var i=0;i<localStorage.length;i++){
            var k = localStorage.key(i);
            if(!k) continue;
            if (typeof STORAGE_KEY === 'string' && (k.indexOf(STORAGE_KEY) === 0 || k.indexOf(prefix) === 0)) {
              if(!(k in out)) out[k] = readKey(k);
            }
          }
        }catch(_e){}

        return out;
      }

      function buildMeta(){
        var meta = { savedAtISO: new Date().toISOString(), version: 1 };
        try{ meta.questionCount = (typeof questions !== 'undefined' && questions && questions.length) ? questions.length : null; }catch(_e){}
        try{ meta.firstQText = (typeof questions !== 'undefined' && questions && questions[0] && questions[0].q) ? String(questions[0].q).slice(0,160) : null; }catch(_e){}
        return meta;
      }

      function exportSession(){
        try{
          var payload = {
            meta: buildMeta(),
            keys: collectKeys()
          };
          var blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
          var a = d.createElement('a');
          var dt = new Date();
          var fn = 'quiz-session-' +
            dt.getFullYear().toString().padStart(4,'0') +
            (dt.getMonth()+1).toString().padStart(2,'0') +
            dt.getDate().toString().padStart(2,'0') + '-' +
            dt.getHours().toString().padStart(2,'0') +
            dt.getMinutes().toString().padStart(2,'0') + '.json';
          a.download = fn;
          a.href = URL.createObjectURL(blob);
          setTimeout(function(){ URL.revokeObjectURL(a.href); }, 5000);
          a.click();
        }catch(_e){}
      }

      function importSessionFile(file){
        if(!file) return;
        var fr = new FileReader();
        fr.onload = function(){
          try{
            var text = String(fr.result || '');
            var data = JSON.parse(text);
            if(data && data.keys && typeof data.keys === 'object'){
              for(var k in data.keys){
                if(Object.prototype.hasOwnProperty.call(data.keys, k)){
                  writeKey(k, data.keys[k]);
                }
              }
              // tiny status note if present
              var status = d.getElementById('import-status');
              if(status){
                status.textContent = 'Snapshot loaded. Reloading…';
              }
              setTimeout(function(){ try{ location.reload(); }catch(_e){} }, 200);
            }
          }catch(_e){}
        };
        fr.readAsText(file);
      }

      exportBtn.addEventListener('click', exportSession, false);
      importBtn.addEventListener('click', function(){ fileInput.click(); }, false);
      fileInput.addEventListener('change', function(){
        var f = fileInput.files && fileInput.files[0];
        importSessionFile(f);
        fileInput.value = '';
      }, false);
    }

    if(d.readyState === 'loading'){ d.addEventListener('DOMContentLoaded', init, { once: true }); }
    else{ init(); }
  }catch(_e){}
})();



// PATCH: Compact Mode (Flashcards triage -> Focus Quiz)
(function(){
  try{
    var d = document;
    var FC_PAGE_SIZE = 20;
    var CONF_KEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz') + '_compactConfidence';
    var ORIG_Q_BACKUP = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions') + '_backupCompactOrig';

    function readJSON(key, def){
      try{ var v = localStorage.getItem(key); return v ? JSON.parse(v) : def; }catch(_e){ return def; }
    }
    function writeJSON(key, val){
      try{ localStorage.setItem(key, JSON.stringify(val)); }catch(_e){}
    }

    function ensureCompactButton(){
      if(d.getElementById('compact-btn')) return;
      var host = d.getElementById('upload-lectures-btn') || d.getElementById('viewer-toggle-btn') || d.getElementById('review-menu-btn');
      if(!host || !host.parentNode) return;
      var btn = d.createElement('button');
      btn.id = 'compact-btn';
      btn.type = 'button';
      btn.textContent = 'Compact Mode';
      host.parentNode.insertBefore(btn, host.nextSibling);
      btn.addEventListener('click', openOverlay, false);
    }

    // Build overlay skeleton once
    function ensureOverlay(){
      if(d.getElementById('compact-overlay')) return;
      var ov = d.createElement('div'); ov.id = 'compact-overlay';
      var panel = d.createElement('div'); panel.id = 'compact-panel';
      var header = d.createElement('div'); header.id = 'compact-header';
      var title = d.createElement('h3'); title.id = 'compact-title'; title.textContent = 'Compact Mode — Flashcards';
      var ctrls = d.createElement('div'); ctrls.id = 'compact-controls';
      var pgInfo = d.createElement('span'); pgInfo.id = 'fc-page-info'; pgInfo.style.opacity = '.9';
      var prev = d.createElement('button'); prev.id = 'fc-prev'; prev.textContent = 'Prev Set';
      var next = d.createElement('button'); next.id = 'fc-next'; next.textContent = 'Next Set';
      var close = d.createElement('button'); close.id = 'fc-close'; close.textContent = 'Close';
      var start = d.createElement('button'); start.id = 'fc-start-focus'; start.textContent = 'Start Focus Quiz';
      ctrls.appendChild(prev); ctrls.appendChild(next); ctrls.appendChild(start); ctrls.appendChild(close);
      header.appendChild(title); header.appendChild(ctrls);

      var grid = d.createElement('div'); grid.id = 'fc-grid';

      panel.appendChild(header);
      panel.appendChild(pgInfo);
      panel.appendChild(grid);
      ov.appendChild(panel);
      d.body.appendChild(ov);

      // wire buttons
      prev.addEventListener('click', function(){ setPage(state.page-1); }, false);
      next.addEventListener('click', function(){ setPage(state.page+1); }, false);
      close.addEventListener('click', function(){ ov.style.display = 'none'; }, false);
      start.addEventListener('click', startFocusQuiz, false);
    }

    var state = { page: 0, totalPages: 0, conf: {}, count: 0 };

    function openOverlay(){
      ensureOverlay();
      state.conf = readJSON(CONF_KEY, {});
      state.count = (typeof questions !== 'undefined' && questions && questions.length) ? questions.length : 0;
      state.totalPages = state.count ? Math.ceil(state.count / FC_PAGE_SIZE) : 0;
      setPage(0);
      d.getElementById('compact-overlay').style.display = 'block';
    }

    function setPage(p){
      if(p < 0) p = 0;
      if(p >= state.totalPages) p = state.totalPages-1;
      state.page = p;
      renderPage();
    }

    function renderPage(){
      var grid = d.getElementById('fc-grid'); if(!grid) return;
      grid.innerHTML = '';
      var start = state.page * FC_PAGE_SIZE;
      var end = Math.min(state.count, start + FC_PAGE_SIZE);
      var pgInfo = d.getElementById('fc-page-info');
      if(pgInfo) pgInfo.textContent = 'Showing ' + (start+1) + '–' + end + ' of ' + state.count;

      for(var i = start; i < end; i++){
        var q = questions[i];
        var card = buildCard(i, q);
        grid.appendChild(card);
      }
    }

    function buildCard(idx, q){
      var wrap = d.createElement('div'); wrap.className = 'fc-card';
      var inner = d.createElement('div'); inner.className = 'fc-inner';
      var front = d.createElement('div'); front.className = 'fc-face fc-front';
      var back = d.createElement('div'); back.className = 'fc-face fc-back';

      var qDiv = d.createElement('div'); qDiv.className = 'fc-q'; qDiv.textContent = q && q.q ? String(q.q) : ('Question ' + (idx+1));
      front.appendChild(qDiv);

      // back: correct answer + explanation (if present)
      var aText = (q && q.c && typeof q.a === 'number' && q.c[q.a] != null) ? String(q.c[q.a]) : '(no answer)';
      var aDiv = d.createElement('div'); aDiv.className = 'fc-a';
      aDiv.innerHTML = '<strong>Answer:</strong> ' + escapeHTML(aText);
      back.appendChild(aDiv);
      if(q && q.e){
        var meta = d.createElement('div'); meta.className = 'fc-meta';
        meta.textContent = q.e;
        back.appendChild(meta);
      }

      // controls: ✓ / — / ×
      var ctrls = d.createElement('div'); ctrls.className = 'fc-controls'; ctrls.addEventListener('click', function(ev){ ev.stopPropagation(); }, false);

      var g = d.createElement('button'); g.className = 'fc-ctrl'; g.title = 'Mark Known (✓)'; g.textContent = '✓';
      var y = d.createElement('button'); y.className = 'fc-ctrl'; y.title = 'Mark Unsure (—)'; y.textContent = '—';
      var r = d.createElement('button'); r.className = 'fc-ctrl'; r.title = 'Mark Don’t know (×)'; r.textContent = '×';

      g.addEventListener('click', function(){ setMark(wrap, idx, 'g'); }, false);
      y.addEventListener('click', function(){ setMark(wrap, idx, 'y'); }, false);
      r.addEventListener('click', function(){ setMark(wrap, idx, 'r'); }, false);

      ctrls.appendChild(g); ctrls.appendChild(y); ctrls.appendChild(r);

      front.appendChild(ctrls);
      back.appendChild(ctrls.cloneNode(true)); // mirror controls on back
      // Note: we'll rebind events for the cloned controls
      var backCtrls = back.querySelectorAll('.fc-ctrl');
      if(backCtrls.length === 3){
        backCtrls[0].addEventListener('click', function(ev){ ev.stopPropagation(); setMark(wrap, idx, 'g'); }, false);
        backCtrls[1].addEventListener('click', function(ev){ ev.stopPropagation(); setMark(wrap, idx, 'y'); }, false);
        backCtrls[2].addEventListener('click', function(ev){ ev.stopPropagation(); setMark(wrap, idx, 'r'); }, false);
      }

      wrap.addEventListener('click', function(){ wrap.classList.toggle('flipped'); }, false);

      // apply stored mark
      applyMarkClass(wrap, state.conf[idx]);

      inner.appendChild(front); inner.appendChild(back);
      wrap.appendChild(inner);
      return wrap;
    }

    function setMark(cardEl, idx, mark){
      state.conf[idx] = mark;
      writeJSON(CONF_KEY, state.conf);
      applyMarkClass(cardEl, mark);
    }
    function applyMarkClass(cardEl, mark){
      cardEl.classList.remove('mark-g','mark-y','mark-r');
      if(mark === 'g') cardEl.classList.add('mark-g');
      else if(mark === 'y') cardEl.classList.add('mark-y');
      else if(mark === 'r') cardEl.classList.add('mark-r');
    }

    function startFocusQuiz(){
      // Build subset of questions using marks 'y' or 'r'
      var conf = readJSON(CONF_KEY, {});
      var pick = [];
      for(var i=0;i<questions.length;i++){
        var m = conf[i];
        if(m === 'y' || m === 'r') pick.push(i);
      }
      if(pick.length === 0){
        try{ alert('No yellow or red cards selected. Mark some first.'); }catch(_e){}
        return;
      }
      // Backup original set once
      try{
        if(typeof QUESTIONS_KEY === 'string' && !localStorage.getItem(ORIG_Q_BACKUP)){
          var orig = localStorage.getItem(QUESTIONS_KEY);
          if(orig != null){ localStorage.setItem(ORIG_Q_BACKUP, orig); }
        }
      }catch(_e){}
      // Build new set
      var subset = [];
      for(var j=0;j<pick.length;j++){
        var idx = pick[j];
        try{ subset.push(questions[idx]); }catch(_e){}
      }
      try{
        if(typeof QUESTIONS_KEY === 'string'){
          localStorage.setItem(QUESTIONS_KEY, JSON.stringify(subset));
        }
      }catch(_e){}
      try{ location.reload(); }catch(_e){}
    }

    function escapeHTML(s){
      return String(s)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#039;');
    }

    function boot(){
      ensureCompactButton();
    }

    if(d.readyState === 'loading'){ d.addEventListener('DOMContentLoaded', boot, { once:true }); }
    else{ boot(); }
  }catch(_e){}
})();



// PATCH: Compact Mode improvements (skip welcome once, show all cards toggle)
(function(){
  try{
    var d = document;
    var SKIP_FLAG = '__skipWelcomeOnce';
    var ORIG_BACKUP_KEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions') + '_backupCompactOrig';
    var CONF_KEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz') + '_compactConfidence';
    var PAGE_SIZE = 20;

    // 1) Ensure welcome overlay is skipped immediately after starting Focus Quiz
    function hideWelcomeIfFlag(){
      try{
        var flag = localStorage.getItem(SKIP_FLAG);
        if(flag){
          var ov = d.getElementById('welcome-overlay');
          if(ov){ ov.style.display = 'none'; }
          localStorage.removeItem(SKIP_FLAG);
        }
      }catch(_e){}
    }
    if(d.readyState === 'loading'){
      d.addEventListener('DOMContentLoaded', hideWelcomeIfFlag, { once: true });
    }else{
      hideWelcomeIfFlag();
    }

    // Ensure we set the flag BEFORE the original handler reloads the page
    function primeSkipFlagCapture(ev){
      try{ localStorage.setItem(SKIP_FLAG, '1'); }catch(_e){}
      // do not prevent default; allow the original listener to run
    }
    function attachSkipFlag(){
      var btn = d.getElementById('fc-start-focus');
      if(btn && !btn.__skipFlagCapture){
        btn.__skipFlagCapture = true;
        // capture phase to run before the existing bubble listener
        btn.addEventListener('click', primeSkipFlagCapture, true);
      }
    }
    if(d.readyState === 'loading'){
      d.addEventListener('DOMContentLoaded', function(){ setTimeout(attachSkipFlag, 0); }, { once: true });
    }else{
      setTimeout(attachSkipFlag, 0);
    }

    // 2) "Show All Cards" toggle inside compact overlay
    var state = { source: 'focus', page: 0, items: [], orig: null, subset: null, conf: {} };

    function readJSON(k, def){ try{ var v = localStorage.getItem(k); return v ? JSON.parse(v) : def; }catch(_e){ return def; } }
    function writeJSON(k, v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(_e){} }

    function ensureToggle(){
      var ctrls = d.getElementById('compact-controls');
      if(!ctrls || d.getElementById('fc-toggle-source')) return;
      var t = d.createElement('button');
      t.id = 'fc-toggle-source';
      t.textContent = 'Show All Cards';
      t.title = 'Toggle between Focus (red/yellow) and All (incl. green)';
      t.addEventListener('click', function(){
        state.source = (state.source === 'focus') ? 'all' : 'focus';
        t.textContent = (state.source === 'focus') ? 'Show All Cards' : 'Show Focus Cards';
        state.page = 0;
        renderGrid();
      }, false);
      // insert as first control button for visibility
      ctrls.insertBefore(t, ctrls.firstChild);
    }

    // Build/refresh our own grid renderer (non-destructive)
    function initState(){
      state.conf = readJSON(CONF_KEY, {});
      var orig = readJSON(ORIG_BACKUP_KEY, null);
      state.orig = Array.isArray(orig) ? orig : null;
      // current set from page-global 'questions'
      state.subset = (typeof questions !== 'undefined' && questions && questions.length) ? questions.slice() : [];
      // default source: if we detect a backup that's longer than current => focus mode, else all
      state.source = (state.orig && state.orig.length > state.subset.length) ? 'focus' : 'all';
    }

    function currentItems(){
      if(state.source === 'all' && state.orig) return state.orig;
      return state.subset;
    }

    function findOrigIndex(qObj){
      if(!state.orig || !qObj) return null;
      // Try fast path: exact object reference not possible after reload; fallback heuristic
      var qtxt = (qObj && qObj.q) ? String(qObj.q) : null;
      var clen = (qObj && qObj.c && qObj.c.length) ? qObj.c.length : null;
      for(var i=0;i<state.orig.length;i++){
        var o = state.orig[i];
        if(!o) continue;
        if(String(o.q) === qtxt && o.c && o.c.length === clen){
          // further check: first and last choice if available
          try{
            var ok = true;
            if(clen && clen > 0){
              if(String(o.c[0]) !== String(qObj.c[0])) ok = false;
              if(String(o.c[clen-1]) !== String(qObj.c[clen-1])) ok = false;
            }
            if(ok) return i;
          }catch(_e){ return i; }
        }
      }
      return null;
    }

    function setMarkByOrigIdx(origIdx, mark){
      if(origIdx == null) return;
      state.conf[origIdx] = mark;
      writeJSON(CONF_KEY, state.conf);
    }
    function getMarkByOrigIdx(origIdx){
      return state.conf[origIdx];
    }

    function ensureHandlers(){
      var prev = d.getElementById('fc-prev');
      var next = d.getElementById('fc-next');
      if(prev && !prev.__fcPatch){
        prev.__fcPatch = true;
        prev.addEventListener('click', function(ev){
          ev.stopPropagation();
          state.page = Math.max(0, state.page - 1);
          renderGrid();
        }, false);
      }
      if(next && !next.__fcPatch){
        next.__fcPatch = true;
        next.addEventListener('click', function(ev){
          ev.stopPropagation();
          state.page = Math.min(totalPages()-1, state.page + 1);
          renderGrid();
        }, false);
      }
    }

    function totalPages(){
      var n = currentItems().length;
      return n ? Math.ceil(n / PAGE_SIZE) : 0;
    }

    function renderGrid(){
      var grid = d.getElementById('fc-grid');
      var info = d.getElementById('fc-page-info');
      if(!grid) return;
      var items = currentItems();
      var n = items.length;
      var tp = totalPages();
      if(state.page >= tp) state.page = Math.max(0, tp-1);
      var start = state.page * PAGE_SIZE;
      var end = Math.min(n, start + PAGE_SIZE);
      if(info) info.textContent = 'Showing ' + (start+1) + '–' + end + ' of ' + n + (state.source==='all'?' — All':' — Focus');
      grid.innerHTML = '';

      for(var i=start;i<end;i++){
        var q = items[i];
        var card = buildCard(i, q);
        grid.appendChild(card);
      }
    }

    function buildCard(localIdx, q){
      var wrap = d.createElement('div'); wrap.className = 'fc-card';
      var inner = d.createElement('div'); inner.className = 'fc-inner';
      var front = d.createElement('div'); front.className = 'fc-face fc-front';
      var back = d.createElement('div'); back.className = 'fc-face fc-back';

      var qDiv = d.createElement('div'); qDiv.className = 'fc-q'; qDiv.textContent = q && q.q ? String(q.q) : ('Question');
      front.appendChild(qDiv);

      var aText = (q && q.c && typeof q.a === 'number' && q.c[q.a] != null) ? String(q.c[q.a]) : '(no answer)';
      var aDiv = d.createElement('div'); aDiv.className = 'fc-a'; aDiv.innerHTML = '<strong>Answer:</strong> ' + escapeHTML(aText);
      back.appendChild(aDiv);
      if(q && q.e){
        var meta = d.createElement('div'); meta.className = 'fc-meta'; meta.textContent = q.e; back.appendChild(meta);
      }

      var ctrls = d.createElement('div'); ctrls.className = 'fc-controls'; ctrls.addEventListener('click', function(ev){ ev.stopPropagation(); }, false);
      var g = d.createElement('button'); g.className = 'fc-ctrl'; g.title = 'Mark Known (✓)'; g.textContent = '✓';
      var y = d.createElement('button'); y.className = 'fc-ctrl'; y.title = 'Mark Unsure (—)'; y.textContent = '—';
      var r = d.createElement('button'); r.className = 'fc-ctrl'; r.title = 'Mark Don’t know (×)'; r.textContent = '×';

      // Use original index for storage regardless of source
      var origIdx = (state.source === 'all') ? localIdx : findOrigIndex(q);
      var mark = getMarkByOrigIdx(origIdx);
      applyMarkClass(wrap, mark);

      g.addEventListener('click', function(){ setMarkByOrigIdx(origIdx, 'g'); applyMarkClass(wrap,'g'); }, false);
      y.addEventListener('click', function(){ setMarkByOrigIdx(origIdx, 'y'); applyMarkClass(wrap,'y'); }, false);
      r.addEventListener('click', function(){ setMarkByOrigIdx(origIdx, 'r'); applyMarkClass(wrap,'r'); }, false);

      ctrls.appendChild(g); ctrls.appendChild(y); ctrls.appendChild(r);
      front.appendChild(ctrls);
      var ctrls2 = ctrls.cloneNode(true);
      // rebind clone
      var bcs = ctrls2.querySelectorAll('.fc-ctrl');
      if(bcs.length === 3){
        bcs[0].addEventListener('click', function(ev){ ev.stopPropagation(); setMarkByOrigIdx(origIdx, 'g'); applyMarkClass(wrap,'g'); }, false);
        bcs[1].addEventListener('click', function(ev){ ev.stopPropagation(); setMarkByOrigIdx(origIdx, 'y'); applyMarkClass(wrap,'y'); }, false);
        bcs[2].addEventListener('click', function(ev){ ev.stopPropagation(); setMarkByOrigIdx(origIdx, 'r'); applyMarkClass(wrap,'r'); }, false);
      }
      back.appendChild(ctrls2);

      wrap.addEventListener('click', function(){ wrap.classList.toggle('flipped'); }, false);

      inner.appendChild(front); inner.appendChild(back); wrap.appendChild(inner);
      return wrap;
    }

    function applyMarkClass(cardEl, mark){
      if(!cardEl) return;
      cardEl.classList.remove('mark-g','mark-y','mark-r');
      if(mark === 'g') cardEl.classList.add('mark-g');
      else if(mark === 'y') cardEl.classList.add('mark-y');
      else if(mark === 'r') cardEl.classList.add('mark-r');
    }

    function escapeHTML(s){
      return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;');
    }

    // Activate our overlay augment when user opens Compact Mode
    function onCompactClick(){
      setTimeout(function(){
        try{
          initState();
          ensureToggle();
          ensureHandlers();
          renderGrid();
        }catch(_e){}
      }, 0);
    }

    function armCompactButton(){
      var cb = d.getElementById('compact-btn');
      if(cb && !cb.__compactAug){
        cb.__compactAug = true;
        cb.addEventListener('click', onCompactClick, false);
      }
    }

    if(d.readyState === 'loading'){
      d.addEventListener('DOMContentLoaded', function(){ setTimeout(armCompactButton, 0); }, { once: true });
    }else{
      setTimeout(armCompactButton, 0);
    }
  }catch(_e){}
})();



// PATCH: Focus Quiz robust pick + welcome skip + updated welcome instructions
(function(){ 
  try{
    var d = document;
    var SKIP_FLAG = '__skipWelcomeOnce';
    var CONF_KEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz') + '_compactConfidence';
    var ORIG_BACKUP_KEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions') + '_backupCompactOrig';

    function readJSON(k, def){ try{ var v = localStorage.getItem(k); return v ? JSON.parse(v) : def; }catch(_e){ return def; } }
    function writeJSON(k, val){ try{ localStorage.setItem(k, JSON.stringify(val)); }catch(_e){} }

    // A) Update welcome text copy
    function updateWelcomeCopy(){
      var card = d.getElementById('welcome-card');
      if(!card) return;
      var p = card.querySelector('p');
      if(p) p.textContent = "Press 'instructions' & then copy. Use Chatgpt 5 Thinking model and upload a lecture of your choice alongside the instructions & the quiz HTML. ChatGPT-5 should return .JSON file, import that file using the 'Import' button.";
    }
    if(d.readyState === 'loading'){ d.addEventListener('DOMContentLoaded', function(){ setTimeout(updateWelcomeCopy, 0); }, { once: true }); }
    else { setTimeout(updateWelcomeCopy, 0); }

    // B) Intercept Start Focus Quiz to build pick from stored marks reliably
    function interceptFocusStart(){
      var btn = d.getElementById('fc-start-focus');
      if(!btn || btn.__focusIntercepted) return;
      btn.__focusIntercepted = true;

      btn.addEventListener('click', function(ev){
        try{ localStorage.setItem(SKIP_FLAG, '1'); }catch(_e){}

        var conf = readJSON(CONF_KEY, {}) || {};
        var pick = [];
        // 1) Prefer scanning conf keys (handles both original and current indexing)
        try{
          for (var k in conf) if (Object.prototype.hasOwnProperty.call(conf, k)) {
            var v = conf[k];
            if (v === 'y' || v === 'r') {
              var idx = parseInt(k, 10);
              if (!isNaN(idx)) pick.push(idx);
            }
          }
        }catch(_e){}

        // 2) Fallback: scan current questions array
        if ((!pick || pick.length === 0) && typeof questions !== 'undefined' && questions && questions.length) {
          for (var i=0; i<questions.length; i++) {
            var v2 = conf[i];
            if (v2 === 'y' || v2 === 'r') pick.push(i);
          }
        }

        // Deduplicate and sort
        if (pick && pick.length) {
          var seen = {}, uniq = [];
          for (var j=0; j<pick.length; j++) { var id = pick[j]; if (!seen[id]) { seen[id]=1; uniq.push(id); } }
          pick = uniq.sort(function(a,b){ return a-b; });
        }

        if (!pick || pick.length === 0) {
          try{ alert('No yellow or red cards selected. Mark some first.'); }catch(_e){}
          ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
          return false;
        }

        // Backup original questions once if not already
        try{
          if (typeof QUESTIONS_KEY === 'string' && !localStorage.getItem(ORIG_BACKUP_KEY)) {
            var orig = localStorage.getItem(QUESTIONS_KEY);
            if (orig != null) localStorage.setItem(ORIG_BACKUP_KEY, orig);
          }
        }catch(_e){}

        // Build subset based on pick
        try{
          var subset = [];
          for (var p=0; p<pick.length; p++) {
            var ix = pick[p];
            if (typeof questions !== 'undefined' && questions[ix] != null) subset.push(questions[ix]);
          }
          if (typeof QUESTIONS_KEY === 'string') localStorage.setItem(QUESTIONS_KEY, JSON.stringify(subset));
        }catch(_e){}

        // Reload immediately to focused quiz
        try{ location.reload(); }catch(_e){}
        ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
        return false;
      }, true); // capture to win over the original
    }

    function arm(){
      interceptFocusStart();
    }
    if(d.readyState === 'loading'){ d.addEventListener('DOMContentLoaded', function(){ setTimeout(arm, 0); }, { once: true }); }
    else { setTimeout(arm, 0); }
  }catch(_e){}
})();



// PATCH: Robust Focus Quiz interceptor + welcome copy
(function(){ 
  try{
    var d = document;
    var SKIP_FLAG = '__skipWelcomeOnce';
    var CONF_KEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz') + '_compactConfidence';

    function readJSON(k, def){ try{ var v = localStorage.getItem(k); return v ? JSON.parse(v) : def; }catch(_e){ return def; } }

    // Update welcome copy
    function updateWelcomeCopy(){
      var card = d.getElementById('welcome-card');
      if(!card) return;
      var p = card.querySelector('p');
      if(p) p.textContent = "Press 'instructions' & then copy. Use Chatgpt 5 Thinking model and upload a lecture of your choice alongside the instructions & the quiz HTML. ChatGPT-5 should return .JSON file, import that file using the 'Import' button.";
    }
    if(d.readyState === 'loading'){ d.addEventListener('DOMContentLoaded', function(){ setTimeout(updateWelcomeCopy, 0); }, { once: true }); }
    else { setTimeout(updateWelcomeCopy, 0); }

    function interceptStart(btn){
      if(!btn || btn.__robustFocus) return;
      btn.__robustFocus = true;
      btn.addEventListener('click', function(ev){
        // Build pick from stored marks
        var conf = readJSON(CONF_KEY, {}) || {};
        var pick = [];
        try{
          for (var k in conf) if (Object.prototype.hasOwnProperty.call(conf, k)) {
            var v = conf[k];
            if (v === 'y' || v === 'r') {
              var ix = parseInt(k, 10);
              if (!isNaN(ix)) pick.push(ix);
            }
          }
        }catch(_e){}
        // Fallback to current array indexing
        if((!pick || pick.length===0) && typeof questions !== 'undefined' && questions && questions.length){
          for (var i=0;i<questions.length;i++){ var v2 = conf[i]; if(v2==='y' || v2==='r') pick.push(i); }
        }
        // Dedup + sort
        if (pick && pick.length) {
          var seen = {}, u = [];
          for (var j=0;j<pick.length;j++){ var id = pick[j]; if(!seen[id]){ seen[id]=1; u.push(id); } }
          pick = u.sort(function(a,b){ return a-b; });
        }
        if(!pick || pick.length===0){
          // Prevent original alert by fully swallowing the event
          ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
          try{ alert('No yellow or red cards selected. Mark some first.'); }catch(_e){}
          return false;
        }
        // Build subset directly from current questions
        try{
          var subset = [];
          for (var p=0; p<pick.length; p++){ var ix = pick[p]; if(questions[ix] != null) subset.push(questions[ix]); }
          if (typeof QUESTIONS_KEY === 'string') localStorage.setItem(QUESTIONS_KEY, JSON.stringify(subset));
        }catch(_e){}
        try{ localStorage.setItem(SKIP_FLAG, '1'); }catch(_e){}
        // Reload immediately to skip welcome and enter focused quiz
        try{ location.reload(); }catch(_e){}
        ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
        return false;
      }, true); // capture to preempt original
    }

    function attachWhenReady(){
      var btn = d.getElementById('fc-start-focus');
      if(btn) interceptStart(btn);
    }

    // Observe overlay creation dynamically
    if('MutationObserver' in window){
      var mo = new MutationObserver(function(muts){
        for(var i=0;i<muts.length;i++){ 
          var m = muts[i];
          if(m.type === 'childList'){
            attachWhenReady();
          }
        }
      });
      mo.observe(d.documentElement, { childList: true, subtree: true });
    }
    // Also attempt periodic polling briefly after UI actions
    var tries = 0;
    (function poll(){
      attachWhenReady();
      tries++;
      if(tries < 30) setTimeout(poll, 200);
    })();
  }catch(_e){}
})();



// PATCH: Focus Quiz uses only cards marked THIS session (when Compact is open)
(function(){
  try{
    var d = document;
    var SKIP_FLAG = '__skipWelcomeOnce';
    var CONF_KEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz') + '_compactConfidence';
    var ORIG_BACKUP_KEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions') + '_backupCompactOrig';

    // In-memory session marks: { [origIdx]: 'g'|'y'|'r' }
    if(!window.__fcSessionMarks) window.__fcSessionMarks = {};
    if(!window.__fcSessionActive) window.__fcSessionActive = false;

    function readJSON(k, def){ try{ var v = localStorage.getItem(k); return v ? JSON.parse(v) : def; }catch(_e){ return def; } }

    // Detect compact overlay presence to mark session active
    function markActiveIfGrid(){
      var grid = d.getElementById('fc-grid');
      if(grid){ window.__fcSessionActive = true; }
    }

    function getOriginalArray(){
      var orig = readJSON(ORIG_BACKUP_KEY, null);
      if(Array.isArray(orig) && orig.length) return orig;
      // Fallback to current questions global
      try{ if(typeof questions !== 'undefined' && questions && questions.length) return questions; }catch(_e){}
      return [];
    }

    // Annotate cards with data-orig-idx by matching question text to original array
    function annotateCards(){
      var grid = d.getElementById('fc-grid');
      if(!grid) return;
      var orig = getOriginalArray();
      var cards = grid.querySelectorAll('.fc-card');
      for(var i=0;i<cards.length;i++){
        var card = cards[i];
        if(card.dataset && card.dataset.origIdx) continue;
        var qEl = card.querySelector('.fc-q');
        var qtxt = qEl ? String(qEl.textContent || '').trim() : null;
        if(!qtxt) continue;
        var found = -1;
        for(var j=0;j<orig.length;j++){
          var oq = orig[j];
          if(oq && String(oq.q || '').trim() === qtxt){ found = j; break; }
        }
        if(found >= 0){
          card.setAttribute('data-orig-idx', String(found));
        }
      }
    }

    // Capture clicks on ✓/—/× to update session marks
    function armSessionMarkCapture(){
      var grid = d.getElementById('fc-grid');
      if(!grid || grid.__fcCapture) return;
      grid.__fcCapture = true;
      grid.addEventListener('click', function(ev){
        var t = ev.target;
        if(!t || !t.classList) return;
        if(!t.classList.contains('fc-ctrl')) return;
        var card = t.closest('.fc-card');
        if(!card) return;
        var idx = card.getAttribute('data-orig-idx');
        if(idx == null) return;
        var mark = null;
        var txt = (t.textContent || '').trim();
        if(txt === '✓') mark = 'g';
        else if(txt === '—') mark = 'y';
        else if(txt === '×') mark = 'r';
        if(!mark) return;
        window.__fcSessionMarks[idx] = mark;
      }, false);
    }

    // Intercept Start Focus Quiz: if compact overlay is active, require session marks
    function interceptStart(){
      var btn = d.getElementById('fc-start-focus');
      if(!btn || btn.__fcSessionOnly) return;
      btn.__fcSessionOnly = true;
      btn.addEventListener('click', function(ev){
        try{ localStorage.setItem(SKIP_FLAG, '1'); }catch(_e){}
        // Build picks
        var picks = [];
        if(window.__fcSessionActive){
          // Use only current-session marks
          for(var k in window.__fcSessionMarks){
            if(!Object.prototype.hasOwnProperty.call(window.__fcSessionMarks, k)) continue;
            var v = window.__fcSessionMarks[k];
            if(v === 'y' || v === 'r') picks.push(parseInt(k,10));
          }
          // If none selected this session, block and ask the user to mark some
          if(picks.length === 0){
            ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
            try{ alert('Mark some yellow (—) or red (×) cards first.'); }catch(_e){}
            return false;
          }
        }else{
          // Fallback behavior: original logic based on stored confidence (legacy path)
          var conf = readJSON(CONF_KEY, {}) || {};
          for (var kk in conf) if (Object.prototype.hasOwnProperty.call(conf, kk)){
            var vv = conf[kk];
            if(vv === 'y' || vv === 'r'){ var id = parseInt(kk,10); if(!isNaN(id)) picks.push(id); }
          }
        }
        // Build subset
        if(picks.length > 0 && typeof questions !== 'undefined' && questions && questions.length){
          // Dedup + sort
          var seen = {}, uniq = [];
          for(var i=0;i<picks.length;i++){ var id=picks[i]; if(!seen[id]){ seen[id]=1; uniq.push(id); } }
          uniq.sort(function(a,b){ return a-b; });
          var subset = [];
          var orig = getOriginalArray();
          for(var j=0;j<uniq.length;j++){
            var ix = uniq[j];
            var item = orig[ix] || questions[ix];
            if(item) subset.push(item);
          }
          try{ if(typeof QUESTIONS_KEY === 'string') localStorage.setItem(QUESTIONS_KEY, JSON.stringify(subset)); }catch(_e){}
          try{ location.reload(); }catch(_e){}
          ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
          return false;
        }
      }, true); // capture
    }

    // Observe to keep annotations up to date as pages change
    if('MutationObserver' in window){
      var mo = new MutationObserver(function(muts){
        markActiveIfGrid();
        annotateCards();
        armSessionMarkCapture();
        interceptStart();
      });
      mo.observe(d.documentElement, { childList: true, subtree: true });
    }
    // Initial pass
    setTimeout(function(){
      markActiveIfGrid(); annotateCards(); armSessionMarkCapture(); interceptStart();
    }, 0);
  }catch(_e){}
})();



// PATCH: Compact Mode — Reset Marks button
(function(){
  try{
    var d = document;
    var CONF_KEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz') + '_compactConfidence';

    function addResetButton(){
      var ctrls = d.getElementById('compact-controls');
      if(!ctrls || d.getElementById('fc-reset-marks')) return;
      var resetBtn = d.createElement('button');
      resetBtn.id = 'fc-reset-marks';
      resetBtn.type = 'button';
      resetBtn.textContent = 'Reset Marks';
      resetBtn.title = 'Clear ✓ / — / × marks for this triage session';
      // place before Close button if present; else append
      var closeBtn = d.getElementById('fc-close');
      if(closeBtn && closeBtn.parentNode === ctrls){
        ctrls.insertBefore(resetBtn, closeBtn);
      }else{
        ctrls.appendChild(resetBtn);
      }

      resetBtn.addEventListener('click', function(ev){
        try { window.__fcSessionMarks = {}; } catch(_e){}
        try { localStorage.setItem(CONF_KEY, JSON.stringify({})); } catch(_e){}
        // Visually clear current page
        var cards = d.querySelectorAll('#fc-grid .fc-card');
        for(var i=0;i<cards.length;i++){
          var c = cards[i];
          c.classList.remove('mark-g','mark-y','mark-r');
        }
      }, false);
    }

    function boot(){
      addResetButton();
      // also watch for overlay creation/redraw
      if('MutationObserver' in window){
        var mo = new MutationObserver(function(){ addResetButton(); });
        mo.observe(d.documentElement, { childList: true, subtree: true });
      }
    }

    if(d.readyState === 'loading'){ d.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once: true }); }
    else { setTimeout(boot, 0); }
  }catch(_e){}
})();



// PATCH: Focus view fidelity + reset continuity
(function(){
  try{
    var d = document;
    var CONF_KEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz') + '_compactConfidence';
    var ORIG_BACKUP_KEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions') + '_backupCompactOrig';
    var PAGE_SIZE = 20;

    if(!window.__fcView) window.__fcView = { mode: 'all', page: 0, total: 0 };
    if(!window.__fcSessionMarks) window.__fcSessionMarks = {};
    if(typeof window.__fcResetActive === 'undefined') window.__fcResetActive = false;

    function readJSON(k, def){ try{ var v = localStorage.getItem(k); return v ? JSON.parse(v) : def; }catch(_e){ return def; } }
    function getOrigArray(){
      var orig = readJSON(ORIG_BACKUP_KEY, null);
      if(Array.isArray(orig) && orig.length) return orig;
      try{ if(typeof questions !== 'undefined' && questions && questions.length) return questions; }catch(_e){}
      return [];
    }
    function focusIndices(){
      // Prefer current session marks
      var picks = [];
      var hasSession = false;
      for(var k in window.__fcSessionMarks){
        if(!Object.prototype.hasOwnProperty.call(window.__fcSessionMarks, k)) continue;
        hasSession = true;
        var v = window.__fcSessionMarks[k];
        if(v === 'y' || v === 'r'){ var id = parseInt(k,10); if(!isNaN(id)) picks.push(id); }
      }
      if(!hasSession){
        // Fallback to stored CONF_KEY
        var conf = readJSON(CONF_KEY, {}) || {};
        for(var kk in conf){
          if(!Object.prototype.hasOwnProperty.call(conf, kk)) continue;
          var vv = conf[kk];
          if(vv === 'y' || vv === 'r'){ var id2 = parseInt(kk,10); if(!isNaN(id2)) picks.push(id2); }
        }
      }
      // Dedup + sort
      if(picks.length){
        var seen = {}, out = [];
        for(var i=0;i<picks.length;i++){ var id=picks[i]; if(!seen[id]){ seen[id]=1; out.push(id); } }
        out.sort(function(a,b){ return a-b; });
        return out;
      }
      return [];
    }
    function scrubMarksIfReset(){
      if(!window.__fcResetActive) return;
      var grid = d.getElementById('fc-grid'); if(!grid) return;
      var cards = grid.querySelectorAll('.fc-card');
      for(var i=0;i<cards.length;i++){
        cards[i].classList.remove('mark-g','mark-y','mark-r');
      }
    }
    function buildCard(qObj){
      var wrap = d.createElement('div'); wrap.className = 'fc-card';
      var inner = d.createElement('div'); inner.className = 'fc-inner';
      var front = d.createElement('div'); front.className = 'fc-face fc-front';
      var back = d.createElement('div'); back.className = 'fc-face fc-back';

      var qDiv = d.createElement('div'); qDiv.className = 'fc-q'; qDiv.textContent = qObj && qObj.q ? String(qObj.q) : 'Question';
      front.appendChild(qDiv);

      var aText = (qObj && qObj.c && typeof qObj.a === 'number' && qObj.c[qObj.a] != null) ? String(qObj.c[qObj.a]) : '(no answer)';
      var aDiv = d.createElement('div'); aDiv.className = 'fc-a'; aDiv.innerHTML = '<strong>Answer:</strong> ' + String(aText).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      back.appendChild(aDiv);
      if(qObj && qObj.e){ var meta = d.createElement('div'); meta.className = 'fc-meta'; meta.textContent = qObj.e; back.appendChild(meta); }

      var ctrls = d.createElement('div'); ctrls.className = 'fc-controls'; ctrls.addEventListener('click', function(ev){ ev.stopPropagation(); }, false);
      function makeBtn(txt, title, mark){ var b = d.createElement('button'); b.className = 'fc-ctrl'; b.textContent = txt; b.title = title; b.addEventListener('click', function(){ /* session marks rely on data-orig-idx set elsewhere */ }, false); return b; }
      ctrls.appendChild(makeBtn('✓','Mark Known','g'));
      ctrls.appendChild(makeBtn('—','Mark Unsure','y'));
      ctrls.appendChild(makeBtn('×','Mark Don’t know','r'));
      front.appendChild(ctrls);
      var ctrls2 = ctrls.cloneNode(true);
      back.appendChild(ctrls2);

      wrap.addEventListener('click', function(){ wrap.classList.toggle('flipped'); }, false);
      inner.appendChild(front); inner.appendChild(back); wrap.appendChild(inner);
      return wrap;
    }
    function renderFocus(page){
      var grid = d.getElementById('fc-grid'); if(!grid) return;
      var info = d.getElementById('fc-page-info');
      var orig = getOrigArray();
      var idxs = focusIndices();
      window.__fcView.mode = 'focus';
      window.__fcView.total = idxs.length;
      var totalPages = idxs.length ? Math.ceil(idxs.length / PAGE_SIZE) : 1;
      if(!page || page < 0) page = 0;
      if(page >= totalPages) page = totalPages-1;
      window.__fcView.page = page;

      grid.innerHTML = '';
      if(idxs.length === 0){
        var empty = d.createElement('div');
        empty.style.cssText = 'padding:1rem;opacity:.9';
        empty.textContent = 'No focus cards marked yet.';
        grid.appendChild(empty);
        if(info) info.textContent = 'Showing 0 of 0 — Focus';
        scrubMarksIfReset();
        return;
      }

      var start = page*PAGE_SIZE, end = Math.min(idxs.length, start+PAGE_SIZE);
      for(var i=start;i<end;i++){
        var q = orig[idxs[i]];
        grid.appendChild(buildCard(q));
      }
      if(info) info.textContent = 'Showing ' + (start+1) + '–' + end + ' of ' + idxs.length + ' — Focus';
      scrubMarksIfReset();
    }

    function hookToggle(){
      var t = d.getElementById('fc-toggle-source');
      if(!t || t.__fcToggleHooked) return;
      t.__fcToggleHooked = true;
      t.addEventListener('click', function(){
        // Wait for the original handler to run, then override grid in focus mode
        setTimeout(function(){
          if(t.textContent.indexOf('Show Focus') !== -1){
            // "All" mode active
            window.__fcView.mode = 'all';
            window.__fcView.page = 0;
          }else{
            // "Focus" mode active
            renderFocus(0);
          }
        }, 0);
      }, true); // capture
    }
    function hookPager(){
      var prev = d.getElementById('fc-prev');
      var next = d.getElementById('fc-next');
      if(prev && !prev.__fcPager){
        prev.__fcPager = true;
        prev.addEventListener('click', function(ev){
          if(window.__fcView.mode === 'focus'){
            ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
            renderFocus(Math.max(0, window.__fcView.page - 1));
            return false;
          }
        }, true);
      }
      if(next && !next.__fcPager){
        next.__fcPager = true;
        next.addEventListener('click', function(ev){
          if(window.__fcView.mode === 'focus'){
            ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
            renderFocus(window.__fcView.page + 1);
            return false;
          }
        }, true);
      }
    }
    function hookResetContinuity(){
      var rst = d.getElementById('fc-reset-marks');
      if(!rst || rst.__fcResetHook) return;
      rst.__fcResetHook = true;
      rst.addEventListener('click', function(){
        try{ window.__fcSessionMarks = {}; }catch(_e){}
        try{ localStorage.setItem(CONF_KEY, JSON.stringify({})); }catch(_e){}
        window.__fcResetActive = true;
        // Scrub now and on future renders until the user marks again
        scrubMarksIfReset();
        if(window.__fcView.mode === 'focus'){
          renderFocus(0);
        }else{
          // all-mode: scrub after any mutation
          setTimeout(scrubMarksIfReset, 0);
        }
      }, true);
    }
    function observeRenders(){
      if(window.__fcRenderObserver) return;
      if('MutationObserver' in window){
        window.__fcRenderObserver = new MutationObserver(function(){
          if(window.__fcView.mode === 'focus'){
            // keep the grid consistent (e.g., after page change from other code)
            // no-op; our pager already intercepts in focus mode
          }else{
            scrubMarksIfReset();
          }
          hookToggle(); hookPager(); hookResetContinuity();
        });
        window.__fcRenderObserver.observe(d.documentElement, { childList: true, subtree: true });
      }
    }
    function boot(){
      hookToggle(); hookPager(); hookResetContinuity(); observeRenders();
      // If user switches to Focus via existing default, enforce our renderer
      var t = d.getElementById('fc-toggle-source');
      if(t && t.textContent.indexOf('Show Focus') === -1){
        // Focus is active
        setTimeout(function(){ renderFocus(0); }, 0);
      }
    }
    if(d.readyState === 'loading'){ d.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true }); }
    else { setTimeout(boot, 0); }
  }catch(_e){}
})();



// PATCH: Deterministic Focus by hash + Reset continuity
(function(){
  try{
    var d = document;
    var ORIG_BACKUP_KEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions') + '_backupCompactOrig';
    var CONF_KEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz') + '_compactConfidence';
    var SKIP_FLAG = '__skipWelcomeOnce';
    var PAGE_SIZE = 20;

    if(!window.__fcMarkHash) window.__fcMarkHash = {};   // { hash: 'g'|'y'|'r' }
    if(!window.__fcSessionMarks) window.__fcSessionMarks = {}; // legacy index map

    function norm(s){ return String(s || '').replace(/\s+/g,' ').trim().toLowerCase(); }
    function qHashObj(q){
      var qt = norm(q && q.q);
      var ans = (q && q.c && typeof q.a === 'number' && q.c[q.a] != null) ? q.c[q.a] : '';
      var at = norm(ans);
      // Simple 32-bit hash
      var str = qt + '||' + at; var h = 0;
      for(var i=0;i<str.length;i++){ h = (h*31 + str.charCodeAt(i))|0; }
      return 'h' + (h>>>0).toString(16);
    }
    function cardHashFromDOM(card){
      var qEl = card.querySelector('.fc-q'); var aEl = card.querySelector('.fc-a');
      var qt = qEl ? qEl.textContent : ''; var at = aEl ? aEl.textContent.replace(/^Answer:\s*/i,'') : '';
      var str = norm(qt) + '||' + norm(at); var h = 0;
      for(var i=0;i<str.length;i++){ h = (h*31 + str.charCodeAt(i))|0; }
      return 'h' + (h>>>0).toString(16);
    }
    function getOrig(){
      try{
        var orig = null;
        try{ orig = JSON.parse(localStorage.getItem(ORIG_BACKUP_KEY) || 'null'); }catch(_e){}
        if(Array.isArray(orig) && orig.length) return orig;
        if(typeof questions !== 'undefined' && questions && questions.length) return questions;
      }catch(_e){}
      return [];
    }

    // A) Capture triage marks into hash map
    function armMarkCapture(){
      if(d.__fcHashCapture) return;
      d.__fcHashCapture = true;
      d.addEventListener('click', function(ev){
        var t = ev.target;
        if(!t || !t.classList || !t.classList.contains('fc-ctrl')) return;
        var card = t.closest('.fc-card'); if(!card) return;
        var h = cardHashFromDOM(card);
        var txt = (t.textContent || '').trim();
        var mark = (txt === '✓') ? 'g' : (txt === '—' ? 'y' : (txt === '×' ? 'r' : null));
        if(!mark) return;
        window.__fcMarkHash[h] = mark;
      }, true); // capture
    }

    // B) Focus view uses only hash-based marks
    function focusIdxByHash(){
      var orig = getOrig(); var out = [];
      for(var i=0;i<orig.length;i++){
        var q = orig[i]; var h = qHashObj(q);
        var m = window.__fcMarkHash[h];
        if(m === 'y' || m === 'r') out.push(i);
      }
      return out;
    }

    function renderFocus(){
      var grid = d.getElementById('fc-grid'); if(!grid) return;
      var info = d.getElementById('fc-page-info');
      var orig = getOrig(); var idxs = focusIdxByHash();
      var page = (window.__fcView && window.__fcView.page) || 0;
      var totalPages = idxs.length ? Math.ceil(idxs.length / PAGE_SIZE) : 1;
      if(page < 0) page = 0; if(page >= totalPages) page = totalPages-1;
      if(!window.__fcView) window.__fcView = { mode:'focus', page:page };
      window.__fcView.mode = 'focus'; window.__fcView.page = page;

      grid.innerHTML = '';
      if(idxs.length === 0){
        var empty = d.createElement('div');
        empty.style.cssText = 'padding:1rem;opacity:.9';
        empty.textContent = 'No focus cards marked yet.';
        grid.appendChild(empty);
        if(info) info.textContent = 'Showing 0 of 0 — Focus';
        return;
      }
      var start = page*PAGE_SIZE, end = Math.min(idxs.length, start+PAGE_SIZE);
      for(var i=start;i<end;i++){
        var q = orig[idxs[i]];
        grid.appendChild(buildCardFromQ(q));
      }
      if(info) info.textContent = 'Showing ' + (start+1) + '–' + end + ' of ' + idxs.length + ' — Focus';
    }

    function buildCardFromQ(q){
      var wrap = d.createElement('div'); wrap.className = 'fc-card';
      var inner = d.createElement('div'); inner.className = 'fc-inner';
      var front = d.createElement('div'); front.className = 'fc-face fc-front';
      var back = d.createElement('div'); back.className = 'fc-face fc-back';

      var qDiv = d.createElement('div'); qDiv.className = 'fc-q'; qDiv.textContent = q && q.q ? String(q.q) : 'Question';
      front.appendChild(qDiv);

      var aText = (q && q.c && typeof q.a === 'number' && q.c[q.a] != null) ? String(q.c[q.a]) : '(no answer)';
      var aDiv = d.createElement('div'); aDiv.className = 'fc-a'; aDiv.innerHTML = '<strong>Answer:</strong> ' + String(aText).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      back.appendChild(aDiv);
      if(q && q.e){ var meta = d.createElement('div'); meta.className = 'fc-meta'; meta.textContent = q.e; back.appendChild(meta); }

      var ctrls = d.createElement('div'); ctrls.className = 'fc-controls'; ctrls.addEventListener('click', function(ev){ ev.stopPropagation(); }, false);
      function mk(txt){ var b=d.createElement('button'); b.className='fc-ctrl'; b.textContent=txt; return b; }
      ctrls.appendChild(mk('✓')); ctrls.appendChild(mk('—')); ctrls.appendChild(mk('×'));
      front.appendChild(ctrls);
      var ctrls2 = ctrls.cloneNode(true); back.appendChild(ctrls2);

      wrap.addEventListener('click', function(){ wrap.classList.toggle('flipped'); }, false);
      inner.appendChild(front); inner.appendChild(back); wrap.appendChild(inner);
      return wrap;
    }

    // C) Pager + toggle wiring for focus mode
    function hookPagerAndToggle(){
      var prev = d.getElementById('fc-prev');
      var next = d.getElementById('fc-next');
      var tog  = d.getElementById('fc-toggle-source');

      if(prev && !prev.__fcHashPage){
        prev.__fcHashPage = true;
        prev.addEventListener('click', function(ev){
          if(window.__fcView && window.__fcView.mode === 'focus'){
            ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
            window.__fcView.page = Math.max(0, (window.__fcView.page||0) - 1);
            renderFocus();
            return false;
          }
        }, true);
      }
      if(next && !next.__fcHashPage){
        next.__fcHashPage = true;
        next.addEventListener('click', function(ev){
          if(window.__fcView && window.__fcView.mode === 'focus'){
            ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
            window.__fcView.page = (window.__fcView.page||0) + 1;
            renderFocus();
            return false;
          }
        }, true);
      }
      if(tog && !tog.__fcHashToggle){
        tog.__fcHashToggle = true;
        tog.addEventListener('click', function(){
          setTimeout(function(){
            if(tog.textContent.indexOf('Show Focus') !== -1){
              // now in All mode
              if(window.__fcResetActive){
                // scrub any marks that UI might try to apply
                scrubMarksRepeated();
              }
              if(window.__fcView) window.__fcView.mode = 'all';
            }else{
              // switched to Focus mode
              renderFocus();
            }
          }, 0);
        }, true);
      }
    }

    // D) Start Focus Quiz using hash-selected questions only
    function interceptStartFocus(){
      var btn = d.getElementById('fc-start-focus');
      if(!btn || btn.__fcHashStart) return;
      btn.__fcHashStart = true;
      btn.addEventListener('click', function(ev){
        // Build subset from ORIG using hash map
        var orig = getOrig();
        var picks = [];
        for(var i=0;i<orig.length;i++){
          var h = qHashObj(orig[i]);
          var m = window.__fcMarkHash[h];
          if(m === 'y' || m === 'r') picks.push(i);
        }
        if(picks.length === 0){
          ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
          try{ alert('Mark some yellow (—) or red (×) cards first.'); }catch(_e){}
          return false;
        }
        var subset = [];
        for(var j=0;j<picks.length;j++){ subset.push(orig[picks[j]]); }
        try{
          if(typeof QUESTIONS_KEY === 'string'){
            localStorage.setItem(QUESTIONS_KEY, JSON.stringify(subset));
          }
          localStorage.setItem(SKIP_FLAG, '1');
        }catch(_e){}
        try{ location.reload(); }catch(_e){}
        ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
        return false;
      }, true);
    }

    // E) Reset continuity: clear both maps, storage, and hot-reopen overlay clean
    function hookReset(){
      var rst = d.getElementById('fc-reset-marks');
      if(!rst || rst.__fcHashReset) return;
      rst.__fcHashReset = true;
      rst.addEventListener('click', function(){
        window.__fcMarkHash = {};
        window.__fcSessionMarks = {};
        try{ localStorage.setItem(CONF_KEY, JSON.stringify({})); }catch(_e){}

        window.__fcResetActive = true;
        // scrub now and for a moment after toggles/renders
        scrubMarksRepeated();
        // Close & reopen overlay to drop any cached state
        var ov = d.getElementById('compact-overlay');
        var cb = d.getElementById('compact-btn');
        if(ov && cb){
          ov.style.display = 'none';
          setTimeout(function(){ cb.click(); }, 50);
        }
      }, true);
    }

    function scrubMarksRepeated(){
      var t0 = Date.now();
      (function loop(){
        var grid = d.getElementById('fc-grid');
        if(grid){
          var cards = grid.querySelectorAll('.fc-card');
          for(var i=0;i<cards.length;i++){ cards[i].classList.remove('mark-g','mark-y','mark-r'); }
        }
        if(Date.now() - t0 < 1200){ setTimeout(loop, 60); }
      })();
    }

    // Observe DOM to wire up after overlay injection
    if('MutationObserver' in window){
      var mo = new MutationObserver(function(){
        armMarkCapture(); hookPagerAndToggle(); interceptStartFocus(); hookReset();
      });
      mo.observe(d.documentElement, { childList: true, subtree: true });
    }
    // Initial pass
    setTimeout(function(){ armMarkCapture(); hookPagerAndToggle(); interceptStartFocus(); hookReset(); }, 0);
  }catch(_e){}
})();



// PATCH: Deterministic Focus set + Mark continuity across toggles
(function(){
  try{
    var d = document;
    var BASE_KEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions') + '_baseFullSet';
    var ORIG_BACKUP_KEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions') + '_backupCompactOrig';
    var MARK_HASH_KEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz') + '_compactMarkHash';
    var PAGE_SIZE = 20;
    var SKIP_FLAG = '__skipWelcomeOnce';

    // --- Utilities ---
    function readJSON(k, def){ try{ var v = localStorage.getItem(k); return v ? JSON.parse(v) : def; }catch(_e){ return def; } }
    function writeJSON(k, val){ try{ localStorage.setItem(k, JSON.stringify(val)); }catch(_e){} }
    function norm(s){ return String(s || '').replace(/\s+/g,' ').trim().toLowerCase(); }
    function qHash(q){
      var qt = norm(q && q.q);
      var ans = (q && q.c && typeof q.a === 'number' && q.c[q.a] != null) ? q.c[q.a] : '';
      var at = norm(ans);
      var str = qt + '||' + at; var h = 0;
      for(var i=0;i<str.length;i++){ h = (h*31 + str.charCodeAt(i))|0; }
      return 'h' + (h>>>0).toString(16);
    }
    function hashFromCard(card){
      var qEl = card.querySelector('.fc-q'); var aEl = card.querySelector('.fc-a');
      var qt = qEl ? qEl.textContent : ''; var at = aEl ? aEl.textContent.replace(/^Answer:\s*/i,'') : '';
      var str = norm(qt) + '||' + norm(at); var h = 0;
      for(var i=0;i<str.length;i++){ h = (h*31 + str.charCodeAt(i))|0; }
      return 'h' + (h>>>0).toString(16);
    }
    function getBase(){
      // Prefer saved base; else backup orig; else current questions
      var base = readJSON(BASE_KEY, null);
      if(Array.isArray(base) && base.length) return base;
      var bak = readJSON(ORIG_BACKUP_KEY, null);
      if(Array.isArray(bak) && bak.length){ writeJSON(BASE_KEY, bak); return bak; }
      try{
        if(typeof questions !== 'undefined' && questions && questions.length){
          writeJSON(BASE_KEY, questions);
          return questions;
        }
      }catch(_e){}
      return [];
    }
    function ensureBaseSaved(){
      var base = readJSON(BASE_KEY, null);
      if(Array.isArray(base) && base.length) return;
      // Save a snapshot of the fullest set we can see
      var bak = readJSON(ORIG_BACKUP_KEY, null);
      if(Array.isArray(bak) && bak.length){ writeJSON(BASE_KEY, bak); return; }
      try{ if(typeof questions !== 'undefined' && questions && questions.length) writeJSON(BASE_KEY, questions); }catch(_e){}
    }

    // --- Mark storage ---
    if(!window.__fcMarkHash) window.__fcMarkHash = readJSON(MARK_HASH_KEY, {}) || {};
    function setMarkHash(h, mark){
      if(!h) return;
      if(mark == null){ delete window.__fcMarkHash[h]; }
      else { window.__fcMarkHash[h] = mark; }
      writeJSON(MARK_HASH_KEY, window.__fcMarkHash);
    }

    // Capture marks from both faces' controls
    function armMarkCapture(){
      if(d.__fcHashMarkCap) return;
      d.__fcHashMarkCap = true;
      d.addEventListener('click', function(ev){
        var t = ev.target;
        if(!t || !t.classList || !t.classList.contains('fc-ctrl')) return;
        var card = t.closest('.fc-card'); if(!card) return;
        var h = hashFromCard(card);
        var txt = (t.textContent || '').trim();
        var mark = (txt === '✓') ? 'g' : (txt === '—' ? 'y' : (txt === '×' ? 'r' : null));
        if(!mark) return;
        setMarkHash(h, mark);
        applyMarksToGrid(); // reflect immediately in All view
      }, true);
    }

    // --- Visual continuity: apply classes based on hash marks ---
    function applyMarksToGrid(){
      var grid = d.getElementById('fc-grid'); if(!grid) return;
      var cards = grid.querySelectorAll('.fc-card');
      for(var i=0;i<cards.length;i++){
        var c = cards[i];
        c.classList.remove('mark-g','mark-y','mark-r');
        var h = hashFromCard(c);
        var m = window.__fcMarkHash[h];
        if(m === 'g') c.classList.add('mark-g');
        else if(m === 'y') c.classList.add('mark-y');
        else if(m === 'r') c.classList.add('mark-r');
      }
    }

    // --- Focus view built strictly from marked hashes against Base ---
    function getFocusIndices(){
      var base = getBase(); var out = [];
      for(var i=0;i<base.length;i++){
        var h = qHash(base[i]);
        var m = window.__fcMarkHash[h];
        if(m === 'y' || m === 'r') out.push(i);
      }
      return out;
    }
    function renderFocus(page){
      ensureBaseSaved();
      var grid = d.getElementById('fc-grid'); if(!grid) return;
      var info = d.getElementById('fc-page-info');
      var base = getBase(); var idxs = getFocusIndices();
      var totalPages = idxs.length ? Math.ceil(idxs.length / PAGE_SIZE) : 1;
      if(!page || page < 0) page = 0;
      if(page >= totalPages) page = totalPages-1;
      if(!window.__fcView) window.__fcView = { mode:'focus', page:page };
      window.__fcView.mode = 'focus'; window.__fcView.page = page;

      grid.innerHTML = '';
      if(idxs.length === 0){
        var empty = d.createElement('div'); empty.style.cssText = 'padding:1rem;opacity:.9'; empty.textContent = 'No focus cards marked yet.';
        grid.appendChild(empty);
        if(info) info.textContent = 'Showing 0 of 0 — Focus';
        return;
      }
      var start = page*PAGE_SIZE, end = Math.min(idxs.length, start+PAGE_SIZE);
      for(var i=start;i<end;i++){
        var q = base[idxs[i]];
        grid.appendChild(buildCardFromQ(q));
      }
      if(info) info.textContent = 'Showing ' + (start+1) + '–' + end + ' of ' + idxs.length + ' — Focus';
      applyMarksToGrid();
    }
    function buildCardFromQ(q){
      var wrap = d.createElement('div'); wrap.className = 'fc-card';
      var inner = d.createElement('div'); inner.className = 'fc-inner';
      var front = d.createElement('div'); front.className = 'fc-face fc-front';
      var back = d.createElement('div'); back.className = 'fc-face fc-back';

      var qDiv = d.createElement('div'); qDiv.className = 'fc-q'; qDiv.textContent = q && q.q ? String(q.q) : 'Question';
      front.appendChild(qDiv);
      var aText = (q && q.c && typeof q.a === 'number' && q.c[q.a] != null) ? String(q.c[q.a]) : '(no answer)';
      var aDiv = d.createElement('div'); aDiv.className = 'fc-a'; aDiv.innerHTML = '<strong>Answer:</strong> ' + String(aText).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      back.appendChild(aDiv);
      if(q && q.e){ var meta = d.createElement('div'); meta.className = 'fc-meta'; meta.textContent = q.e; back.appendChild(meta); }

      var ctrls = d.createElement('div'); ctrls.className = 'fc-controls'; ctrls.addEventListener('click', function(ev){ ev.stopPropagation(); }, false);
      function mk(txt){ var b=d.createElement('button'); b.className='fc-ctrl'; b.textContent=txt; return b; }
      ctrls.appendChild(mk('✓')); ctrls.appendChild(mk('—')); ctrls.appendChild(mk('×'));
      front.appendChild(ctrls);
      var ctrls2 = ctrls.cloneNode(true); back.appendChild(ctrls2);

      wrap.addEventListener('click', function(){ wrap.classList.toggle('flipped'); }, false);
      inner.appendChild(front); inner.appendChild(back); wrap.appendChild(inner);
      return wrap;
    }

    // Toggle + pager hooks to swap between All and Focus views seamlessly
    function hookToggleAndPager(){
      var tog = d.getElementById('fc-toggle-source');
      var prev = d.getElementById('fc-prev');
      var next = d.getElementById('fc-next');
      if(tog && !tog.__fcHashToggle){
        tog.__fcHashToggle = true;
        tog.addEventListener('click', function(){
          setTimeout(function(){
            // If button now reads "Show Focus Cards", All mode is active
            if(tog.textContent.indexOf('Show Focus') !== -1){
              if(window.__fcView) window.__fcView.mode = 'all';
              applyMarksToGrid();
            }else{
              renderFocus(0);
            }
          }, 0);
        }, true);
      }
      if(prev && !prev.__fcHashPager){
        prev.__fcHashPager = true;
        prev.addEventListener('click', function(ev){
          if(window.__fcView && window.__fcView.mode === 'focus'){
            ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
            window.__fcView.page = Math.max(0, (window.__fcView.page||0) - 1);
            renderFocus(window.__fcView.page);
            return false;
          }
        }, true);
      }
      if(next && !next.__fcHashPager){
        next.__fcHashPager = true;
        next.addEventListener('click', function(ev){
          if(window.__fcView && window.__fcView.mode === 'focus'){
            ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
            window.__fcView.page = (window.__fcView.page||0) + 1;
            renderFocus(window.__fcView.page);
            return false;
          }
        }, true);
      }
    }

    // Start Focus Quiz: subset strictly from Base by hash marks
    function interceptStartFocus(){
      var btn = d.getElementById('fc-start-focus');
      if(!btn || btn.__fcHashStart) return;
      btn.__fcHashStart = true;
      btn.addEventListener('click', function(ev){
        ensureBaseSaved();
        var base = getBase(); var picks = [];
        for(var i=0;i<base.length;i++){
          var h = qHash(base[i]); var m = window.__fcMarkHash[h];
          if(m === 'y' || m === 'r') picks.push(i);
        }
        if(picks.length === 0){
          ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
          try{ alert('Mark some yellow (—) or red (×) cards first.'); }catch(_e){}
          return false;
        }
        var subset = [];
        for(var j=0;j<picks.length;j++){ subset.push(base[picks[j]]); }
        try{
          if(typeof QUESTIONS_KEY === 'string'){
            localStorage.setItem(QUESTIONS_KEY, JSON.stringify(subset));
          }
          localStorage.setItem(SKIP_FLAG, '1');
        }catch(_e){}
        try{ location.reload(); }catch(_e){}
        ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
        return false;
      }, true);
    }

    // Reset: clear persist + memory only; do NOT scrub visuals on toggle unless reset pressed
    function interceptReset(){
      var rst = d.getElementById('fc-reset-marks');
      if(!rst || rst.__fcHashReset) return;
      rst.__fcHashReset = true;
      rst.addEventListener('click', function(){
        window.__fcMarkHash = {};
        writeJSON(MARK_HASH_KEY, {});
        // wipe classes now
        var grid = d.getElementById('fc-grid');
        if(grid){
          var cards = grid.querySelectorAll('.fc-card');
          for(var i=0;i<cards.length;i++){
            cards[i].classList.remove('mark-g','mark-y','mark-r');
          }
        }
      }, true);
    }

    // Observe and wire up after overlay creation & on re-renders
    if('MutationObserver' in window){
      var mo = new MutationObserver(function(){
        ensureBaseSaved();
        armMarkCapture();
        applyMarksToGrid();
        hookToggleAndPager();
        interceptStartFocus();
        interceptReset();
      });
      mo.observe(d.documentElement, { childList: true, subtree: true });
    }
    // Initial pass
    setTimeout(function(){
      ensureBaseSaved();
      armMarkCapture();
      applyMarksToGrid();
      hookToggleAndPager();
      interceptStartFocus();
      interceptReset();
    }, 0);
  }catch(_e){}
})();



// PATCH: Focus by signature + strong mark continuity
(function(){
  try{
    var d = document;
    var QUESTIONS_BASE_KEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions') + '_baseFullSet';
    var QUESTIONS_BACKUP_KEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions') + '_backupCompactOrig';
    var MARK_HASH_KEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz') + '_compactMarkHash'; // legacy
    var MARK_SIG_KEY  = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz') + '_compactMarkSig';  // new canonical
    var SKIP_FLAG = '__skipWelcomeOnce';
    var PAGE = 20;

    function readJSON(k, def){ try{ var v = localStorage.getItem(k); return v ? JSON.parse(v) : def; }catch(_e){ return def; } }
    function writeJSON(k, val){ try{ localStorage.setItem(k, JSON.stringify(val)); }catch(_e){} }
    function norm(s){ return String(s||'').replace(/\s+/g,' ').trim().toLowerCase(); }
    function getBase(){
      var base = readJSON(QUESTIONS_BASE_KEY, null);
      if(Array.isArray(base) && base.length) return base;
      var bak = readJSON(QUESTIONS_BACKUP_KEY, null);
      if(Array.isArray(bak) && bak.length){ writeJSON(QUESTIONS_BASE_KEY, bak); return bak; }
      try{ if(typeof questions !== 'undefined' && questions && questions.length){ writeJSON(QUESTIONS_BASE_KEY, questions); return questions; } }catch(_e){}
      return [];
    }
    function ensureBase(){
      var base = readJSON(QUESTIONS_BASE_KEY, null);
      if(Array.isArray(base) && base.length) return;
      var bak = readJSON(QUESTIONS_BACKUP_KEY, null);
      if(Array.isArray(bak) && bak.length){ writeJSON(QUESTIONS_BASE_KEY, bak); return; }
      try{ if(typeof questions !== 'undefined' && questions && questions.length){ writeJSON(QUESTIONS_BASE_KEY, questions); } }catch(_e){}
    }

    function sigFromQ(q){
      var qt = norm(q && q.q);
      var ans = (q && q.c && typeof q.a === 'number' && q.c[q.a] != null) ? q.c[q.a] : '';
      var at = norm(ans);
      return qt + '||' + at;
    }
    function sigFromCard(card){
      var qEl = card.querySelector('.fc-q');
      var aEl = card.querySelector('.fc-a');
      var qt = qEl ? qEl.textContent : '';
      var at = aEl ? aEl.textContent.replace(/^Answer:\s*/i,'') : '';
      return norm(qt) + '||' + norm(at);
    }

    // In-memory caches
    if(!window.__markSig) window.__markSig = readJSON(MARK_SIG_KEY, {}) || {};
    if(!window.__markHash) window.__markHash = readJSON(MARK_HASH_KEY, {}) || {};

    function setMarkBySig(sig, mark){
      if(!sig) return;
      if(mark == null) delete window.__markSig[sig];
      else window.__markSig[sig] = mark;
      writeJSON(MARK_SIG_KEY, window.__markSig);
    }
    function getMarkBySig(sig){
      var m = window.__markSig[sig];
      if(m) return m;
      // Legacy fallback via hash if necessary
      var base = getBase();
      for(var i=0;i<base.length;i++){
        if(sigFromQ(base[i]) === sig){
          var qt = norm(base[i] && base[i].q);
          var ans = (base[i] && base[i].c && typeof base[i].a === 'number' && base[i].c[base[i].a] != null) ? base[i].c[base[i].a] : '';
          var at = norm(ans);
          var str = qt + '||' + at; var h = 0;
          for(var j=0;j<str.length;j++){ h = (h*31 + str.charCodeAt(j))|0; } h = 'h' + (h>>>0).toString(16);
          return window.__markHash[h];
        }
      }
      return undefined;
    }

    // Capture marks (✓/—/×) and persist by signature (and keep legacy hash in sync)
    function armMarkCapture(){
      if(d.__sigMarkCap) return;
      d.__sigMarkCap = true;
      d.addEventListener('click', function(ev){
        var t = ev.target;
        if(!t || !t.classList || !t.classList.contains('fc-ctrl')) return;
        var card = t.closest('.fc-card'); if(!card) return;
        var sig = sigFromCard(card);
        var txt = (t.textContent || '').trim();
        var mark = (txt === '✓') ? 'g' : (txt === '—' ? 'y' : (txt === '×' ? 'r' : null));
        if(!mark) return;
        setMarkBySig(sig, mark);
        applyMarksRepeated();
      }, true);
    }

    function applyMarksToGrid(){
      var grid = d.getElementById('fc-grid'); if(!grid) return;
      var cards = grid.querySelectorAll('.fc-card');
      for(var i=0;i<cards.length;i++){
        var c = cards[i];
        c.classList.remove('mark-g','mark-y','mark-r');
        var sig = sigFromCard(c);
        var m = getMarkBySig(sig);
        if(m === 'g') c.classList.add('mark-g');
        else if(m === 'y') c.classList.add('mark-y');
        else if(m === 'r') c.classList.add('mark-r');
      }
    }
    function applyMarksRepeated(){
      var start = Date.now();
      (function tick(){
        applyMarksToGrid();
        if(Date.now() - start < 1200) setTimeout(tick, 60);
      })();
    }

    // Focus view driven strictly by signature marks against Base
    function focusIndices(){
      var base = getBase(); var out = [];
      for(var i=0;i<base.length;i++){
        var sig = sigFromQ(base[i]);
        var m = getMarkBySig(sig);
        if(m === 'y' || m === 'r') out.push(i);
      }
      return out;
    }
    function renderFocus(page){
      ensureBase();
      var grid = d.getElementById('fc-grid'); if(!grid) return;
      var info = d.getElementById('fc-page-info');
      var base = getBase(); var idxs = focusIndices();
      var total = idxs.length ? Math.ceil(idxs.length / PAGE) : 1;
      if(!page || page < 0) page = 0;
      if(page >= total) page = total-1;
      window.__fcView = window.__fcView || { mode:'focus', page:0 };
      window.__fcView.mode = 'focus'; window.__fcView.page = page;

      grid.innerHTML = '';
      if(idxs.length === 0){
        var empty = d.createElement('div'); empty.style.cssText='padding:1rem;opacity:.9'; empty.textContent='No focus cards marked yet.';
        grid.appendChild(empty);
        if(info) info.textContent = 'Showing 0 of 0 — Focus';
        return;
      }
      var start = page*PAGE, end = Math.min(idxs.length, start+PAGE);
      for(var i=start;i<end;i++){
        var q = base[idxs[i]];
        grid.appendChild(buildCardFromQ(q));
      }
      if(info) info.textContent = 'Showing ' + (start+1) + '–' + end + ' of ' + idxs.length + ' — Focus';
      applyMarksRepeated();
    }
    function buildCardFromQ(q){
      var wrap = d.createElement('div'); wrap.className = 'fc-card';
      var inner = d.createElement('div'); inner.className = 'fc-inner';
      var front = d.createElement('div'); front.className = 'fc-face fc-front';
      var back = d.createElement('div'); back.className = 'fc-face fc-back';
      var qDiv = d.createElement('div'); qDiv.className = 'fc-q'; qDiv.textContent = q && q.q ? String(q.q) : 'Question';
      front.appendChild(qDiv);
      var aText = (q && q.c && typeof q.a === 'number' && q.c[q.a] != null) ? String(q.c[q.a]) : '(no answer)';
      var aDiv = d.createElement('div'); aDiv.className = 'fc-a'; aDiv.innerHTML = '<strong>Answer:</strong> ' + String(aText).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      back.appendChild(aDiv);
      if(q && q.e){ var meta = d.createElement('div'); meta.className = 'fc-meta'; meta.textContent = q.e; back.appendChild(meta); }
      var ctrls = d.createElement('div'); ctrls.className = 'fc-controls'; ctrls.addEventListener('click', function(ev){ ev.stopPropagation(); }, false);
      function mk(t){ var b=d.createElement('button'); b.className='fc-ctrl'; b.textContent=t; return b; }
      ctrls.appendChild(mk('✓')); ctrls.appendChild(mk('—')); ctrls.appendChild(mk('×'));
      front.appendChild(ctrls);
      var ctrls2 = ctrls.cloneNode(true); back.appendChild(ctrls2);
      wrap.addEventListener('click', function(){ wrap.classList.toggle('flipped'); }, false);
      inner.appendChild(front); inner.appendChild(back); wrap.appendChild(inner);
      return wrap;
    }

    // Toggle + pager
    function hookToggleAndPager(){
      var tog = d.getElementById('fc-toggle-source');
      var prev = d.getElementById('fc-prev');
      var next = d.getElementById('fc-next');
      if(tog && !tog.__sigToggle){
        tog.__sigToggle = true;
        tog.addEventListener('click', function(){
          setTimeout(function(){
            if(tog.textContent.indexOf('Show Focus') !== -1){
              window.__fcView = { mode:'all', page:0 };
              applyMarksRepeated();
            }else{
              renderFocus(0);
            }
          }, 0);
        }, true);
      }
      if(prev && !prev.__sigPage){
        prev.__sigPage = true;
        prev.addEventListener('click', function(ev){
          if(window.__fcView && window.__fcView.mode === 'focus'){
            ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
            var p = (window.__fcView.page||0) - 1; if(p < 0) p = 0;
            renderFocus(p);
            return false;
          }
        }, true);
      }
      if(next && !next.__sigPage){
        next.__sigPage = true;
        next.addEventListener('click', function(ev){
          if(window.__fcView && window.__fcView.mode === 'focus'){
            ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
            var p = (window.__fcView.page||0) + 1;
            renderFocus(p);
            return false;
          }
        }, true);
      }
    }

    // Start Focused Quiz strictly by signature marks (yellow/red)
    function interceptStartFocus(){
      var btn = d.getElementById('fc-start-focus');
      if(!btn || btn.__sigStart) return;
      btn.__sigStart = true;
      btn.addEventListener('click', function(ev){
        ensureBase();
        var base = getBase();
        var picks = [];
        for(var i=0;i<base.length;i++){
          var m = getMarkBySig(sigFromQ(base[i]));
          if(m === 'y' || m === 'r') picks.push(i);
        }
        if(picks.length === 0){
          ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
          try{ alert('Mark some yellow (—) or red (×) cards first.'); }catch(_e){}
          return false;
        }
        var subset = [];
        for(var j=0;j<picks.length;j++){ subset.push(base[picks[j]]); }
        try{
          if(typeof QUESTIONS_KEY === 'string'){ localStorage.setItem(QUESTIONS_KEY, JSON.stringify(subset)); }
          localStorage.setItem(SKIP_FLAG, '1');
        }catch(_e){}
        try{ location.reload(); }catch(_e){}
        ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
        return false;
      }, true);
    }

    // Reset clears BOTH stores and visuals; stays cleared through toggles
    function interceptReset(){
      var rst = d.getElementById('fc-reset-marks');
      if(!rst || rst.__sigReset) return;
      rst.__sigReset = true;
      rst.addEventListener('click', function(){
        window.__markSig = {}; window.__markHash = {};
        writeJSON(MARK_SIG_KEY, {}); writeJSON(MARK_HASH_KEY, {});
        applyMarksRepeated();
      }, true);
    }

    // Observe to keep continuity across re-renders
    if('MutationObserver' in window){
      var mo = new MutationObserver(function(){
        armMarkCapture();
        hookToggleAndPager();
        interceptStartFocus();
        interceptReset();
        applyMarksToGrid();
      });
      mo.observe(d.documentElement, { childList:true, subtree:true });
    }
    // Initial pass
    setTimeout(function(){
      armMarkCapture();
      hookToggleAndPager();
      interceptStartFocus();
      interceptReset();
      applyMarksRepeated();
    }, 0);
  }catch(_e){}
})();


// PATCH: Welcome overlay instructions inline + guard against bypass
(function(){
  try{
    var d = document;
    function ensureWelcomeInstrInline(){
      var card = d.getElementById('welcome-card');
      if(!card) return null;
      var inline = d.getElementById('welcome-instr-inline');
      if(!inline){
        inline = d.createElement('div');
        inline.id = 'welcome-instr-inline';
        var title = d.createElement('h3');
        title.textContent = 'Instructions';
        inline.appendChild(title);
        var ta = d.createElement('textarea');
        var srcTA = d.getElementById('instr-ta');
        if(srcTA && typeof srcTA.value === 'string' && srcTA.value.trim()){
          ta.value = srcTA.value;
        }else{
          var panel = d.getElementById('instr-panel');
          if(panel){
            var t = panel.querySelector('textarea');
            if(t && t.value) ta.value = t.value;
          }
        }
        inline.appendChild(ta);
        var copyBtn = d.createElement('button');
        copyBtn.id = 'welcome-instr-copy';
        copyBtn.textContent = 'Copy';
        copyBtn.addEventListener('click', function(){
          try{
            ta.focus(); ta.select();
            if(document.execCommand && document.execCommand('copy')) return;
          }catch(_e){}
          try{ navigator.clipboard.writeText(ta.value||''); }catch(__e){}
        }, false);
        inline.appendChild(copyBtn);
        card.appendChild(inline);
      } else {
        inline.style.display = 'block';
      }
      return inline;
    }
    function attach(){
      var btn = d.getElementById('welcome-open-instr');
      if(!btn || btn.__keepOnOverlay) return;
      btn.__keepOnOverlay = true;
      btn.addEventListener('click', function(ev){
        ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
        ensureWelcomeInstrInline();
      }, true);
    }
    if(d.readyState === 'loading'){
      d.addEventListener('DOMContentLoaded', function(){ setTimeout(attach, 0); }, { once: true });
    } else {
      setTimeout(attach, 0);
    }
  }catch(_e){}
})();

// PATCH: Gate Start Quiz on welcome + Restore Original Quiz button
(function(){
  try{
    var d = document;
    var SKIP_FLAG = '__skipWelcomeOnce';
    var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
    var BACKUP_KEY = QKEY + '_backupCompactOrig';
    var BASE_KEY = QKEY + '_baseFullSet';

    function hasUploadedJSON(){
      try{
        var raw = localStorage.getItem(QKEY);
        if(!raw) return false;
        var data = JSON.parse(raw);
        return Array.isArray(data) && data.length > 0;
      }catch(_e){ return false; }
    }

    function ensureBackup(){
      try{
        if(!hasUploadedJSON()) return;
        if(!localStorage.getItem(BACKUP_KEY)){
          var raw = localStorage.getItem(QKEY);
          if(raw != null) localStorage.setItem(BACKUP_KEY, raw);
        }
        if(!localStorage.getItem(BASE_KEY)){
          var raw2 = localStorage.getItem(QKEY);
          if(raw2 != null) localStorage.setItem(BASE_KEY, raw2);
        }
      }catch(_e){}
    }

    function updateWelcomeStartBtn(){
      try{
        var btn = d.getElementById('welcome-start-btn');
        if(!btn) return;
        var ok = hasUploadedJSON();
        btn.disabled = !ok;
        btn.setAttribute('aria-disabled', (!ok).toString());
        if(!btn.__origTitle) btn.__origTitle = btn.title || 'Start Quiz';
        btn.title = ok ? btn.__origTitle : 'upload json file first to start';
      }catch(_e){}
    }

    function gateOnOverlayShow(){
      // If the welcome overlay is shown after a reset, keep Start disabled if no JSON
      try{
        var ov = d.getElementById('welcome-overlay');
        if(!ov) return;
        // Observe visibility changes
        if(!ov.__observer){
          var mo = new MutationObserver(function(){ updateWelcomeStartBtn(); });
          mo.observe(ov, { attributes: true, attributeFilter: ['style','class'] });
          ov.__observer = mo;
        }
      }catch(_e){}
    }

    function hookReset(){
      var r = d.getElementById('reset-btn');
      if(r && !r.__gateHook){
        r.__gateHook = true;
        r.addEventListener('click', function(){
          // After reset shows the welcome overlay, re-evaluate gating
          setTimeout(function(){ updateWelcomeStartBtn(); }, 300);
        }, true);
      }
    }

    function addRestoreOriginalBtn(){
      var compact = d.getElementById('compact-btn');
      if(!compact || compact.__restoreAdded) return;
      compact.__restoreAdded = true;
      var btn = d.createElement('button');
      btn.id = 'restore-original-btn';
      btn.type = 'button';
      btn.textContent = 'Restore Original Quiz';
      compact.parentNode.insertBefore(btn, compact.nextSibling);

      function updateState(){
        var hasBackup = !!localStorage.getItem(BACKUP_KEY) || !!localStorage.getItem(BASE_KEY);
        btn.disabled = !hasBackup;
        btn.setAttribute('aria-disabled', (!hasBackup).toString());
        btn.title = hasBackup ? 'Restore the original uploaded set' : 'upload json file first to enable restore';
      }
      updateState();

      btn.addEventListener('click', function(){
        try{
          var src = localStorage.getItem(BACKUP_KEY) || localStorage.getItem(BASE_KEY);
          if(src){
            localStorage.setItem(QKEY, src);
            // Clear skip flag so user returns to welcome (optional). We won't set it; respect current flow.
            // Reload to apply
            location.reload();
          }
        }catch(_e){}
      }, false);
    }

    function hookImportRechecks(){
      try{
        var importBtn = d.getElementById('import-load-json') || d.getElementById('importLoad');
      }catch(_e){}
      var fileInput = d.getElementById('import-json-file') || d.getElementById('importJSON');
      function schedule(){
        setTimeout(function(){
          ensureBackup();
          updateWelcomeStartBtn();
          // restore button state may depend on backup presence
          var ro = d.getElementById('restore-original-btn');
          if(ro){
            var hasBackup = !!localStorage.getItem(BACKUP_KEY) || !!localStorage.getItem(BASE_KEY);
            ro.disabled = !hasBackup;
            ro.setAttribute('aria-disabled', (!hasBackup).toString());
          }
        }, 500);
      }
      if(importBtn && importBtn.addEventListener){
        importBtn.addEventListener('click', schedule, true);
      }
      if(fileInput && fileInput.addEventListener){
        fileInput.addEventListener('change', schedule, true);
      }
      window.addEventListener('storage', function(e){
        if(e && e.key === QKEY) schedule();
      });
    }

    function boot(){
      ensureBackup();
      updateWelcomeStartBtn();
      gateOnOverlayShow();
      hookReset();
      addRestoreOriginalBtn();
      hookImportRechecks();
    }

    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    }else{
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();

// PATCH: Restore Original Quiz — skip welcome & reset progress
(function(){
  try{
    var d = document;
    function patchRestore(){
      var btn = d.getElementById('restore-original-btn');
      if(!btn || btn.__restorePatch2) return;
      btn.__restorePatch2 = true;
      btn.addEventListener('click', function(ev){
        try{
          var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
          var BACKUP_KEY = QKEY + '_backupCompactOrig';
          var BASE_KEY = QKEY + '_baseFullSet';
          var src = localStorage.getItem(BACKUP_KEY) || localStorage.getItem(BASE_KEY);
          if(src){
            // Write the restored full set
            localStorage.setItem(QKEY, src);
            // Ensure Base tracks the restored set for Compact/Focus logic
            try{ localStorage.setItem(BASE_KEY, src); }catch(_e){}
            // Reset progress-related keys so we don't land at "quiz complete"
            try{ if(typeof PROG_KEY !== 'undefined') localStorage.removeItem(PROG_KEY); }catch(_e){}
            try{ if(typeof BM_KEY !== 'undefined') localStorage.removeItem(BM_KEY); }catch(_e){}
            // Skip welcome overlay on reload
            try{ localStorage.setItem('__skipWelcomeOnce', '1'); }catch(_e){}
            // Reload to re-init app state with restored questions
            location.reload();
            ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
            return false;
          }
        }catch(_e){}
      }, true);
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(patchRestore, 0); }, { once: true });
    } else {
      setTimeout(patchRestore, 0);
    }
  }catch(_e){}
})();

// PATCH: Restore Original — deep reset of run-state + skip welcome (capture)
(function(){
  try{
    var d = document;
    function deepResetAndRestore(ev){
      try{
        var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
        var BACKUP_KEY = QKEY + '_backupCompactOrig';
        var BASE_KEY = QKEY + '_baseFullSet';
        var STORAGE = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz');

        var src = localStorage.getItem(BACKUP_KEY) || localStorage.getItem(BASE_KEY);
        if(!src) return; // nothing to do

        // Write restored questions and sync Base
        localStorage.setItem(QKEY, src);
        try{ localStorage.setItem(BASE_KEY, src); }catch(_e){}

        // Nuke run-state keys that could make the app think it's "complete" or at an invalid index
        try{ if(typeof PROG_KEY !== 'undefined') localStorage.removeItem(PROG_KEY); }catch(_e){}
        try{ if(typeof BM_KEY !== 'undefined') localStorage.removeItem(BM_KEY); }catch(_e){}

        // Sweep other likely run-state keys under STORAGE_KEY prefix (but KEEP our question sets & marks)
        var keep = {};
        keep[QKEY] = 1;
        keep[BACKUP_KEY] = 1;
        keep[BASE_KEY] = 1;
        keep[(typeof STORAGE_KEY==='string'?STORAGE_KEY:'quiz') + '_compactMarkSig'] = 1;
        keep[(typeof STORAGE_KEY==='string'?STORAGE_KEY:'quiz') + '_compactMarkHash'] = 1;

        var toDeleteSub = ['progress','prog','current','index','answer','answers','visited','seen','queue','subset','focus','filter','order','cursor','pos'];
        for(var i=0;i<localStorage.length;i++){
          var k = localStorage.key(i);
          if(!k) continue;
          if(keep[k]) continue;
          if(typeof STORAGE === 'string' && k.indexOf(STORAGE + '_') === 0){
            // Heuristic: remove run-state-y keys
            var low = k.toLowerCase();
            var rm = false;
            for(var j=0;j<toDeleteSub.length;j++){ if(low.indexOf(toDeleteSub[j]) !== -1){ rm = true; break; } }
            if(rm){ try{ localStorage.removeItem(k); }catch(_e){} }
          }
        }

        // Ensure we skip welcome overlay on next load
        try{ localStorage.setItem('__skipWelcomeOnce','1'); }catch(_e){}
        // Hard reload to re-init app cleanly
        location.reload();
        if(ev){ ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation(); }
        return false;
      }catch(_e){}
    }
    function hook(){
      var btn = document.getElementById('restore-original-btn');
      if(!btn || btn.__deepRestoreHook) return;
      btn.__deepRestoreHook = true;
      // Capture so we run before any other listeners and swallow the event
      btn.addEventListener('click', deepResetAndRestore, true);
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(hook, 0); }, { once:true });
    }else{
      setTimeout(hook, 0);
    }
  }catch(_e){}
})();

// PATCH: Welcome Start gating survives refresh (enforced on overlay + timers)
(function(){
  try{
    var d = document;
    function hasUploadedJSON(){
      try{
        var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
        var raw = localStorage.getItem(QKEY);
        if(!raw) return false;
        var data = JSON.parse(raw);
        return Array.isArray(data) && data.length > 0;
      }catch(_e){ return false; }
    }
    function enforceStartGate(){
      var b = d.getElementById('welcome-start-btn');
      if(!b) return;
      var ok = hasUploadedJSON();
      b.disabled = !ok;
      b.setAttribute('aria-disabled', (!ok).toString());
      if(!b.__origTitle) b.__origTitle = b.title || 'Start Quiz';
      b.title = ok ? b.__origTitle : 'upload json file first to start';
    }
    function boot(){
      enforceStartGate();
      // Observe overlay visibility changes
      var ov = d.getElementById('welcome-overlay');
      if(ov && !ov.__gateObs){
        var mo = new MutationObserver(function(){ enforceStartGate(); });
        mo.observe(ov, { attributes:true, attributeFilter:['style','class'] });
        ov.__gateObs = mo;
      }
      // Short recheck loop to win races with other scripts
      var t0 = Date.now();
      (function tick(){
        enforceStartGate();
        if(Date.now() - t0 < 2000){ setTimeout(tick, 120); }
      })();
      // Also respond to cross-tab changes
      window.addEventListener('storage', function(e){
        try{
          var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
          if(e && e.key === QKEY) enforceStartGate();
        }catch(_e){}
      });
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    }else{
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();

// PATCH: Restore Original — clear main run-state + stronger Start gating
(function(){
  try{
    var d = document;
    function strengthenRestore(){
      var btn = d.getElementById('restore-original-btn');
      if(!btn || btn.__restorePatch3) return;
      btn.__restorePatch3 = true;
      btn.addEventListener('click', function(ev){
        try{
          var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
          var BACKUP_KEY = QKEY + '_backupCompactOrig';
          var BASE_KEY = QKEY + '_baseFullSet';
          var SKEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz'); // main run-state
          var src = localStorage.getItem(BACKUP_KEY) || localStorage.getItem(BASE_KEY);
          if(!src) return;
          localStorage.setItem(QKEY, src);
          try{ localStorage.setItem(BASE_KEY, src); }catch(_e){}
          // Reset explicit progress & bookmarks
          try{ if(typeof PROG_KEY !== 'undefined') localStorage.setItem(PROG_KEY, '{}'); }catch(_e){}
          try{ if(typeof BM_KEY !== 'undefined') localStorage.setItem(BM_KEY, '{}'); }catch(_e){}
          // Remove main run-state snapshot so app rebuilds order/current fresh
          try{ localStorage.removeItem(SKEY); }catch(_e){}
          // Skip welcome overlay on the reload for a smooth return to quiz
          try{ localStorage.setItem('__skipWelcomeOnce', '1'); }catch(_e){}
          location.reload();
          ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
          return false;
        }catch(_e){}
      }, true);
    }
    function strongStartGate(){
      var d = document;
      function hasUploadedJSON(){
        try{
          var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
          var raw = localStorage.getItem(QKEY);
          if(!raw) return false;
          var data = JSON.parse(raw);
          return Array.isArray(data) && data.length > 0;
        }catch(_e){ return false; }
      }
      function enforce(){
        var b = d.getElementById('welcome-start-btn');
        if(!b) return;
        var ok = hasUploadedJSON();
        if(!ok){
          b.disabled = true;
          b.setAttribute('aria-disabled','true');
          b.title = 'upload json file first to start';
        }
      }
      // Persistent observer to restore disabled if other code toggles it
      var startBtn = d.getElementById('welcome-start-btn');
      if(startBtn && !startBtn.__gateObs2){
        var mo = new MutationObserver(function(){ enforce(); });
        mo.observe(startBtn, { attributes:true, attributeFilter:['disabled','class','title'] });
        startBtn.__gateObs2 = mo;
      }
      // Click-cancel guard if somehow enabled
      var sb = d.getElementById('welcome-start-btn');
      if(sb && !sb.__gateClickGuard){
        sb.__gateClickGuard = true;
        sb.addEventListener('click', function(ev){
          try{
            var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
            var raw = localStorage.getItem(QKEY);
            var ok = false;
            if(raw){ try{ var d=JSON.parse(raw); ok=Array.isArray(d)&&d.length>0; }catch(_e){} }
            if(!ok){
              ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
              enforce();
              return false;
            }
          }catch(_e){}
        }, true);
      }
      // Re-check loop for a few seconds after load
      var t0 = Date.now();
      (function tick(){ enforce(); if(Date.now()-t0<4000) setTimeout(tick, 150); })();
      window.addEventListener('storage', function(e){
        try{
          var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
          if(e && e.key === QKEY) enforce();
        }catch(_e){}
      });
    }
    function boot(){
      strengthenRestore();
      strongStartGate();
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    }else{
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();

// PATCH: Strong restore/reset — clear all run-state + proper gating
(function(){
  try{
    var d = document;
    function clearRunState(preserveKeys){
      var SKEY = (typeof STORAGE_KEY === 'string' ? STORAGE_KEY : 'quiz');
      var PK = (typeof PROG_KEY === 'string' ? PROG_KEY : SKEY + '_prog');
      var BK = (typeof BM_KEY === 'string' ? BM_KEY : SKEY + '_bm');
      var keep = {};
      (preserveKeys || []).forEach(function(k){ keep[k] = 1; });

      // Remove exact and prefixed variants for SKEY/PK/BK
      var toRemove = [];
      for(var i=0;i<localStorage.length;i++){
        var k = localStorage.key(i);
        if(keep[k]) continue;
        if(k === SKEY || k === PK || k === BK ||
           (k && (k.indexOf(SKEY + '_') === 0 || k.indexOf(PK + '_') === 0 || k.indexOf(BK + '_') === 0))){
          toRemove.push(k);
        }
      }
      for(var j=0;j<toRemove.length;j++){
        try{ localStorage.removeItem(toRemove[j]); }catch(_e){}
      }
    }

    function hookRestore(){
      var btn = d.getElementById('restore-original-btn');
      if(!btn || btn.__restoreStrong) return;
      btn.__restoreStrong = true;
      btn.addEventListener('click', function(ev){
        try{
          var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
          var BACKUP_KEY = QKEY + '_backupCompactOrig';
          var BASE_KEY = QKEY + '_baseFullSet';
          var src = localStorage.getItem(BACKUP_KEY) || localStorage.getItem(BASE_KEY);
          if(!src) return;
          // Write full set and sync Base
          localStorage.setItem(QKEY, src);
          try{ localStorage.setItem(BASE_KEY, src); }catch(_e){}
          // Wipe all run-state so app rebuilds index/order/answers cleanly
          clearRunState([QKEY, BACKUP_KEY, BASE_KEY, (typeof STORAGE_KEY==='string'?STORAGE_KEY:'quiz') + '_compactMarkSig', (typeof STORAGE_KEY==='string'?STORAGE_KEY:'quiz') + '_compactMarkHash']);
          // Skip welcome overlay; land in quiz directly
          try{ localStorage.setItem('__skipWelcomeOnce', '1'); }catch(_e){}
          location.reload();
          ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
          return false;
        }catch(_e){}
      }, true);
    }

    function hookResetGate(){
      var r = d.getElementById('reset-btn');
      if(!r || r.__resetGate) return;
      r.__resetGate = true;
      r.addEventListener('click', function(){
        try{
          var QKEY = (typeof QUESTIONS_KEY === 'string' ? QUESTIONS_KEY : 'quiz_questions');
          var BACKUP_KEY = QKEY + '_backupCompactOrig';
          var BASE_KEY = QKEY + '_baseFullSet';
          // Clear uploaded JSON so Start is forced disabled after reset
          try{ localStorage.removeItem(QKEY); }catch(_e){}
          try{ localStorage.removeItem(BASE_KEY); }catch(_e){}
          try{ localStorage.removeItem(BACKUP_KEY); }catch(_e){}
          // Wipe all run-state snapshots
          clearRunState([]);
          // Ensure overlay appears and Start is disabled
          try{ localStorage.removeItem('__skipWelcomeOnce'); }catch(_e){}
          setTimeout(function(){
            var b = d.getElementById('welcome-start-btn');
            if(b){
              b.disabled = true;
              b.setAttribute('aria-disabled','true');
              b.title = 'upload json file first to start';
            }
          }, 300);
        }catch(_e){}
      }, true);
    }

    function boot(){
      hookRestore();
      hookResetGate();
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 0); }, { once:true });
    }else{
      setTimeout(boot, 0);
    }
  }catch(_e){}
})();

// PATCH: results heatmap (minimal, feature-detected)
(function(){
  try{
    var d = document;
    // Resolve keys consistently with existing app
    function keys(){ try{ return (typeof getKeys==='function')? getKeys(): null; }catch(_e){ return null; } }
    function QKEY(){ var k = keys(); return k ? k.QKEY : (typeof QUESTIONS_KEY==='string'?QUESTIONS_KEY:'quiz_questions'); }
    function SKEY(){ return (typeof STORAGE_KEY==='string'?STORAGE_KEY:'quiz'); }
    function PROG(){ var p = (typeof PROG_KEY==='string')? PROG_KEY : (SKEY()+'_progress'); return p; }

    // Create UI nodes (non-intrusive, left dock)
    function ensureUI(){
      if(d.getElementById('heatmap-toggle')) return;
      var btn = d.createElement('button');
      btn.id = 'heatmap-toggle'; btn.type = 'button';
      btn.setAttribute('aria-label', 'Toggle results heatmap');
      btn.textContent = 'HM';
      var panel = d.createElement('div');
      panel.id = 'heatmap-panel';
      panel.innerHTML = '<div class="hm-head"><span>Results heatmap</span><button id="hm-close" type="button" style="background:transparent;border:0;color:inherit;font-size:14px;cursor:pointer">✕</button></div><div class="hm-grid" id="hm-grid"></div><div class="hm-legend"><span><i class="hm-dot green"></i>Correct</span><span><i class="hm-dot red"></i>Wrong</span><span><i class="hm-dot gray"></i>Unanswered</span></div>';
      d.body.appendChild(btn); d.body.appendChild(panel);
      btn.addEventListener('click', function(){ panel.classList.toggle('hshow'); renderHeatmap(); }, false);
      var hc = d.getElementById('hm-close'); if(hc){ hc.addEventListener('click', function(){ panel.classList.remove('hshow'); }, false); }
    }

    function readJSON(key){
      try{ var v = localStorage.getItem(key); return v? JSON.parse(v): null; }catch(_e){ return null; }
    }

    function getQuestions(){
      var qs = readJSON(QKEY());
      return Array.isArray(qs)? qs: [];
    }

    function extractSelections(){
      var p = readJSON(PROG()) || {};
      // Look for a mapping of index->selected
      var cand = null;
      var keys = Object.keys(p||{});
      // Common field names
      var fields = ['answers','ans','responses','userAnswers','selections','selected'];
      for(var i=0;i<fields.length;i++){ if(p && typeof p[fields[i]] === 'object'){ cand = p[fields[i]]; break; } }
      // If not found, see if the object itself looks like a map of indices
      if(!cand && p && keys.length){
        var looksMap = true;
        for(var j=0;j<keys.length && j<10;j++){
          var k = keys[j];
          if(!/^\d+$/.test(k)) { looksMap = false; break; }
        }
        if(looksMap) cand = p;
      }
      return (cand && typeof cand === 'object')? cand : {};
    }

    function computeStatuses(){
      var qs = getQuestions();
      var sel = extractSelections();
      var statuses = []; // 'correct' | 'wrong' | 'unanswered'
      for(var i=0;i<qs.length;i++){
        var s = (sel && (sel[i]!=null || sel[String(i)]!=null)) ? (sel[i]!=null? sel[i] : sel[String(i)]) : null;
        if(s==null){ statuses.push('unanswered'); continue; }
        var correct = (typeof qs[i]==='object' && typeof qs[i].a!=='undefined') ? (Number(s)===Number(qs[i].a)) : false;
        statuses.push(correct? 'correct' : 'wrong');
      }
      return statuses;
    }

    function renderHeatmap(){
      var grid = d.getElementById('hm-grid');
      if(!grid) return;
      grid.innerHTML = '';
      var statuses = computeStatuses();
      for(var i=0;i<statuses.length;i++){
        var cell = d.createElement('div');
        cell.className = 'hm-cell ' + statuses[i];
        cell.title = 'Q'+(i+1)+': ' + statuses[i];
        grid.appendChild(cell);
      }
    }

    // Keep it fresh with minimal overhead
    var tick = 0;
    function scheduleRefresh(){
      // update on interval to avoid hooking into app internals
      setInterval(function(){
        tick++; if(tick%2===0){ renderHeatmap(); }
      }, 1000);
    }

    function boot(){
      ensureUI();
      renderHeatmap();
      scheduleRefresh();
    }

    if(d.readyState==='loading'){ d.addEventListener('DOMContentLoaded', boot, {once:true}); }
    else { boot(); }
  }catch(_e){ /* silent */ }
})();

// PATCH: tools suite (timer/progress/export/import/cheatsheet)
(function(){
  try{
    var d=document;

    function keys(){ try{ return (typeof getKeys==='function')? getKeys(): null; }catch(_e){ return null; } }
    function QKEY(){ var k=keys(); return k? k.QKEY : (typeof QUESTIONS_KEY==='string'?QUESTIONS_KEY:'quiz_questions'); }
    function SKEY(){ return (typeof STORAGE_KEY==='string'?STORAGE_KEY:'quiz'); }
    function PROG(){ var p=(typeof PROG_KEY==='string')? PROG_KEY : (SKEY()+'_progress'); return p; }
    function TKEY(){ return SKEY()+'_timer'; }
    function SNAPKEY(){ return SKEY()+'_snapshot_meta'; }

    function readJSON(k){ try{ var v=localStorage.getItem(k); return v? JSON.parse(v): null;}catch(_e){ return null;} }
    function writeJSON(k,v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(_e){} }

    function getQuestions(){ var qs=readJSON(QKEY()); return Array.isArray(qs)? qs: []; }

    function extractSelections(){
      var p = readJSON(PROG()) || {};
      var fields = ['answers','ans','responses','userAnswers','selections','selected'];
      for(var i=0;i<fields.length;i++){ if(p && typeof p[fields[i]]==='object') return p[fields[i]]; }
      // map-like fallback
      var keys = Object.keys(p||{}), looksMap=true;
      for(var j=0;j<Math.min(keys.length,10);j++){ if(!/^\d+$/.test(keys[j])){ looksMap=false; break; } }
      return looksMap? p : {};
    }

    function computeStatuses(){
      var qs=getQuestions();
      var sel=extractSelections();
      var statuses=[], answered=0;
      for(var i=0;i<qs.length;i++){
        var has = (sel && (sel[i]!=null || sel[String(i)]!=null));
        var s = has? (sel[i]!=null? sel[i] : sel[String(i)]) : null;
        if(s==null){ statuses.push('unanswered'); continue; }
        answered++;
        var correct = (typeof qs[i]==='object' && typeof qs[i].a!=='undefined') ? (Number(s)===Number(qs[i].a)) : false;
        statuses.push(correct? 'correct':'wrong');
      }
      return {statuses:statuses, answered:answered, total:qs.length};
    }

    // --- UI creation ---
    function ensureToolsUI(){
      if(d.getElementById('tools-toggle')) return;
      var tbtn=d.createElement('button');
      tbtn.id='tools-toggle'; tbtn.type='button'; tbtn.textContent='≡';
      var panel=d.createElement('div'); panel.id='tools-panel';
      panel.innerHTML = ''
        + '<div class="tools-row" style="justify-content:space-between">'
        + '  <span class="tools-label">Tools</span>'
        + '  <button id="tools-close" type="button">✕</button>'
        + '</div>'
        + '<div class="tools-row"><span class="tools-label">Timer:</span>'
        + '  <button class="tools-btn" id="tm-start">Start</button>'
        + '  <button class="tools-btn" id="tm-pause">Pause</button>'
        + '  <button class="tools-btn" id="tm-reset">Reset</button>'
        + '  <span class="caption" id="tm-readout" style="margin-left:6px;opacity:.8">00:00:00</span>'
        + '</div>'
        + '<hr/>'
        + '<div class="tools-row"><span class="tools-label">Study Guide:</span>'
        + '  <button class="tools-btn" id="ex-study">Export Wrong→HTML</button>'
        + '</div>'
        + '<div class="tools-row"><span class="tools-label">Session:</span>'
        + '  <button class="tools-btn" id="ex-snap">Export Snapshot</button>'
        + '  <button class="tools-btn" id="im-snap">Import Snapshot</button>'
        + '  <input id="snap-file" class="hidden-tools-input" type="file" accept="application/json">'
        + '</div>'
        + '<hr/>'
        + '<div class="tools-row"><span class="tools-label">Shortcuts:</span>'
        + '  <span class="caption">Press <span class="kbd">?</span> to view</span>'
        + '</div>';

      var pill=d.createElement('div'); pill.id='timer-pill'; pill.innerHTML='<span id="tp-time">00:00:00</span>';
      var prog=d.createElement('div'); prog.id='progress-mini'; prog.innerHTML='<i></i>';

      d.body.appendChild(tbtn); d.body.appendChild(panel); d.body.appendChild(pill); d.body.appendChild(prog);

      tbtn.addEventListener('click', function(){ panel.classList.toggle('tshow'); }, false);
      var tc=d.getElementById('tools-close'); if(tc) tc.addEventListener('click', function(){ panel.classList.remove('tshow'); }, false);

      // Timer controls
      var startB=d.getElementById('tm-start'), pauseB=d.getElementById('tm-pause'), resetB=d.getElementById('tm-reset');
      startB.addEventListener('click', timerStart, false);
      pauseB.addEventListener('click', timerPause, false);
      resetB.addEventListener('click', timerReset, false);

      // Export study guide
      var exS=d.getElementById('ex-study'); exS.addEventListener('click', exportStudyGuide, false);

      // Snapshot export/import
      var exSnap=d.getElementById('ex-snap'), imSnap=d.getElementById('im-snap'), fIn=d.getElementById('snap-file');
      exSnap.addEventListener('click', exportSnapshot, false);
      imSnap.addEventListener('click', function(){ fIn && fIn.click(); }, false);
      fIn.addEventListener('change', importSnapshot, false);

      ensureShortcutModal();
    }

    // --- Timer ---
    function fmt(ms){
      ms = Math.max(0, ms|0);
      var s = Math.floor(ms/1000), h=Math.floor(s/3600), m=Math.floor((s%3600)/60), sec=s%60;
      function pad(n){ return (n<10?'0':'')+n; }
      return pad(h)+':'+pad(m)+':'+pad(sec);
    }
    function timerState(){
      return readJSON(TKEY()) || {running:false, startedAt:0, elapsed:0};
    }
    function setTimer(st){ writeJSON(TKEY(), st); }
    function timerStart(){
      var st=timerState();
      if(!st.running){ st.running=true; st.startedAt=Date.now(); setTimer(st); }
    }
    function timerPause(){
      var st=timerState();
      if(st.running){ st.elapsed += (Date.now()-st.startedAt); st.running=false; setTimer(st); }
    }
    function timerReset(){
      setTimer({running:false, startedAt:0, elapsed:0});
      renderTimer();
    }
    function renderTimer(){
      var st=timerState(), now=Date.now();
      var ms = st.elapsed + (st.running? (now-st.startedAt):0);
      var t = fmt(ms);
      var pill=d.getElementById('tp-time'), ro=d.getElementById('tm-readout');
      if(pill) pill.textContent = t;
      if(ro) ro.textContent = t;
    }

    // --- Progress mini bar ---
    function renderProgressMini(){
      var info=computeStatuses();
      var pct = info.total? Math.round(100*info.answered/info.total) : 0;
      var bar=d.querySelector('#progress-mini > i');
      if(bar){ bar.style.width = pct+'%'; }
    }

    // --- Export study guide ---
    function exportStudyGuide(){
      try{
        var info=computeStatuses(), qs=getQuestions();
        var rows=[];
        for(var i=0;i<qs.length;i++){
          if(info.statuses[i]==='wrong'){
            var q=qs[i]||{};
            var correctIdx = (typeof q.a==='number')? q.a : null;
            var correctText = (correctIdx!=null && Array.isArray(q.c))? q.c[correctIdx] : '(n/a)';
            rows.push('<section style="margin:0 0 16px 0;padding:12px;border:1px solid rgba(0,0,0,.2);border-radius:10px;background:#0b1220;color:#e5e7eb"><h3 style="margin:0 0 6px 0;font-size:16px">Q'+(i+1)+'. '+(q.q||'')+'</h3><div><b>Correct:</b> '+(correctText||'')+'</div><div style="margin-top:6px"><b>Why:</b> '+(q.e||'See explanation')+'</div><div style="margin-top:6px;opacity:.8"><b>Evidence:</b> '+(q._meta&&q._meta.evidence?q._meta.evidence:'')+'</div></section>');
          }
        }
        var html='<!doctype html><meta charset="utf-8"><title>Study Guide (Wrong Only)</title><body style="background:#0a0f1a;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:20px"><h1 style="color:#e5e7eb">Study Guide – Wrong Questions</h1>'+ (rows.length? rows.join('') : '<p style="color:#e5e7eb">No wrong answers yet 🎉</p>') +'</body>';
        var blob=new Blob([html],{type:'text/html'});
        var url=URL.createObjectURL(blob);
        var a=d.createElement('a'); a.href=url; a.download='study_guide_wrong.html'; d.body.appendChild(a); a.click(); setTimeout(function(){ URL.revokeObjectURL(url); a.remove(); }, 1000);
      }catch(e){ /* noop */ }
    }

    // --- Snapshot export/import ---
    function exportSnapshot(){
      try{
        var payload = {
          meta: { savedAt: new Date().toISOString(), key:SKEY() },
          progress: readJSON(PROG()),
          timer: readJSON(TKEY())
        };
        writeJSON(SNAPKEY(), payload.meta);
        var blob=new Blob([JSON.stringify(payload,null,2)],{type:'application/json'});
        var url=URL.createObjectURL(blob);
        var a=d.createElement('a'); a.href=url; a.download='quiz_snapshot.json'; d.body.appendChild(a); a.click(); setTimeout(function(){ URL.revokeObjectURL(url); a.remove(); }, 1000);
      }catch(e){ /* noop */ }
    }

    function importSnapshot(ev){
      var f = ev && ev.target && ev.target.files && ev.target.files[0];
      if(!f) return;
      var reader=new FileReader();
      reader.onload=function(){
        try{
          var data=JSON.parse(String(reader.result||'{}'));
          if(data && data.progress){ writeJSON(PROG(), data.progress); }
          if(data && data.timer){ writeJSON(TKEY(), data.timer); }
          // keep dataset untouched; reload to reflect
          setTimeout(function(){ location.reload(); }, 100);
        }catch(e){ /* noop */ }
      };
      reader.readAsText(f);
    }

    // --- Shortcut cheatsheet ---
    function ensureShortcutModal(){
      if(d.getElementById('shortcut-modal')) return;
      var wrap=d.createElement('div'); wrap.id='shortcut-modal';
      wrap.innerHTML='<div class="inner"><div style="display:flex;justify-content:space-between;align-items:center"><h3 style="margin:0">Keyboard Shortcuts</h3><button id="sc-close" class="tools-btn">Close</button></div><div style="margin-top:10px;line-height:1.9"><div><span class="kbd">A</span><span class="kbd">B</span><span class="kbd">C</span><span class="kbd">D</span> — select choices</div><div><span class="kbd">←</span> previous • <span class="kbd">→</span> next • <span class="kbd">Enter</span> next</div><div><span class="kbd">S</span> strike/unstrike choice under focus (if supported)</div><div><span class="kbd">E</span> toggle evidence panel (if available)</div><div><span class="kbd">?</span> open/close this sheet</div></div></div>';
      d.body.appendChild(wrap);
      var close=d.getElementById('sc-close');
      if(close) close.addEventListener('click', function(){ wrap.style.display='none'; }, false);
      wrap.addEventListener('click', function(e){ if(e.target===wrap) wrap.style.display='none'; }, false);
      d.addEventListener('keydown', function(e){
        if(e.key === '?'){ e.preventDefault(); wrap.style.display = (wrap.style.display==='block'?'none':'block'); }
      }, false);
    }

    // --- Ticker ---
    function tick(){
      renderTimer();
      renderProgressMini();
    }

    function boot(){
      ensureToolsUI();
      tick();
      setInterval(tick, 1000);
    }

    if(d.readyState==='loading'){ d.addEventListener('DOMContentLoaded', boot, {once:true}); }
    else { boot(); }

  }catch(_e){ /* silent */ }
})();

// PATCH: timer immediate update & resilient ticker
(function(){
  try{
    var d=document;
    function readJSON(k){ try{ var v=localStorage.getItem(k); return v? JSON.parse(v): null; }catch(_e){ return null; } }
    function writeJSON(k,v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(_e){} }
    function SKEY(){ return (typeof STORAGE_KEY==='string'? STORAGE_KEY : 'quiz'); }
    function TKEY(){ return SKEY()+'_timer'; }
    function fmt(ms){
      ms = Math.max(0, ms|0);
      var s = Math.floor(ms/1000), h=Math.floor(s/3600), m=Math.floor((s%3600)/60), sec=s%60;
      function pad(n){ return (n<10?'0':'')+n; }
      return pad(h)+':'+pad(m)+':'+pad(sec);
    }
    function state(){ return readJSON(TKEY()) || {running:false, startedAt:0, elapsed:0}; }
    function setState(st){ writeJSON(TKEY(), st); }

    function render(){
      var st = state(), now = Date.now();
      var ms = st.elapsed + (st.running? (now-st.startedAt):0);
      var t = fmt(ms);
      var pill=d.getElementById('tp-time'), ro=d.getElementById('tm-readout');
      if(pill) pill.textContent = t;
      if(ro) ro.textContent = t;
    }

    function ensureTicker(){
      if(window.__qtTimerTick) return;
      window.__qtTimerTick = setInterval(render, 1000);
    }

    function start(){
      var st = state();
      if(!st.running){
        st.running = true; st.startedAt = Date.now(); setState(st);
        render(); // immediate feedback
      }
      ensureTicker();
    }
    function pause(){
      var st = state();
      if(st.running){
        st.elapsed += (Date.now()-st.startedAt);
        st.running = false; setState(st);
        render();
      }
    }
    function reset(){
      setState({running:false, startedAt:0, elapsed:0});
      render();
    }

    // Attach if buttons exist
    var sb=d.getElementById('tm-start'), pb=d.getElementById('tm-pause'), rb=d.getElementById('tm-reset');
    if(sb && !sb.__qtBound){ sb.addEventListener('click', start, false); sb.__qtBound=1; }
    if(pb && !pb.__qtBound){ pb.addEventListener('click', pause, false); pb.__qtBound=1; }
    if(rb && !rb.__qtBound){ rb.addEventListener('click', reset, false); rb.__qtBound=1; }

    // Initial render and ticker
    render(); ensureTicker();
  }catch(_e){}
})();

// PATCH: heatmap correctness fix (robust selection decoding & override renderer)
(function(){
  try{
    var d=document;

    function readJSON(k){ try{ var v=localStorage.getItem(k); return v? JSON.parse(v): null; }catch(_e){ return null; } }
    function keys(){ try{ return (typeof getKeys==='function')? getKeys(): null; }catch(_e){ return null; } }
    function QKEY(){ var k=keys(); return k ? k.QKEY : (typeof QUESTIONS_KEY==='string'?QUESTIONS_KEY:'quiz_questions'); }
    function SKEY(){ return (typeof STORAGE_KEY==='string'?STORAGE_KEY:'quiz'); }
    function PROG(){ var p=(typeof PROG_KEY==='string')? PROG_KEY : (SKEY()+'_progress'); return p; }

    function getQuestions(){ var qs=readJSON(QKEY()); return Array.isArray(qs)? qs: []; }
    function getProgress(){ return readJSON(PROG()) || {}; }

    // Try to coerce a user selection for index i into a numeric choice index
    function coerceSelection(i, q, progress){
      var candidates = [];
      var fields = ['answers','ans','responses','userAnswers','selections','selected','choices','picked'];
      for(var f=0; f<fields.length; f++){
        var obj = progress && progress[fields[f]];
        if(obj && (typeof obj==='object')){
          if(typeof obj[i] !== 'undefined') candidates.push(obj[i]);
          if(typeof obj[String(i)] !== 'undefined') candidates.push(obj[String(i)]);
        }
      }
      // direct map fallback (keys are indices as strings)
      if(!candidates.length){
        var ks = Object.keys(progress||{}), looksMap=true;
        for(var j=0;j<Math.min(ks.length,10);j++){ if(!/^\d+$/.test(ks[j])){ looksMap=false; break; } }
        if(looksMap){ candidates.push(progress[i]); candidates.push(progress[String(i)]); }
      }
      // decode each candidate
      for(var k=0;k<candidates.length;k++){
        var s = candidates[k];
        // numeric or numeric string
        if(typeof s === 'number' && isFinite(s)) return s|0;
        if(typeof s === 'string'){
          var t=s.trim();
          if(/^\d+$/.test(t)) return parseInt(t,10);
          // letter to index (A-D...Z)
          var m = t.match(/^[A-Za-z]$/);
          if(m){
            var idx = t.toUpperCase().charCodeAt(0) - 65; // A=0
            if(Array.isArray(q.c) && idx>=0 && idx<q.c.length) return idx;
          }
          // try to match choice text
          if(Array.isArray(q.c)){
            for(var ci=0; ci<q.c.length; ci++){
              if(String(q.c[ci]).trim().toLowerCase() === t.toLowerCase()) return ci;
            }
          }
        }
        // object forms {index:1} {i:1} {choice: "B"} {text:"..."}
        if(s && typeof s === 'object'){
          if(typeof s.index === 'number') return s.index|0;
          if(typeof s.i === 'number') return s.i|0;
          if(typeof s.choice === 'number') return s.choice|0;
          if(typeof s.choice === 'string'){
            var t2=String(s.choice).trim();
            if(/^\d+$/.test(t2)) return parseInt(t2,10);
            var idx2 = t2.toUpperCase && (t2.toUpperCase().charCodeAt(0)-65);
            if(idx2>=0 && Array.isArray(q.c) && idx2<q.c.length) return idx2;
          }
          if(typeof s.text === 'string' && Array.isArray(q.c)){
            var t3 = s.text.trim().toLowerCase();
            for(var cj=0;cj<q.c.length;cj++){
              if(String(q.c[cj]).trim().toLowerCase()===t3) return cj;
            }
          }
        }
      }
      return null;
    }

    // If selection unavailable, try explicit correctness maps
    function coerceCorrectness(i, progress){
      var flags = ['correct','isCorrect','results','result','score','scores'];
      for(var f=0; f<flags.length; f++){
        var obj = progress && progress[flags[f]];
        if(obj && typeof obj==='object'){
          var v = (typeof obj[i] !== 'undefined')? obj[i] : obj[String(i)];
          if(typeof v === 'boolean') return v;
          if(v === 1 || v === '1' || v === 'true' || v === 'correct') return true;
          if(v === 0 || v === '0' || v === 'false' || v === 'wrong' || v === 'incorrect') return false;
        }
      }
      return null;
    }

    function computeStatusesFixed(){
      var qs=getQuestions();
      var p=getProgress();
      var out=[], answered=0;
      for(var i=0;i<qs.length;i++){
        var q = (typeof qs[i]==='object')? qs[i]: {};
        var correctIdx = (q && typeof q.a!=='undefined')? (Number(q.a)) : null;
        var selIdx = coerceSelection(i, q, p);
        if(selIdx==null){
          // try correctness flags
          var flag = coerceCorrectness(i, p);
          if(flag===true){ out.push('correct'); answered++; continue; }
          if(flag===false){ out.push('wrong'); answered++; continue; }
          out.push('unanswered'); continue;
        }else{
          answered++;
          if(correctIdx!=null && Number(selIdx)===Number(correctIdx)){
            out.push('correct');
          }else{
            out.push('wrong');
          }
        }
      }
      return {statuses: out, answered: answered, total: qs.length};
    }

    function renderHeatmapFixed(){
      var grid = d.getElementById('hm-grid');
      if(!grid) return;
      var info = computeStatusesFixed();
      // only re-render if counts differ from current DOM to minimize flicker
      var need = info.statuses.length;
      if(grid.childElementCount !== need){
        grid.innerHTML='';
        for(var i=0;i<info.statuses.length;i++){
          var cell=d.createElement('div');
          cell.className='hm-cell '+info.statuses[i];
          cell.title='Q'+(i+1)+': '+info.statuses[i];
          grid.appendChild(cell);
        }
      }else{
        // update classes in place
        for(var i=0;i<need;i++){
          var el=grid.children[i];
          var stat=info.statuses[i];
          if(!el.classList.contains(stat)){
            el.classList.remove('correct','wrong','unanswered');
            el.classList.add(stat);
            el.title='Q'+(i+1)+': '+stat;
          }
        }
      }
    }

    // gentle override ticker
    if(!window.__hmFixTick){
      window.__hmFixTick = setInterval(renderHeatmapFixed, 900);
      // one immediate pass
      renderHeatmapFixed();
    }
  }catch(_e){ /* silent */ }
})();

// PATCH: remove heatmap and fix progress bar
(function(){
  try{
    var d=document;
    // Remove HM UI & cancel any timers
    var hmBtn = d.getElementById('heatmap-toggle'); if(hmBtn && hmBtn.parentNode) hmBtn.parentNode.removeChild(hmBtn);
    var hmPanel = d.getElementById('heatmap-panel'); if(hmPanel && hmPanel.parentNode) hmPanel.parentNode.removeChild(hmPanel);
    if(window.__hmFixTick){ try{ clearInterval(window.__hmFixTick); }catch(_e){} window.__hmFixTick = 0; }
    // Neutralize any stray renderer
    window.renderHeatmap = function(){};

    // --- Robust answered/total computation for the green bar ---
    function readJSON(k){ try{ var v=localStorage.getItem(k); return v? JSON.parse(v): null; }catch(_e){ return null; } }
    function keys(){ try{ return (typeof getKeys==='function')? getKeys(): null; }catch(_e){ return null; } }
    function QKEY(){ var k=keys(); return k ? k.QKEY : (typeof QUESTIONS_KEY==='string'?QUESTIONS_KEY:'quiz_questions'); }
    function SKEY(){ return (typeof STORAGE_KEY==='string')? STORAGE_KEY : 'quiz'; }
    function PROG(){ var p=(typeof PROG_KEY==='string')? PROG_KEY : (SKEY()+'_progress'); return p; }

    function getQuestions(){ var qs=readJSON(QKEY()); return Array.isArray(qs)? qs: []; }
    function getProgress(){ return readJSON(PROG()) || {}; }

    function coerceSelection(i, q, progress){
      var candidates = [];
      var fields = ['answers','ans','responses','userAnswers','selections','selected','choices','picked'];
      for(var f=0; f<fields.length; f++){
        var obj = progress && progress[fields[f]];
        if(obj && typeof obj==='object'){
          if(typeof obj[i] !== 'undefined') candidates.push(obj[i]);
          if(typeof obj[String(i)] !== 'undefined') candidates.push(obj[String(i)]);
        }
      }
      if(!candidates.length){
        var ks = Object.keys(progress||{}), looksMap=true;
        for(var j=0;j<Math.min(ks.length,10);j++){ if(!/^\d+$/.test(ks[j])){ looksMap=false; break; } }
        if(looksMap){ candidates.push(progress[i]); candidates.push(progress[String(i)]); }
      }
      for(var k=0;k<candidates.length;k++){
        var s = candidates[k];
        if(s==null) continue;
        if(typeof s === 'number' && isFinite(s)) return s|0;
        if(typeof s === 'string'){
          var t=s.trim();
          if(/^\d+$/.test(t)) return parseInt(t,10);
          if(/^[A-Za-z]$/.test(t)){
            var idx = t.toUpperCase().charCodeAt(0) - 65;
            if(Array.isArray(q.c) && idx>=0 && idx<q.c.length) return idx;
          }
          if(Array.isArray(q.c)){
            for(var ci=0; ci<q.c.length; ci++){
              if(String(q.c[ci]).trim().toLowerCase() === t.toLowerCase()) return ci;
            }
          }
        }
        if(typeof s === 'object'){
          if(typeof s.index === 'number') return s.index|0;
          if(typeof s.i === 'number') return s.i|0;
          if(typeof s.choice === 'number') return s.choice|0;
          if(typeof s.choice === 'string'){
            var t2=String(s.choice).trim();
            if(/^\d+$/.test(t2)) return parseInt(t2,10);
            var idx2 = t2.toUpperCase && (t2.toUpperCase().charCodeAt(0)-65);
            if(idx2>=0 && Array.isArray(q.c) && idx2<q.c.length) return idx2;
          }
          if(typeof s.text === 'string' && Array.isArray(q.c)){
            var t3 = s.text.trim().toLowerCase();
            for(var cj=0;cj<q.c.length;cj++){
              if(String(q.c[cj]).trim().toLowerCase()===t3) return cj;
            }
          }
        }
      }
      return null;
    }

    function computeAnswered(){
      var qs=getQuestions();
      var p=getProgress();
      var answered=0;
      for(var i=0;i<qs.length;i++){
        var sel = coerceSelection(i, qs[i]||{}, p);
        if(sel!=null) answered++;
      }
      return {answered:answered, total:qs.length};
    }

    function renderProgressMiniFixed(){
      var info = computeAnswered();
      var pct = info.total? Math.round(100*info.answered/info.total) : 0;
      var bar = d.querySelector('#progress-mini > i');
      if(bar){ bar.style.width = pct+'%'; bar.setAttribute('title', info.answered + ' / ' + info.total); }
    }

    // Periodic refresh to keep it in sync
    if(!window.__pmFixTick){
      window.__pmFixTick = setInterval(renderProgressMiniFixed, 800);
      renderProgressMiniFixed();
    }
  }catch(_e){ /* silent */ }
})();

// PATCH: disable progress mini updater (bar removed)
(function(){
  try{
    if(window.__pmFixTick){ clearInterval(window.__pmFixTick); window.__pmFixTick = 0; }
  }catch(_e){}
})();

// PATCH: move Instructions button to where Open in New Tab used to be
(function(){
  try{
    var d=document;
    function moveInstr(){
      var openBtn = d.getElementById('open-tab-btn');
      var instr = d.getElementById('instr-btn');
      if(openBtn && instr && openBtn.parentNode){
        if(instr !== openBtn){ 
          // Insert instr right before the old open-tab-btn node for identical placement
          openBtn.parentNode.insertBefore(instr, openBtn);
          // Keep open-tab hidden per previous patch; no further changes
        }
      }
    }
    if(d.readyState==='loading'){ d.addEventListener('DOMContentLoaded', moveInstr, {once:true}); }
    else { moveInstr(); }
  }catch(_e){ /* silent */ }
})();

// PATCH: Export Wrong→HTML accuracy fix (robust wrong-only computation)
(function(){
  try{
    var d=document;

    function readJSON(k){ try{ var v=localStorage.getItem(k); return v? JSON.parse(v): null; }catch(_e){ return null; } }
    function keys(){ try{ return (typeof getKeys==='function')? getKeys(): null; }catch(_e){ return null; } }
    function QKEY(){ var k=keys(); return k? k.QKEY : (typeof QUESTIONS_KEY==='string'?QUESTIONS_KEY:'quiz_questions'); }
    function SKEY(){ return (typeof STORAGE_KEY==='string')? STORAGE_KEY : 'quiz'; }
    function PROG(){ var p=(typeof PROG_KEY==='string')? PROG_KEY : (SKEY()+'_progress'); return p; }

    function getQuestions(){ var qs=readJSON(QKEY()); return Array.isArray(qs)? qs: []; }
    function getProgress(){ return readJSON(PROG()) || {}; }

    // Coerce selection formats → numeric index
    function coerceSelection(i, q, progress){
      var candidates = [];
      var fields = ['answers','ans','responses','userAnswers','selections','selected','choices','picked'];
      for(var f=0; f<fields.length; f++){
        var obj = progress && progress[fields[f]];
        if(obj && typeof obj==='object'){
          if(typeof obj[i] !== 'undefined') candidates.push(obj[i]);
          if(typeof obj[String(i)] !== 'undefined') candidates.push(obj[String(i)]);
        }
      }
      if(!candidates.length){
        var ks = Object.keys(progress||{}), looksMap=true;
        for(var j=0;j<Math.min(ks.length,10);j++){ if(!/^\d+$/.test(ks[j])){ looksMap=false; break; } }
        if(looksMap){ candidates.push(progress[i]); candidates.push(progress[String(i)]); }
      }
      for(var k=0;k<candidates.length;k++){
        var s = candidates[k];
        if(s==null) continue;
        if(typeof s === 'number' && isFinite(s)) return s|0;
        if(typeof s === 'string'){
          var t=s.trim();
          if(/^\d+$/.test(t)) return parseInt(t,10);
          // letter A-D → index
          if(/^[A-Za-z]$/.test(t)){
            var idx = t.toUpperCase().charCodeAt(0) - 65;
            if(Array.isArray(q.c) && idx>=0 && idx<q.c.length) return idx;
          }
          // exact text match
          if(Array.isArray(q.c)){
            for(var ci=0; ci<q.c.length; ci++){
              if(String(q.c[ci]).trim().toLowerCase() === t.toLowerCase()) return ci;
            }
          }
        }
        if(typeof s === 'object'){
          if(typeof s.index === 'number') return s.index|0;
          if(typeof s.i === 'number') return s.i|0;
          if(typeof s.choice === 'number') return s.choice|0;
          if(typeof s.choice === 'string'){
            var t2=String(s.choice).trim();
            if(/^\d+$/.test(t2)) return parseInt(t2,10);
            var idx2 = t2.toUpperCase && (t2.toUpperCase().charCodeAt(0)-65);
            if(idx2>=0 && Array.isArray(q.c) && idx2<q.c.length) return idx2;
          }
          if(typeof s.text === 'string' && Array.isArray(q.c)){
            var t3 = s.text.trim().toLowerCase();
            for(var cj=0;cj<q.c.length;cj++){
              if(String(q.c[cj]).trim().toLowerCase()===t3) return cj;
            }
          }
        }
      }
      return null;
    }

    // Optional correctness flags support
    function coerceCorrectness(i, progress){
      var flags = ['correct','isCorrect','results','result','score','scores'];
      for(var f=0; f<flags.length; f++){
        var obj = progress && progress[flags[f]];
        if(obj && typeof obj==='object'){
          var v = (typeof obj[i] !== 'undefined')? obj[i] : obj[String(i)];
          if(typeof v === 'boolean') return v;
          if(v === 1 || v === '1' || v === 'true' || v === 'correct') return true;
          if(v === 0 || v === '0' || v === 'false' || v === 'wrong' || v === 'incorrect') return false;
        }
      }
      return null;
    }

    function computeWrong(){
      var qs = getQuestions();
      var p = getProgress();
      var wrong = [];
      for(var i=0;i<qs.length;i++){
        var q = qs[i]||{};
        var correctIdx = (typeof q.a!=='undefined')? Number(q.a) : null;
        var selIdx = coerceSelection(i, q, p);
        if(selIdx==null){
          var flag = coerceCorrectness(i, p);
          if(flag===false){ wrong.push(i); }
          // unanswered not included
        }else{
          if(correctIdx==null || Number(selIdx)!==Number(correctIdx)){
            wrong.push(i);
          }
        }
      }
      return wrong;
    }

    function exportStudyGuideFixed(ev){
      if(ev && typeof ev.preventDefault==='function') ev.preventDefault();
      try{
        var qs = getQuestions();
        var wr = computeWrong();
        var rows = [];
        for(var w=0; w<wr.length; w++){
          var i = wr[w];
          var q = qs[i] || {};
          var correctIdx = (typeof q.a==='number')? q.a : null;
          var correctText = (correctIdx!=null && Array.isArray(q.c))? q.c[correctIdx] : '(n/a)';
          rows.push(
            '<section style="margin:0 0 16px 0;padding:12px;border:1px solid rgba(0,0,0,.2);border-radius:10px;background:#0b1220;color:#e5e7eb">'
            + '<h3 style="margin:0 0 6px 0;font-size:16px">Q'+(i+1)+'. '+ (q.q||'') +'</h3>'
            + '<div><b>Correct:</b> '+ (correctText||'') +'</div>'
            + '<div style="margin-top:6px"><b>Why:</b> '+ (q.e||'See explanation') +'</div>'
            + '<div style="margin-top:6px;opacity:.8"><b>Evidence:</b> '+ (q._meta&&q._meta.evidence?q._meta.evidence:'') +'</div>'
            + '</section>'
          );
        }
        var html = '<!doctype html><meta charset="utf-8"><title>Study Guide (Wrong Only)</title>'
          + '<body style="background:#0a0f1a;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:20px">'
          + '<h1 style="color:#e5e7eb">Study Guide – Wrong Questions</h1>'
          + (rows.length? rows.join('') : '<p style="color:#e5e7eb">No wrong answers yet 🎉</p>')
          + '</body>';
        var blob = new Blob([html], {type:'text/html'});
        var url = URL.createObjectURL(blob);
        var a = d.createElement('a'); a.href=url; a.download='study_guide_wrong.html';
        d.body.appendChild(a); a.click(); setTimeout(function(){ URL.revokeObjectURL(url); a.remove(); }, 1200);
      }catch(e){ /* silent */ }
    }

    // Replace previous handler by cloning the button (removes old listeners), then attach fixed one
    function attach(){
      var btn = d.getElementById('ex-study');
      if(!btn) return;
      if(btn.__fixed) return;
      var clone = btn.cloneNode(true);
      btn.parentNode.replaceChild(clone, btn);
      clone.addEventListener('click', exportStudyGuideFixed, false);
      clone.__fixed = 1;
    }

    if(d.readyState==='loading'){ d.addEventListener('DOMContentLoaded', attach, {once:true}); }
    else { attach(); }
  }catch(_e){ /* silent */ }
})();
</script>
<style>

/* PATCH: Welcome card darken & title match */
#welcome-card{
  background: #0b1220 !important; /* closer to black, matches --bg */
  border-color: #111827 !important;
  box-shadow: 0 16px 44px rgba(0,0,0,0.6), 0 0 0 1px rgba(17,24,39,0.55) !important;
}
#welcome-card h2{
  font-weight: 800 !important;
  letter-spacing: .01em !important;
  /* use the same gradient/text treatment as action buttons */
  background-image: var(--g) !important;
  -webkit-background-clip: text !important;
  background-clip: text !important;
  -webkit-text-fill-color: transparent !important;
  color: transparent !important;
  text-shadow: 0 0 18px rgba(96,165,250,.25), 0 0 18px rgba(167,139,250,.15) !important;
}


/* PATCH: Choice strikeout */
.choice{ position: relative; } /* positioning context for the icon without layout changes */
.choice.struck{
  opacity: .45;
  text-decoration: line-through;
  filter: grayscale(0.6);
}
.choice .strike-icon{
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 24px;
  height: 24px;
  border-radius: 8px;
  border: 1px solid var(--bd);
  background: var(--bg);
  background-image: var(--g);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  color: transparent;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  line-height: 1;
  cursor: pointer;
  opacity: .9;
}
.choice .strike-icon:hover{ filter: brightness(1.08); }
.choice.struck .strike-icon{ opacity: 1; }


/* PATCH: Compact Mode (Flashcards) */
#compact-btn{
  margin:.4rem .4rem 0 0;
  display:inline-flex;align-items:center;gap:.5rem;
  padding:.45rem .8rem;border-radius:12px;border:1px solid rgba(255,255,255,.22);
  background:rgba(255,255,255,.06);backdrop-filter:blur(10px);
  font-weight:800;letter-spacing:.01em;background-image:var(--g);
  -webkit-background-clip:text;background-clip:text;color:transparent;
  text-shadow:0 0 18px rgba(96,165,250,.25);cursor:pointer
}
#compact-overlay{
  position:fixed;inset:0;display:none;z-index:10020;
  background:
    radial-gradient(1200px 800px at 20% 20%, rgba(96,165,250,0.12), transparent 60%),
    radial-gradient(1000px 700px at 80% 70%, rgba(244,114,182,0.10), transparent 60%),
    linear-gradient(135deg, rgba(15,23,42,0.96), rgba(2,6,23,0.98));
}
#compact-panel{
  width:min(1400px,95vw);max-height:92vh;overflow:auto;
  margin:3vh auto;padding:1rem;border-radius:14px;
  background:#0b1220;border:1px solid var(--bd);
  box-shadow:0 16px 44px rgba(0,0,0,.6);
  color:inherit;
}
#compact-header{display:flex;align-items:center;justify-content:space-between;gap:.75rem;margin-bottom:.5rem}
#compact-title{
  font-size:1.2rem;font-weight:800;margin:0;
  background-image:var(--g);-webkit-background-clip:text;background-clip:text;
  -webkit-text-fill-color:transparent;color:transparent;
}
#compact-controls{display:flex;align-items:center;gap:.5rem;flex-wrap:wrap}
#compact-controls button{
  padding:.35rem .6rem;border-radius:.6rem;border:1px solid var(--bd);
  background:var(--bg);background-image:var(--g);
  -webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;color:transparent;
  cursor:pointer
}
#fc-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:.75rem}
.fc-card{position:relative;height:180px;perspective:1000px;cursor:pointer}
.fc-inner{position:absolute;inset:0;transform-style:preserve-3d;transition:transform .35s ease}
.fc-card.flipped .fc-inner{transform:rotateY(180deg)}
.fc-face{
  position:absolute;inset:0;border-radius:10px;border:1px solid #374151;background:#1f2937;overflow:auto;
  padding:.6rem .6rem 40px .6rem;backface-visibility:hidden;color:#e5e7eb
}
.fc-back{transform:rotateY(180deg)}
.fc-q{font-weight:700;font-size:.98rem;line-height:1.25}
.fc-a{font-size:.95rem;opacity:.95}
.fc-meta{margin-top:.35rem;font-size:.85rem;opacity:.9}
.fc-controls{
  position:absolute;right:6px;bottom:6px;display:flex;gap:.4rem;pointer-events:auto
}
.fc-ctrl{
  width:28px;height:28px;border-radius:8px;border:1px solid var(--bd);
  background:var(--bg);background-image:var(--g);
  -webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;color:transparent;
  display:flex;align-items:center;justify-content:center;font-weight:800;cursor:pointer
}
/* status borders */
.fc-card.mark-g .fc-face{ box-shadow:0 0 0 2px rgba(34,197,94,.7) inset }
.fc-card.mark-y .fc-face{ box-shadow:0 0 0 2px rgba(245,158,11,.75) inset }
.fc-card.mark-r .fc-face{ box-shadow:0 0 0 2px rgba(239,68,68,.75) inset }


/* PATCH: Welcome inline instructions + import button text color */
#welcome-import-inline button{
  color:#e5e7eb !important;
  -webkit-text-fill-color:#e5e7eb !important;
  background-image:none !important;
}
#welcome-instr-inline{
  margin-top:.75rem;
  padding:.75rem;
  border:1px solid var(--bd);
  border-radius:10px;
  background:var(--bg);
}
#welcome-instr-inline h3{
  margin:0 0 .5rem 0;
  font-weight:700;
}
#welcome-instr-inline textarea{
  width:100%;
  min-height:160px;
  background:#0f172a;
  color:#e5e7eb;
  border:1px solid var(--bd);
  border-radius:8px;
  padding:.5rem;
  font-family:ui-monospace,Menlo,monospace;
  font-size:.9rem;
}
#welcome-instr-inline button{
  margin-top:.5rem;
  padding:.45rem .7rem;
  border:1px solid var(--bd);
  border-radius:10px;
  background:#1f2937;
  color:#e5e7eb;
}

/* PATCH: Gate Start Quiz + Restore Original button styles */
#welcome-start-btn[disabled]{
  opacity:.35;
  cursor:not-allowed;
  filter:grayscale(1);
}
#restore-original-btn{
  margin:.4rem 0 0 .4rem;
  padding:.45rem .8rem;
  border-radius:12px;
  border:1px solid var(--bd);
  background:var(--bg);
  background-image:var(--g);
  -webkit-background-clip:text;
  background-clip:text;
  -webkit-text-fill-color:transparent;
  color:transparent;
  cursor:pointer;
}
#restore-original-btn[disabled]{
  opacity:.35; cursor:not-allowed; filter:grayscale(1);
}

/* PATCH: Match question box color to welcome page (closer to black) */
#quiz-card{ background:#1f2937; } /* ensure wrapper matches */
.choice{ background:#1f2937; }    /* choices match the darker welcome card */

/* PATCH: results heatmap (non-interfering, left dock) */
#heatmap-toggle{position:fixed;left:12px;bottom:12px;z-index:60;display:inline-flex;align-items:center;justify-content:center;width:40px;height:40px;border-radius:999px;background:var(--bg, #0f172a);border:1px solid var(--bd, rgba(255,255,255,.12));color:var(--fg, #e5e7eb);box-shadow:0 4px 14px rgba(0,0,0,.25);cursor:pointer;font-weight:700}
#heatmap-toggle:hover{transform:translateY(-1px);transition:transform .15s ease}
#heatmap-panel{position:fixed;left:12px;bottom:60px;width:320px;max-width:90vw;max-height:300px;padding:12px;border-radius:14px;z-index:60;background:var(--bg, #0b1220);border:1px solid var(--bd, rgba(255,255,255,.1));box-shadow:0 18px 40px rgba(0,0,0,.35);display:none}
#heatmap-panel.hshow{display:block}
.hm-head{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;font-size:.9rem;color:var(--fg, #e5e7eb)}
.hm-grid{display:grid;grid-template-columns:repeat(20, minmax(0,1fr));gap:4px}
.hm-cell{width:14px;height:14px;border-radius:4px;border:1px solid rgba(255,255,255,.12);opacity:.95}
.hm-cell.correct{background:#16a34a} /* green */
.hm-cell.wrong{background:#dc2626}   /* red */
.hm-cell.unanswered{background:#6b7280} /* neutral */
.hm-legend{display:flex;gap:8px;margin-top:8px;align-items:center;flex-wrap:wrap;color:var(--fg,#e5e7eb);font-size:.8rem;opacity:.9}
.hm-dot{display:inline-block;width:10px;height:10px;border-radius:3px;border:1px solid rgba(255,255,255,.2);vertical-align:middle;margin-right:4px}
.hm-dot.green{background:#16a34a}.hm-dot.red{background:#dc2626}.hm-dot.gray{background:#6b7280}

/* PATCH: tools suite (timer/progress/export/import/cheatsheet) */
#tools-toggle{position:fixed;left:12px;bottom:112px;z-index:60;display:inline-flex;align-items:center;justify-content:center;width:40px;height:40px;border-radius:999px;background:var(--bg,#0f172a);border:1px solid var(--bd,rgba(255,255,255,.12));color:var(--fg,#e5e7eb);box-shadow:0 4px 14px rgba(0,0,0,.25);cursor:pointer;font-weight:700}
#tools-toggle:hover{transform:translateY(-1px);transition:transform .15s ease}
#tools-panel{position:fixed;left:12px;bottom:160px;width:360px;max-width:92vw;max-height:60vh;overflow:auto;padding:12px;border-radius:14px;z-index:60;background:var(--bg,#0b1220);border:1px solid var(--bd,rgba(255,255,255,.1));box-shadow:0 20px 44px rgba(0,0,0,.35);display:none}
#tools-panel.tshow{display:block}
.tools-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:6px 0}
.tools-btn{padding:6px 10px;border-radius:8px;border:1px solid var(--bd,rgba(255,255,255,.15));background:rgba(255,255,255,.04);color:var(--fg,#e5e7eb);cursor:pointer}
.tools-btn:hover{filter:brightness(1.1)}
.tools-label{color:var(--fg,#e5e7eb);opacity:.9;font-size:.9rem}
#timer-pill{position:fixed;left:64px;bottom:112px;height:28px;display:flex;align-items:center;gap:10px;padding:0 10px;border-radius:999px;border:1px solid var(--bd,rgba(255,255,255,.12));background:var(--bg,#0f172a);color:var(--fg,#e5e7eb);z-index:60}
#progress-mini{position:fixed;left:64px;bottom:144px;height:8px;width:200px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid var(--bd,rgba(255,255,255,.1));overflow:hidden;z-index:60}
#progress-mini > i{display:block;height:100%;width:0%;background:linear-gradient(90deg,#22c55e,#16a34a);transition:width .3s}
#shortcut-modal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;z-index:70}
#shortcut-modal .inner{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:min(560px,92vw);background:var(--bg,#0b1220);border:1px solid var(--bd,rgba(255,255,255,.12));border-radius:14px;box-shadow:0 30px 60px rgba(0,0,0,.45);padding:16px;color:var(--fg,#e5e7eb)}
.kbd{display:inline-block;min-width:22px;padding:2px 6px;border:1px solid rgba(255,255,255,.2);border-bottom-width:2px;border-radius:6px;font-family:ui-monospace,monospace;font-size:.85rem;margin:0 2px;background:rgba(255,255,255,.06)}
#tools-panel .caption{font-size:.8rem;opacity:.75}
#tools-panel hr{border:none;border-top:1px solid rgba(255,255,255,.08);margin:8px 0}
#tools-close{background:transparent;border:0;color:inherit;font-size:14px;cursor:pointer}
input[type="file"].hidden-tools-input{display:none}

/* PATCH: remove heatmap UI */
#heatmap-toggle, #heatmap-panel { display: none !important; }

/* PATCH: timer bottom-left; remove progress bar; hide open-in-new-tab */
#timer-pill{ left:12px !important; bottom:12px !important; }
#progress-mini{ display:none !important; }
#open-tab-btn{ display:none !important; }

/* PATCH: place tools-toggle (≡) to the left of the timer and keep timer bottom-left */
#tools-toggle{ left:12px !important; bottom:12px !important; position:fixed !important; z-index:60 !important; }
#timer-pill{ left:56px !important; bottom:12px !important; position:fixed !important; z-index:60 !important; }

/* PATCH: shortcut modal z-index fix */
#shortcut-modal{ z-index: 2147483647 !important; }
#shortcut-modal .inner{ z-index: 2147483647 !important; }

/* PATCH: remove export buttons only */
#ex-study, #ex-snap { display: none !important; }

/* PATCH: remove import snapshot */
#im-snap, #snap-file { display: none !important; }
</style>
<script>
// PATCH: robust wrong-only export + 'E' (evidence) and 'S' (strike) shortcuts
(function(){
  try{
    var d=document;

    function readJSON(k){ try{ var v=localStorage.getItem(k); return v? JSON.parse(v): null; }catch(_e){ return null; } }
    function writeJSON(k,v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(_e){} }
    function keys(){ try{ return (typeof getKeys==='function')? getKeys(): null; }catch(_e){ return null; } }
    function QKEY(){ var k=keys(); return k? k.QKEY : (typeof QUESTIONS_KEY==='string'?QUESTIONS_KEY:'quiz_questions'); }
    function SKEY(){ return (typeof STORAGE_KEY==='string')? STORAGE_KEY : 'quiz'; }
    function PROG(){ var p=(typeof PROG_KEY==='string')? PROG_KEY : (SKEY()+'_progress'); return p; }

    function getQuestions(){ var qs=readJSON(QKEY()); return Array.isArray(qs)? qs: []; }
    function getProgress(){ return readJSON(PROG()) || {}; }

    // --- selection extraction ------------------------------------------------
    function coerceSelection(i, q, progress){
      var candidates = [];
      var fields = ['answers','ans','responses','userAnswers','selections','selected','choices','picked'];
      for(var f=0; f<fields.length; f++){
        var obj = progress && progress[fields[f]];
        if(obj && typeof obj==='object'){
          if(typeof obj[i] !== 'undefined') candidates.push(obj[i]);
          if(typeof obj[String(i)] !== 'undefined') candidates.push(obj[String(i)]);
        }
      }
      // Fallback: look for separate LS keys likely holding answers
      if(!candidates.length){
        try{
          for(var k=0;k<localStorage.length;k++){
            var key = localStorage.key(k);
            if(!key) continue;
            var low = key.toLowerCase();
            if(low.indexOf('answer')===-1 && low.indexOf('select')===-1 && low.indexOf('response')===-1) continue;
            if(low.indexOf(SKEY().toLowerCase())===-1 && low.indexOf('quiz')===-1) continue;
            var val = readJSON(key);
            if(Array.isArray(val)){
              if(typeof val[i] !== 'undefined') candidates.push(val[i]);
              if(typeof val[String(i)] !== 'undefined') candidates.push(val[String(i)]);
            }else if(val && typeof val==='object'){
              if(typeof val[i] !== 'undefined') candidates.push(val[i]);
              if(typeof val[String(i)] !== 'undefined') candidates.push(val[String(i)]);
            }
          }
        }catch(_e){}
      }
      // Decode candidate to numeric index
      for(var c=0;candidates.length && c<candidates.length; c++){
        var s = candidates[c];
        if(s==null) continue;
        if(typeof s === 'number' && isFinite(s)) return s|0;
        if(typeof s === 'string'){
          var t=s.trim();
          if(/^\d+$/.test(t)) return parseInt(t,10);
          if(/^[A-Za-z]$/.test(t)){
            var idx = t.toUpperCase().charCodeAt(0) - 65;
            if(Array.isArray(q.c) && idx>=0 && idx<q.c.length) return idx;
          }
          if(Array.isArray(q.c)){
            for(var ci=0; ci<q.c.length; ci++){
              if(String(q.c[ci]).trim().toLowerCase() === t.toLowerCase()) return ci;
            }
          }
        }
        if(typeof s === 'object'){
          if(typeof s.index === 'number') return s.index|0;
          if(typeof s.i === 'number') return s.i|0;
          if(typeof s.choice === 'number') return s.choice|0;
          if(typeof s.choice === 'string'){
            var t2=String(s.choice).trim();
            if(/^\d+$/.test(t2)) return parseInt(t2,10);
            var idx2 = t2.toUpperCase && (t2.toUpperCase().charCodeAt(0)-65);
            if(idx2>=0 && Array.isArray(q.c) && idx2<q.c.length) return idx2;
          }
          if(typeof s.text === 'string' && Array.isArray(q.c)){
            var t3 = s.text.trim().toLowerCase();
            for(var cj=0;cj<q.c.length;cj++){
              if(String(q.c[cj]).trim().toLowerCase()===t3) return cj;
            }
          }
        }
      }
      return null;
    }

    function coerceCorrectness(i, progress){
      var flags = ['correct','isCorrect','results','result','score','scores'];
      for(var f=0; f<flags.length; f++){
        var obj = progress && progress[flags[f]];
        if(obj && typeof obj==='object'){
          var v = (typeof obj[i] !== 'undefined')? obj[i] : obj[String(i)];
          if(typeof v === 'boolean') return v;
          if(v === 1 || v === '1' || v === 'true' || v === 'correct') return true;
          if(v === 0 || v === '0' || v === 'false' || v === 'wrong' || v === 'incorrect') return false;
        }
      }
      // Fallback: search LS for correctness-like arrays
      try{
        for(var k=0;k<localStorage.length;k++){
          var key = localStorage.key(k); if(!key) continue;
          var low=key.toLowerCase();
          if(low.indexOf('correct')===-1 && low.indexOf('result')===-1 && low.indexOf('score')===-1) continue;
          var val = readJSON(key);
          if(Array.isArray(val)){
            var v = val[i]; if(typeof v==='boolean') return v;
            if(v===1||v==='1'||v==='true'||v==='correct') return true;
            if(v===0||v==='0'||v==='false'||v==='wrong'||v==='incorrect') return false;
          }else if(val && typeof val==='object'){
            var vv = (typeof val[i]!=='undefined')? val[i] : val[String(i)];
            if(typeof vv==='boolean') return vv;
          }
        }
      }catch(_e){}
      return null;
    }

    function computeWrong(){
      var qs = getQuestions();
      var p = getProgress();
      var wrong = [];
      for(var i=0;i<qs.length;i++){
        var q = qs[i]||{};
        var a = (typeof q.a!=='undefined')? Number(q.a) : null;
        var sel = coerceSelection(i, q, p);
        if(sel==null){
          var flag = coerceCorrectness(i, p);
          if(flag===false) wrong.push(i);
        }else{
          if(a==null || Number(sel)!==Number(a)) wrong.push(i);
        }
      }
      return wrong;
    }

    function exportStudyGuideFixed(ev){
      if(ev && typeof ev.preventDefault==='function') ev.preventDefault();
      try{
        var qs = getQuestions();
        var wr = computeWrong();
        var rows = [];
        for(var w=0; w<wr.length; w++){
          var i = wr[w];
          var q = qs[i] || {};
          var correctIdx = (typeof q.a==='number')? q.a : null;
          var correctText = (correctIdx!=null && Array.isArray(q.c))? q.c[correctIdx] : '(n/a)';
          rows.push(
            '<section style="margin:0 0 16px 0;padding:12px;border:1px solid rgba(0,0,0,.2);border-radius:10px;background:#0b1220;color:#e5e7eb">'
            + '<h3 style="margin:0 0 6px 0;font-size:16px">Q'+(i+1)+'. '+ (q.q||'') +'</h3>'
            + '<div><b>Correct:</b> '+ (correctText||'') +'</div>'
            + '<div style="margin-top:6px"><b>Why:</b> '+ (q.e||'See explanation') +'</div>'
            + '<div style="margin-top:6px;opacity:.8"><b>Evidence:</b> '+ (q._meta&&q._meta.evidence?q._meta.evidence:'') +'</div>'
            + '</section>'
          );
        }
        var html = '<!doctype html><meta charset="utf-8"><title>Study Guide (Wrong Only)</title>'
          + '<body style="background:#0a0f1a;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:20px">'
          + '<h1 style="color:#e5e7eb">Study Guide – Wrong Questions</h1>'
          + (rows.length? rows.join('') : '<p style="color:#e5e7eb">No wrong answers yet 🎉</p>')
          + '</body>';
        var blob = new Blob([html], {type:'text/html'});
        var url = URL.createObjectURL(blob);
        var a = d.createElement('a'); a.href=url; a.download='study_guide_wrong.html';
        d.body.appendChild(a); a.click(); setTimeout(function(){ URL.revokeObjectURL(url); a.remove(); }, 1200);
      }catch(e){ /* silent */ }
    }

    function attachExportFix(){
      var btn = d.getElementById('ex-study'); if(!btn) return;
      if(btn.__fixed) return;
      var clone = btn.cloneNode(true); btn.parentNode.replaceChild(clone, btn);
      clone.addEventListener('click', exportStudyGuideFixed, false);
      clone.__fixed = 1;
    }

    // --- 'E' toggles evidence/resources panel -------------------------------
    function tryToggleEvidence(){
      // Prefer clicking an existing toggle button to respect app logic
      var toggles = Array.prototype.slice.call(d.querySelectorAll('button, [role="button"], .btn, .toggle'));
      for(var i=0;i<toggles.length;i++){
        var t = toggles[i]; var txt = (t.textContent||'').toLowerCase();
        if(/evidence|resources|show evidence|hide evidence|evidence panel|resources panel/.test(txt)){
          t.click();
          return true;
        }
      }
      // Fallback: toggle #pdf-pane visibility
      var pane = d.getElementById('pdf-pane');
      if(pane){
        var showing = pane.style.display !== 'none';
        pane.style.display = showing ? 'none' : '';
        return true;
      }
      return false;
    }

    // --- 'S' strike/unstrike current choice ---------------------------------
    var __lastHoverChoice = null;
    d.addEventListener('mousemove', function(e){
      try{
        var el = e.target;
        var cand = el && el.closest && el.closest('[data-choice-index], .choice, .answer, .option, li');
        if(cand) __lastHoverChoice = cand;
      }catch(_e){}
    }, false);

    function toggleStrikeOn(el){
      if(!el) return false;
      if(el.hasAttribute('data-strike')){
        el.removeAttribute('data-strike'); el.classList.remove('struck');
      }else{
        el.setAttribute('data-strike','1'); el.classList.add('struck');
      }
      return true;
    }

    function strikeFocusedChoice(){
      var active = d.activeElement;
      var el = (active && active.closest)? active.closest('[data-choice-index], .choice, .answer, .option, li') : null;
      if(!el) el = __lastHoverChoice;
      if(!el){
        // try selected/checked radio/choice
        var selected = d.querySelector('.selected, [aria-checked="true"], input[type="radio"]:checked');
        if(selected) el = selected.closest('[data-choice-index], .choice, .answer, .option, li');
      }
      return toggleStrikeOn(el);
    }

    // Keyboard listeners: do not interfere with typing
    d.addEventListener('keydown', function(e){
      if(e.defaultPrevented) return;
      var tag = (e.target && e.target.tagName || '').toLowerCase();
      if(tag==='input' || tag==='textarea' || e.isComposing) return;
      if(e.key==='e' || e.key==='E'){
        tryToggleEvidence();
      }else if(e.key==='s' || e.key==='S'){
        strikeFocusedChoice();
      }
    }, false);

    function boot(){
      attachExportFix();
    }
    if(d.readyState==='loading'){ d.addEventListener('DOMContentLoaded', boot, {once:true}); }
    else { boot(); }

  }catch(_e){ /* silent */ }
})();

// PATCH: physically remove export buttons (wrong answers & snapshot)
(function(){
  try{
    var d=document;
    function rm(id){ var el=d.getElementById(id); if(el && el.parentNode){ el.parentNode.removeChild(el); } }
    function boot(){ rm('ex-study'); rm('ex-snap'); }
    if(d.readyState==='loading'){ d.addEventListener('DOMContentLoaded', boot, {once:true}); }
    else { boot(); }
  }catch(_e){ /* silent */ }
})();

// PATCH: physically remove import snapshot button & file input
(function(){
  try{
    var d=document;
    function rm(id){ var el=d.getElementById(id); if(el && el.parentNode){ el.parentNode.removeChild(el); } }
    function boot(){ rm('im-snap'); rm('snap-file'); }
    if(d.readyState==='loading'){ d.addEventListener('DOMContentLoaded', boot, {once:true}); }
    else { boot(); }
  }catch(_e){ /* silent */ }
})();

// PATCH: remove "Study Guide:" and "Session:" rows
(function(){
  try{
    var d=document;
    function norm(t){ return String(t||'').replace(/[:\s]/g,'').toLowerCase(); }
    function boot(){
      var rows = d.querySelectorAll('#tools-panel .tools-row');
      for(var i=0;i<rows.length;i++){
        var r = rows[i];
        var lab = r.querySelector('.tools-label');
        if(!lab) continue;
        var n = norm(lab.textContent);
        if(n==='studyguide' || n==='session'){
          if(r && r.parentNode) r.parentNode.removeChild(r);
        }
      }
    }
    if(d.readyState==='loading'){ d.addEventListener('DOMContentLoaded', boot, {once:true}); }
    else { boot(); }
  }catch(_e){ /* silent */ }
})();
</script>